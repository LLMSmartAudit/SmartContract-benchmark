nameid,content,tokens,LoC,Security issue,VulnNumber
8_NFTXEligiblityManager.sol,"pragma solidity 0.6.8;

import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./proxy/ClonesUpgradeable.sol"";

contract NFTXEligibilityManager is OwnableUpgradeable {
  INFTXVaultFactory public nftxVaultFactory;

  struct EligibilityModule {
    address impl;
  }
  EligibilityModule[] public modules;

  function __NFTXEligibilityManager_init() public initializer {
    __Ownable_init();
  }

  function addModule(address implementation) public onlyOwner {
    EligibilityModule memory module = EligibilityModule(implementation);
    modules.push(module);
  }

  function updateModule(uint256 index, address implementation) public onlyOwner {
    modules[index].impl = implementation;
  }

  function deployEligibility(uint256 moduleIndex, bytes calldata configData) external virtual returns (address) {
    address eligImpl = modules[moduleIndex].impl;
    address eligibilityClone = ClonesUpgradeable.clone(eligImpl);
    INFTXEligibility(eligibilityClone).__NFTXEligibility_init_bytes(configData);
    return eligibilityClone;
  }

  function allModules() external view returns (EligibilityModule[] memory) {
    return modules;
  }
}",282,39,"H-02: distribute DoS on missing receiveRewards implementation NFTXEligiblityManager._sendForReceiver should check returnData.length == 1 before decoding. Otherwise, if it returns no return data, the abi.decode call will revert and with it the whole distribute function .
A single poorly implemented feeReceiver can break the whole distribute function and allow a denial of service by reverting the transaction. M-05: Unbounded iteration in NFTXEligiblityManager.distribute over _feeReceivers NFTXEligiblityManager.distribute iterates over all _feeReceivers. If the number of _feeReceivers gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call distribute at all.",2
35_ConcentratedLiquidityPosition.sol,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IConcentratedLiquidityPool.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/ITridentRouter.sol"";
import ""../../libraries/concentratedPool/FullMath.sol"";
import ""./TridentNFT.sol"";
import ""hardhat/console.sol"";

/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.
abstract contract ConcentratedLiquidityPosition is TridentNFT {
    event Mint(address indexed pool, address indexed recipient, uint256 indexed positionId);
    event Burn(address indexed pool, address indexed owner, uint256 indexed positionId);

    address public immutable wETH;
    IBentoBoxMinimal public immutable bento;
    IMasterDeployer public immutable masterDeployer;

    mapping(uint256 => Position) public positions;

    struct Position {
        IConcentratedLiquidityPool pool;
        uint128 liquidity;
        int24 lower;
        int24 upper;
        uint256 feeGrowthInside0; 
        /// @dev Per unit of liquidity.
        uint256 feeGrowthInside1;
    }

    constructor(address _wETH, address _masterDeployer) {
        wETH = _wETH;
        masterDeployer = IMasterDeployer(_masterDeployer);
        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());
    }

    function positionMintCallback(
        address recipient,
        int24 lower,
        int24 upper,
        uint128 amount,
        uint256 feeGrowthInside0,
        uint256 feeGrowthInside1
    ) external returns (uint256 positionId) {
        require(IMasterDeployer(masterDeployer).pools(msg.sender), ""NOT_POOL"");
        positions[totalSupply] = Position(IConcentratedLiquidityPool(msg.sender), amount, lower, upper, feeGrowthInside0, feeGrowthInside1);
        positionId = totalSupply;
        _mint(recipient);
        emit Mint(msg.sender, recipient, positionId);
    }

    function burn(
        uint256 tokenId,
        uint128 amount,
        address recipient,
        bool unwrapBento
    ) external {
        require(msg.sender == ownerOf[tokenId], ""NOT_ID_OWNER"");
        Position storage position = positions[tokenId];
        if (position.liquidity < amount) amount = position.liquidity;

        position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento));

        if (amount < position.liquidity) {
            position.liquidity -= amount;
        } else {
            delete positions[tokenId];
            _burn(tokenId);
        }
        emit Burn(address(position.pool), msg.sender, tokenId);
    }

    function collect(
        uint256 tokenId,
        address recipient,
        bool unwrapBento
    ) external returns (uint256 token0amount, uint256 token1amount) {
        require(msg.sender == ownerOf[tokenId], ""NOT_ID_OWNER"");

        Position storage position = positions[tokenId];

        (address token0, address token1) = _getAssets(position.pool);

        {
            (uint256 feeGrowthInside0, uint256 feeGrowthInside1) = position.pool.rangeFeeGrowth(position.lower, position.upper);
            token0amount = FullMath.mulDiv(
                feeGrowthInside0 - position.feeGrowthInside0,
                position.liquidity,
                0x100000000000000000000000000000000
            );
            token1amount = FullMath.mulDiv(
                feeGrowthInside1 - position.feeGrowthInside1,
                position.liquidity,
                0x100000000000000000000000000000000
            );

            position.feeGrowthInside0 = feeGrowthInside0;
            position.feeGrowthInside1 = feeGrowthInside1;
        }

        uint256 balance0 = bento.balanceOf(token0, address(this));
        uint256 balance1 = bento.balanceOf(token1, address(this));
        if (balance0 < token0amount || balance1 < token1amount) {
            (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);

            uint256 newBalance0 = amount0fees + balance0;
            uint256 newBalance1 = amount1fees + balance1;

            /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw
            if (token0amount > newBalance0) token0amount = newBalance0;
            if (token1amount > newBalance1) token1amount = newBalance1;
        }
        _transfer(token0, address(this), recipient, token0amount, unwrapBento);
        _transfer(token1, address(this), recipient, token1amount, unwrapBento);
    }

    function _getAssets(IConcentratedLiquidityPool pool) internal view returns (address token0, address token1) {
        address[] memory pair = pool.getAssets();
        token0 = pair[0];
        token1 = pair[1];
    }

    function _transfer(
        address token,
        address from,
        address to,
        uint256 shares,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token, from, to, 0, shares);
        } else {
            bento.transfer(token, from, to, shares);
        }
    }
}",1188,140,"H-06: ConcentratedLiquidityPosition.sol#collect() Users may get double the amount of yield when they call collect() before burn() When a user calls ConcentratedLiquidityPosition.sol#collect() to collect their yield, it calcuates the yield based on position.pool.rangeFeeGrowth() and position.feeGrowthInside0, position.feeGrowthInside1: ConcentratedLiquidityPosition.sol#75 L101
When there are enough tokens in bento.balanceOf, it will not call position.pool.collect() to collect fees from the pool. This makes the user who collect() their yield when there is enough balance to get double yield when they call burn() to remove liquidity. Because burn() will automatically collect fees on the pool contract. H-07: ConcentratedLiquidityPosition.sol#burn() Wrong implementation allows attackers to steal yield When a user calls ConcentratedLiquidityPosition.sol#burn() to burn their liquidity, it calls ConcentratedLiquidityPool.sol#burn() -> _updatePosition(): ConcentratedLiquidityPosition.sol#525 L101 The _updatePosition() function will return amount0fees and amount1fees of the whole position with the lower and upper tick and send them to the recipient alongside the burned liquidity amounts.",2
44_Swap.sol,"pragma solidity ^0.8.0;

import ""../governance/EmergencyPausable.sol"";
import ""../utils/Math.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Swap is EmergencyPausable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    using Math for uint256;

    /// @notice An address to receive swap fees. The 0 address prevents fee
    ///         withdrawal.
    address payable public feeRecipient;
    /// @notice divide by the SWAP_FEE_DIVISOR to get the fee ratio, deducted
    ///         from the proceeds of each swap.
    uint256 public swapFee;
    uint256 public constant SWAP_FEE_DIVISOR = 100_000;

    event SwappedTokens(
        address tokenSold,
        address tokenBought,
        uint256 amountSold,
        uint256 amountBought,
        uint256 amountBoughtFee
    );

    event NewSwapFee(
        uint256 newSwapFee
    );

    event NewFeeRecipient(
        address newFeeRecipient
    );

    event FeesSwept(
        address token,
        uint256 amount,
        address recipient
    );

    /// @param owner_ A new contract owner, expected to implement
    ///               TimelockGovernorWithEmergencyGovernance.
    /// @param feeRecipient_ A payable address to receive swap fees. Setting the
    ///        0 address prevents fee withdrawal, and can be set later by
    ///        governance.
    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee
    ///                 ratio charged for each swap.
    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {
        require(owner_ != address(0), ""Swap::constructor: Owner must not be 0"");
        transferOwnership(owner_);
        feeRecipient = feeRecipient_;
        emit NewFeeRecipient(feeRecipient);
        swapFee = swapFee_;
        emit NewSwapFee(swapFee);
    }

    /// @notice Set the fee taken from each swap's proceeds.
    /// @dev Only timelocked governance can set the swap fee.
    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee ratio.
    function setSwapFee(uint256 swapFee_) external onlyTimelock {
        require(swapFee_ < SWAP_FEE_DIVISOR, ""Swap::setSwapFee: Swap fee must not exceed 100%"");
        swapFee = swapFee_;
        emit NewSwapFee(swapFee);
    }

    /// @notice Set the address permitted to receive swap fees.
    /// @dev Only timelocked governance can set the fee recipient.
    /// @param feeRecipient_ A payable address to receive swap fees. Setting the
    ///        0 address prevents fee withdrawal.
    function setFeeRecipient(address payable feeRecipient_) external onlyTimelock {
        feeRecipient = feeRecipient_;
        emit NewFeeRecipient(feeRecipient);
    }

    /// @notice Swap by filling a 0x quote.
    /// @dev Execute a swap by filling a 0x quote, as provided by the 0x API.
    ///      Charges a governable swap fee that comes out of the bought asset,
    ///      be it token or ETH. Unfortunately, the fee is also charged on any
    ///      refunded ETH from 0x protocol fees due to an implementation oddity.
    ///      This behavior shouldn't impact most users.
    ///
    ///      Learn more about the 0x API and quotes at https://0x.org/docs/api
    /// @param zrxSellTokenAddress The contract address of the token to be sold,
    ///        as returned by the 0x `/swap/v1/quote` API endpoint. If selling
    ///        unwrapped ETH included via msg.value, this should be address(0)
    /// @param amountToSell Amount of token to sell, with the same precision as
    ///        zrxSellTokenAddress. This information is also encoded in zrxData.
    ///        If selling unwrapped ETH via msg.value, this should be 0.
    /// @param zrxBuyTokenAddress The contract address of the token to be bought,
    ///        as returned by the 0x `/swap/v1/quote` API endpoint. To buy
    ///        unwrapped ETH, use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`
    /// @param minimumAmountReceived The minimum amount expected to be received
    ///        from filling the quote, before the swap fee is deducted, in
    ///        zrxBuyTokenAddress. Reverts if not met
    /// @param zrxAllowanceTarget Contract address that needs to be approved for
    ///        zrxSellTokenAddress, as returned by the 0x `/swap/v1/quote` API
    ///        endpoint. Should be address(0) for purchases uses unwrapped ETH
    /// @param zrxTo Contract to fill the 0x quote, as returned by the 0x
    ///        `/swap/v1/quote` API endpoint
    /// @param zrxData Data encoding the 0x quote, as returned by the 0x
    ///        `/swap/v1/quote` API endpoint
    /// @param deadline Timestamp after which the swap will be reverted.
    function swapByQuote(
        address zrxSellTokenAddress,
        uint256 amountToSell,
        address zrxBuyTokenAddress,
        uint256 minimumAmountReceived,
        address zrxAllowanceTarget,
        address payable zrxTo,
        bytes calldata zrxData,
        uint256 deadline
    ) external payable whenNotPaused nonReentrant {
        require(
            block.timestamp <= deadline,
            ""Swap::swapByQuote: Deadline exceeded""
        );
        require(
            !signifiesETHOrZero(zrxSellTokenAddress) || msg.value > 0,
            ""Swap::swapByQuote: Unwrapped ETH must be swapped via msg.value""
        );

        // if zrxAllowanceTarget is 0, this is an ETH sale
        if (zrxAllowanceTarget != address(0)) {
            // transfer tokens to this contract
            IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell);
            // approve token transfer to 0x contracts
            // TODO (handle approval special cases like USDT, KNC, etc)
            IERC20(zrxSellTokenAddress).safeIncreaseAllowance(zrxAllowanceTarget, amountToSell);
        }

        // execute 0x quote
        (uint256 boughtERC20Amount, uint256 boughtETHAmount) = fillZrxQuote(
            IERC20(zrxBuyTokenAddress),
            zrxTo,
            zrxData,
            msg.value
        );

        require(
            (
                !signifiesETHOrZero(zrxBuyTokenAddress) &&
                boughtERC20Amount >= minimumAmountReceived
            ) ||
            (
                signifiesETHOrZero(zrxBuyTokenAddress) &&
                boughtETHAmount >= minimumAmountReceived
            ),
            ""Swap::swapByQuote: Minimum swap proceeds requirement not met""
        );
        if (boughtERC20Amount > 0) {
            // take the swap fee from the ERC20 proceeds and return the rest
            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);
            IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);
            // return any refunded ETH
            payable(msg.sender).transfer(boughtETHAmount);

            emit SwappedTokens(
                zrxSellTokenAddress,
                zrxBuyTokenAddress,
                amountToSell,
                boughtERC20Amount,
                boughtERC20Amount.sub(toTransfer)
            );
        } else {

            // take the swap fee from the ETH proceeds and return the rest. Note
            // that if any 0x protocol fee is refunded in ETH, it also suffers
            // the swap fee tax
            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);
            payable(msg.sender).transfer(toTransfer);
            emit SwappedTokens(
                zrxSellTokenAddress,
                zrxBuyTokenAddress,
                amountToSell,
                boughtETHAmount,
                boughtETHAmount.sub(toTransfer)
            );
        }
        if (zrxAllowanceTarget != address(0)) {
            // remove any dangling token allowance
            IERC20(zrxSellTokenAddress).safeApprove(zrxAllowanceTarget, 0);
        }
    }

    /// @notice Fill a 0x quote as provided by the API, and return any ETH or
    ///         ERC20 proceeds.
    /// @dev Learn more at https://0x.org/docs/api
    /// @param zrxBuyTokenAddress The contract address of the token to be bought,
    ///        as provided by the 0x API. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`
    ///        signifies the user is buying unwrapped ETH.
    /// @param zrxTo Contract to fill the 0x quote, as provided by the 0x API
    /// @param zrxData Data encoding the 0x quote, as provided by the 0x API
    /// @param ethAmount The amount of ETH required to fill the quote, including
    ///        any ETH being traded as well as protocol fees
    /// @return any positive `zrxBuyTokenAddress` ERC20 balance change, as well
    ///         as any positive ETH balance change
    function fillZrxQuote(
        IERC20 zrxBuyTokenAddress,
        address payable zrxTo,
        bytes calldata zrxData,
        uint256 ethAmount
    ) internal returns (uint256, uint256) {
        uint256 originalERC20Balance = 0;
        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {
            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));
        }
        uint256 originalETHBalance = address(this).balance;

        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);
        require(success, ""Swap::fillZrxQuote: Failed to fill quote"");

        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);
        uint256 erc20Delta;
        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {
            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);
            require(erc20Delta > 0, ""Swap::fillZrxQuote: Didn't receive bought token"");
        } else {
            require(ethDelta > 0, ""Swap::fillZrxQuote: Didn't receive bought ETH"");
        }

        return (erc20Delta, ethDelta);
    }

    /// @notice Test whether an address is zero, or the magic address the 0x
    ///         platform uses to signify ""unwrapped ETH"" rather than an ERC20.
    /// @param tokenAddress An address that might point toward an ERC-20.
    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {
        return (
            tokenAddress == address(0) ||
            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)
        );
    }

    /// @notice Sweeps accrued ETH and ERC20 swap fees to the pre-established
    ///         fee recipient address.
    /// @dev Fees are tracked based on the contract's balances, rather than
    ///      using any additional bookkeeping. If there are bugs in swap
    ///      accounting, this function could jeopardize funds.
    /// @param tokens An array of ERC20 contracts to withdraw token fees
    function sweepFees(
        address[] calldata tokens
    ) external nonReentrant {
        require(
            feeRecipient != address(0),
            ""Swap::withdrawAccruedFees: feeRecipient is not initialized""
        );
        for (uint8 i = 0; i<tokens.length; i++) {
            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));
            if (balance > 0) {
                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);
                emit FeesSwept(tokens[i], balance, feeRecipient);
            }
        }
        feeRecipient.transfer(address(this).balance);
        emit FeesSwept(address(0), address(this).balance, feeRecipient);
    }

    fallback() external payable {}
    receive() external payable {}
}",2733,264,"H-01 Arbitrary contract call allows attackers to steal ERC20 from users' wallets Swap.sol L220-L212 A call to an arbitrary contract with custom calldata is made in fillZrxQuote(), which means the contract can be an ERC20 token, and the calldata can be transferFrom a previously approved user.
H-02 Wrong calculation of erc20Delta and ethDelta Swap.sol L200-L225 When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, ethDelta will always be 0. That's because originalETHBalance already includes the msg.value sent by the caller. M-01: Swap.sol implements potentially dangerous transfer The use of transfer() in Swap.sol may have unintended outcomes on the eth being sent to the receiver. Eth may be irretrievable or undelivered if the msg.sender or feeRecipient is a smart contract. M-02 Unused ERC20 tokens are not refunded Based on the context and comments in the code, we assume that it's possible that there will be some leftover sell tokens, not only when users are selling unwrapped ETH but also for ERC20 tokens. However, in the current implementation, only refunded ETH is returned (L158). Because of this, the leftover tkoens may be left in the contract unintentionally.",4
3_MarginRouter.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol"";
import ""../libraries/UniswapStyleLib.sol"";

import ""./RoleAware.sol"";
import ""./Fund.sol"";
import ""../interfaces/IMarginTrading.sol"";
import ""./Lending.sol"";
import ""./Admin.sol"";
import ""./IncentivizedHolder.sol"";

/// @title Top level transaction controller
contract MarginRouter is RoleAware, IncentivizedHolder, Ownable {
    /// @notice wrapped ETH ERC20 contract
    address public immutable WETH;
    uint256 public constant mswapFeesPer10k = 10;

    /// emitted when a trader depoits on cross margin
    event CrossDeposit(
        address trader,
        address depositToken,
        uint256 depositAmount
    );
    /// emitted whenever a trade happens
    event CrossTrade(
        address trader,
        address inToken,
        uint256 inTokenAmount,
        uint256 inTokenBorrow,
        address outToken,
        uint256 outTokenAmount,
        uint256 outTokenExtinguish
    );
    /// emitted when a trader withdraws funds
    event CrossWithdraw(
        address trader,
        address withdrawToken,
        uint256 withdrawAmount
    );
    /// emitted upon sucessfully borrowing
    event CrossBorrow(
        address trader,
        address borrowToken,
        uint256 borrowAmount
    );

    /// emmited on deposit-borrow-withdraw
    event CrossOvercollateralizedBorrow(
        address trader,
        address depositToken,
        uint256 depositAmount,
        address borrowToken,
        uint256 withdrawAmount
    );

    modifier ensure(uint256 deadline) {
        require(deadline >= block.timestamp, ""Trade has expired"");
        _;
    }

    constructor(address _WETH, address _roles) RoleAware(_roles) {
        WETH = _WETH;
    }

    /// @notice traders call this to deposit funds on cross margin
    function crossDeposit(address depositToken, uint256 depositAmount)
        external
    {
        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);

        uint256 extinguishAmount =
            IMarginTrading(marginTrading()).registerDeposit(
                msg.sender,
                depositToken,
                depositAmount
            );
        if (extinguishAmount > 0) {
            Lending(lending()).payOff(depositToken, extinguishAmount);
            withdrawClaim(msg.sender, depositToken, extinguishAmount);
        }
        emit CrossDeposit(msg.sender, depositToken, depositAmount);
    }

    /// @notice deposit wrapped ehtereum into cross margin account
    function crossDepositETH() external payable {
        Fund(fund()).depositToWETH{value: msg.value}();
        uint256 extinguishAmount =
            IMarginTrading(marginTrading()).registerDeposit(
                msg.sender,
                WETH,
                msg.value
            );
        if (extinguishAmount > 0) {
            Lending(lending()).payOff(WETH, extinguishAmount);
            withdrawClaim(msg.sender, WETH, extinguishAmount);
        }
        emit CrossDeposit(msg.sender, WETH, msg.value);
    }

    /// @notice withdraw deposits/earnings from cross margin account
    function crossWithdraw(address withdrawToken, uint256 withdrawAmount)
        external
    {
        IMarginTrading(marginTrading()).registerWithdrawal(
            msg.sender,
            withdrawToken,
            withdrawAmount
        );
        Fund(fund()).withdraw(withdrawToken, msg.sender, withdrawAmount);
        emit CrossWithdraw(msg.sender, withdrawToken, withdrawAmount);
    }

    /// @notice withdraw ethereum from cross margin account
    function crossWithdrawETH(uint256 withdrawAmount) external {
        IMarginTrading(marginTrading()).registerWithdrawal(
            msg.sender,
            WETH,
            withdrawAmount
        );
        Fund(fund()).withdrawETH(msg.sender, withdrawAmount);
    }

    /// @notice borrow into cross margin trading account
    function crossBorrow(address borrowToken, uint256 borrowAmount) external {
        Lending(lending()).registerBorrow(borrowToken, borrowAmount);
        IMarginTrading(marginTrading()).registerBorrow(
            msg.sender,
            borrowToken,
            borrowAmount
        );

        stakeClaim(msg.sender, borrowToken, borrowAmount);
        emit CrossBorrow(msg.sender, borrowToken, borrowAmount);
    }

    /// @notice convenience function to perform overcollateralized borrowing
    /// against a cross margin account.
    /// @dev caution: the account still has to have a positive balaance at the end
    /// of the withdraw. So an underwater account may not be able to withdraw
    function crossOvercollateralizedBorrow(
        address depositToken,
        uint256 depositAmount,
        address borrowToken,
        uint256 withdrawAmount
    ) external {
        Fund(fund()).depositFor(msg.sender, depositToken, depositAmount);

        Lending(lending()).registerBorrow(borrowToken, withdrawAmount);
        IMarginTrading(marginTrading()).registerOvercollateralizedBorrow(
            msg.sender,
            depositToken,
            depositAmount,
            borrowToken,
            withdrawAmount
        );

        Fund(fund()).withdraw(borrowToken, msg.sender, withdrawAmount);
        stakeClaim(msg.sender, borrowToken, withdrawAmount);
        emit CrossOvercollateralizedBorrow(
            msg.sender,
            depositToken,
            depositAmount,
            borrowToken,
            withdrawAmount
        );
    }

    /// @notice close an account that is no longer borrowing and return gains
    function crossCloseAccount() external {
        (address[] memory holdingTokens, uint256[] memory holdingAmounts) =
            IMarginTrading(marginTrading()).getHoldingAmounts(msg.sender);

        // requires all debts paid off
        IMarginTrading(marginTrading()).registerLiquidation(msg.sender);

        for (uint256 i; holdingTokens.length > i; i++) {
            Fund(fund()).withdraw(
                holdingTokens[i],
                msg.sender,
                holdingAmounts[i]
            );
        }
    }

    // **** SWAP ****
    /// @dev requires the initial amount to have already been sent to the first pair
    function _swap(
        uint256[] memory amounts,
        address[] memory pairs,
        address[] memory tokens,
        address _to
    ) internal virtual {
        address outToken = tokens[tokens.length - 1];
        uint256 startingBalance = IERC20(outToken).balanceOf(_to);
        for (uint256 i; i < pairs.length; i++) {
            (address input, address output) = (tokens[i], tokens[i + 1]);
            (address token0, ) = UniswapStyleLib.sortTokens(input, output);

            uint256 amountOut = amounts[i + 1];

            (uint256 amount0Out, uint256 amount1Out) =
                input == token0
                    ? (uint256(0), amountOut)
                    : (amountOut, uint256(0));

            address to = i < pairs.length - 1 ? pairs[i + 1] : _to;
            IUniswapV2Pair pair = IUniswapV2Pair(pairs[i]);
            pair.swap(amount0Out, amount1Out, to, new bytes(0));
        }

        uint256 endingBalance = IERC20(outToken).balanceOf(_to);
        require(
            endingBalance >= startingBalance + amounts[amounts.length - 1],
            ""Defective AMM route; balances don't match""
        );
    }

    /// @dev internal helper swapping exact token for token on AMM
    function _swapExactT4T(
        uint256[] memory amounts,
        uint256 amountOutMin,
        address[] calldata pairs,
        address[] calldata tokens
    ) internal {
        require(
            amounts[amounts.length - 1] >= amountOutMin,
            ""MarginRouter: INSUFFICIENT_OUTPUT_AMOUNT""
        );
        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);
        _swap(amounts, pairs, tokens, fund());
    }

    /// @notice make swaps on AMM using protocol funds, only for authorized contracts
    function authorizedSwapExactT4T(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata pairs,
        address[] calldata tokens
    ) external returns (uint256[] memory amounts) {
        require(
            isAuthorizedFundTrader(msg.sender),
            ""Calling contract is not authorized to trade with protocl funds""
        );
        amounts = UniswapStyleLib.getAmountsOut(amountIn, pairs, tokens);
        _swapExactT4T(amounts, amountOutMin, pairs, tokens);
    }

    // @dev internal helper swapping exact token for token on on AMM
    function _swapT4ExactT(
        uint256[] memory amounts,
        uint256 amountInMax,
        address[] calldata pairs,
        address[] calldata tokens
    ) internal {
        // TODO minimum trade?
        require(
            amounts[0] <= amountInMax,
            ""MarginRouter: EXCESSIVE_INPUT_AMOUNT""
        );
        Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);
        _swap(amounts, pairs, tokens, fund());
    }

    //// @notice swap protocol funds on AMM, only for authorized
    function authorizedSwapT4ExactT(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata pairs,
        address[] calldata tokens
    ) external returns (uint256[] memory amounts) {
        require(
            isAuthorizedFundTrader(msg.sender),
            ""Calling contract is not authorized to trade with protocl funds""
        );
        amounts = UniswapStyleLib.getAmountsIn(amountOut, pairs, tokens);
        _swapT4ExactT(amounts, amountInMax, pairs, tokens);
    }

    /// @notice entry point for swapping tokens held in cross margin account
    function crossSwapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata pairs,
        address[] calldata tokens,
        uint256 deadline
    ) external ensure(deadline) returns (uint256[] memory amounts) {
        // calc fees
        uint256 fees = takeFeesFromInput(amountIn);

        // swap
        amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);

        // checks that trader is within allowed lending bounds
        registerTrade(
            msg.sender,
            tokens[0],
            tokens[tokens.length - 1],
            amountIn,
            amounts[amounts.length - 1]
        );

        _swapExactT4T(amounts, amountOutMin, pairs, tokens);
    }

    /// @notice entry point for swapping tokens held in cross margin account
    function crossSwapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata pairs,
        address[] calldata tokens,
        uint256 deadline
    ) external ensure(deadline) returns (uint256[] memory amounts) {
        // swap
        amounts = UniswapStyleLib.getAmountsIn(
            amountOut + takeFeesFromOutput(amountOut),
            pairs,
            tokens
        );

        // checks that trader is within allowed lending bounds
        registerTrade(
            msg.sender,
            tokens[0],
            tokens[tokens.length - 1],
            amounts[0],
            amountOut
        );

        _swapT4ExactT(amounts, amountInMax, pairs, tokens);
    }

    /// @dev helper function does all the work of telling other contracts
    /// about a trade
    function registerTrade(
        address trader,
        address inToken,
        address outToken,
        uint256 inAmount,
        uint256 outAmount
    ) internal {
        (uint256 extinguishAmount, uint256 borrowAmount) =
            IMarginTrading(marginTrading()).registerTradeAndBorrow(
                trader,
                inToken,
                outToken,
                inAmount,
                outAmount
            );
        if (extinguishAmount > 0) {
            Lending(lending()).payOff(outToken, extinguishAmount);
            withdrawClaim(trader, outToken, extinguishAmount);
        }
        if (borrowAmount > 0) {
            Lending(lending()).registerBorrow(inToken, borrowAmount);
            stakeClaim(trader, inToken, borrowAmount);
        }

        emit CrossTrade(
            trader,
            inToken,
            inAmount,
            borrowAmount,
            outToken,
            outAmount,
            extinguishAmount
        );
    }

    function getAmountsOut(
        uint256 inAmount,
        address[] calldata pairs,
        address[] calldata tokens
    ) external view returns (uint256[] memory) {
        return UniswapStyleLib.getAmountsOut(inAmount, pairs, tokens);
    }

    function getAmountsIn(
        uint256 outAmount,
        address[] calldata pairs,
        address[] calldata tokens
    ) external view returns (uint256[] memory) {
        return UniswapStyleLib.getAmountsIn(outAmount, pairs, tokens);
    }

    function takeFeesFromOutput(uint256 amount)
        internal
        pure
        returns (uint256 fees)
    {
        fees = (mswapFeesPer10k * amount) / 10_000;
    }

    function takeFeesFromInput(uint256 amount)
        internal
        pure
        returns (uint256 fees)
    {
        fees = (mswapFeesPer10k * amount) / (10_000 + mswapFeesPer10k);
    }
}",2888,403,"H-01: Re-entrancy bug allows inflating balance One can call the MarginRouter.crossSwapExactTokensForTokens function first with a fake contract disguised as a token pair: crossSwapExactTokensForTokens(0.0001 WETH, 0, [ATTACKER_CONTRACT], [WETH, WBTC]). When the amounts are computed by the amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens); call, the attacker contract returns fake reserves that yield 1 WBTC for the tiny input.  H-02: Missing fromToken != toToken check Attacker calls MarginRouter.crossSwapExactTokensForTokens with a fake pair and the same token[0] == token[1]. crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH]) M-03: No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens The functions crossSwapTokensForExactTokens and crossSwapExactTokensForTokens of MarginRouter.sol do not check who is calling the function. They also do not check the contents of pairs and tokens nor do they check if the size of pairs and tokens is the same.",3
70_LiquidityBasedTWAP.sol,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""../external/libraries/UniswapV2OracleLibrary.sol"";

import ""../interfaces/external/chainlink/IAggregatorV3.sol"";
import ""../interfaces/external/uniswap/IUniswapV2Pair.sol"";

import ""../interfaces/lbt/ILiquidityBasedTWAP.sol"";
import ""../interfaces/dex-v2/pool/IVaderPoolV2.sol"";

contract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {
    /* ========== LIBRARIES ========== */

    using FixedPoint for FixedPoint.uq112x112;
    using FixedPoint for FixedPoint.uq144x112;

    /* ========== STATE VARIABLES ========== */

    address public immutable vader;
    IVaderPoolV2 public immutable vaderPool;

    IUniswapV2Pair[] public vaderPairs;
    IERC20[] public usdvPairs;

    uint256 public override maxUpdateWindow;
    uint256[2] public totalLiquidityWeight;
    uint256[2] public override previousPrices;
    mapping(address => ExchangePair) public twapData;
    mapping(address => IAggregatorV3) public oracles;

    /* ========== CONSTRUCTOR ========== */

    constructor(address _vader, IVaderPoolV2 _vaderPool) {
        require(
            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),
            ""LBTWAP::construction: Zero Address""
        );
        vader = _vader;
        vaderPool = _vaderPool;
    }

    /* ========== VIEWS ========== */

    function getStaleVaderPrice() external view returns (uint256) {
        uint256 totalPairs = vaderPairs.length;
        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);
        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[
            uint256(Paths.VADER)
        ];

        for (uint256 i; i < totalPairs; ++i)
            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]
                .pastLiquidityEvaluation;

        return
            _calculateVaderPrice(
                pastLiquidityWeights,
                pastTotalLiquidityWeight
            );
    }

    function getStaleUSDVPrice() external view returns (uint256) {
        uint256 totalPairs = usdvPairs.length;
        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);
        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[
            uint256(Paths.USDV)
        ];

        for (uint256 i; i < totalPairs; ++i)
            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]
                .pastLiquidityEvaluation;

        return
            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);
    }

    function getChainlinkPrice(address asset) public view returns (uint256) {
        IAggregatorV3 oracle = oracles[asset];

        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle
            .latestRoundData();

        require(
            answeredInRound >= roundID,
            ""LBTWAP::getChainlinkPrice: Stale Chainlink Price""
        );

        require(price > 0, ""LBTWAP::getChainlinkPrice: Chainlink Malfunction"");

        return uint256(price);
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function getVaderPrice() external returns (uint256) {
        (
            uint256[] memory pastLiquidityWeights,
            uint256 pastTotalLiquidityWeight
        ) = syncVaderPrice();

        return
            _calculateVaderPrice(
                pastLiquidityWeights,
                pastTotalLiquidityWeight
            );
    }

    function syncVaderPrice()
        public
        override
        returns (
            uint256[] memory pastLiquidityWeights,
            uint256 pastTotalLiquidityWeight
        )
    {
        uint256 _totalLiquidityWeight;
        uint256 totalPairs = vaderPairs.length;
        pastLiquidityWeights = new uint256[](totalPairs);
        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];

        for (uint256 i; i < totalPairs; ++i) {
            IUniswapV2Pair pair = vaderPairs[i];
            ExchangePair storage pairData = twapData[address(pair)];
            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;

            if (timeElapsed < pairData.updatePeriod) continue;

            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;
            uint256 currentLiquidityEvaluation = _updateVaderPrice(
                pair,
                pairData,
                timeElapsed
            );

            pastLiquidityWeights[i] = pastLiquidityEvaluation;

            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;

            _totalLiquidityWeight += currentLiquidityEvaluation;
        }

        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;
    }

    function _updateVaderPrice(
        IUniswapV2Pair pair,
        ExchangePair storage pairData,
        uint256 timeElapsed
    ) internal returns (uint256 currentLiquidityEvaluation) {
        bool isFirst = pair.token0() == vader;

        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();

        (uint256 reserveNative, uint256 reserveForeign) = isFirst
            ? (reserve0, reserve1)
            : (reserve1, reserve0);

        (
            uint256 price0Cumulative,
            uint256 price1Cumulative,
            uint256 currentMeasurement
        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));

        uint256 nativeTokenPriceCumulative = isFirst
            ? price0Cumulative
            : price1Cumulative;

        unchecked {
            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(
                uint224(
                    (nativeTokenPriceCumulative -
                        pairData.nativeTokenPriceCumulative) / timeElapsed
                )
            );
        }

        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;

        pairData.lastMeasurement = currentMeasurement;

        currentLiquidityEvaluation =
            (reserveNative * previousPrices[uint256(Paths.VADER)]) +
            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));
    }

    function _calculateVaderPrice(
        uint256[] memory liquidityWeights,
        uint256 totalVaderLiquidityWeight
    ) internal view returns (uint256) {
        uint256 totalUSD;
        uint256 totalVader;
        uint256 totalPairs = vaderPairs.length;

        for (uint256 i; i < totalPairs; ++i) {
            IUniswapV2Pair pair = vaderPairs[i];
            ExchangePair storage pairData = twapData[address(pair)];

            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);

            totalUSD +=
                (foreignPrice * liquidityWeights[i]) /
                totalVaderLiquidityWeight;

            totalVader +=
                (pairData
                    .nativeTokenPriceAverage
                    .mul(pairData.foreignUnit)
                    .decode144() * liquidityWeights[i]) /
                totalVaderLiquidityWeight;
        }

        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether
        return (totalUSD * 1 ether) / totalVader;
    }

    function setupVader(
        IUniswapV2Pair pair,
        IAggregatorV3 oracle,
        uint256 updatePeriod,
        uint256 vaderPrice
    ) external onlyOwner {
        require(
            previousPrices[uint256(Paths.VADER)] == 0,
            ""LBTWAP::setupVader: Already Initialized""
        );

        previousPrices[uint256(Paths.VADER)] = vaderPrice;

        _addVaderPair(pair, oracle, updatePeriod);
    }

    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level
    function addVaderPair(
        IUniswapV2Pair pair,
        IAggregatorV3 oracle,
        uint256 updatePeriod
    ) external onlyOwner {
        require(
            previousPrices[uint256(Paths.VADER)] != 0,
            ""LBTWAP::addVaderPair: Vader Uninitialized""
        );

        _addVaderPair(pair, oracle, updatePeriod);
    }

    function _addVaderPair(
        IUniswapV2Pair pair,
        IAggregatorV3 oracle,
        uint256 updatePeriod
    ) internal {
        require(
            updatePeriod != 0,
            ""LBTWAP::addVaderPair: Incorrect Update Period""
        );

        require(oracle.decimals() == 8, ""LBTWAP::addVaderPair: Non-USD Oracle"");

        ExchangePair storage pairData = twapData[address(pair)];

        bool isFirst = pair.token0() == vader;

        (address nativeAsset, address foreignAsset) = isFirst
            ? (pair.token0(), pair.token1())
            : (pair.token1(), pair.token0());

        oracles[foreignAsset] = oracle;

        require(nativeAsset == vader, ""LBTWAP::addVaderPair: Unsupported Pair"");

        pairData.foreignAsset = foreignAsset;
        pairData.foreignUnit = uint96(
            10**uint256(IERC20Metadata(foreignAsset).decimals())
        );

        pairData.updatePeriod = updatePeriod;
        pairData.lastMeasurement = block.timestamp;

        pairData.nativeTokenPriceCumulative = isFirst
            ? pair.price0CumulativeLast()
            : pair.price1CumulativeLast();

        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();

        (uint256 reserveNative, uint256 reserveForeign) = isFirst
            ? (reserve0, reserve1)
            : (reserve1, reserve0);

        uint256 pairLiquidityEvaluation = (reserveNative *
            previousPrices[uint256(Paths.VADER)]) +
            (reserveForeign * getChainlinkPrice(foreignAsset));

        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;

        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;

        vaderPairs.push(pair);

        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;
    }

    function getUSDVPrice() external returns (uint256) {
        (
            uint256[] memory pastLiquidityWeights,
            uint256 pastTotalLiquidityWeight
        ) = syncUSDVPrice();

        return
            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);
    }

    function syncUSDVPrice()
        public
        override
        returns (
            uint256[] memory pastLiquidityWeights,
            uint256 pastTotalLiquidityWeight
        )
    {
        uint256 _totalLiquidityWeight;
        uint256 totalPairs = usdvPairs.length;
        pastLiquidityWeights = new uint256[](totalPairs);
        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];

        for (uint256 i; i < totalPairs; ++i) {
            IERC20 foreignAsset = usdvPairs[i];
            ExchangePair storage pairData = twapData[address(foreignAsset)];
            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;

            if (timeElapsed < pairData.updatePeriod) continue;

            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;
            uint256 currentLiquidityEvaluation = _updateUSDVPrice(
                foreignAsset,
                pairData,
                timeElapsed
            );

            pastLiquidityWeights[i] = pastLiquidityEvaluation;

            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;

            _totalLiquidityWeight += currentLiquidityEvaluation;
        }

        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;
    }

    function _updateUSDVPrice(
        IERC20 foreignAsset,
        ExchangePair storage pairData,
        uint256 timeElapsed
    ) internal returns (uint256 currentLiquidityEvaluation) {
        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool
            .getReserves(foreignAsset);

        (
            uint256 nativeTokenPriceCumulative,
            ,
            uint256 currentMeasurement
        ) = vaderPool.cumulativePrices(foreignAsset);

        unchecked {
            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(
                uint224(
                    (nativeTokenPriceCumulative -
                        pairData.nativeTokenPriceCumulative) / timeElapsed
                )
            );
        }

        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;

        pairData.lastMeasurement = currentMeasurement;

        currentLiquidityEvaluation =
            (reserveNative * previousPrices[uint256(Paths.USDV)]) +
            (reserveForeign * getChainlinkPrice(address(foreignAsset)));
    }

    function _calculateUSDVPrice(
        uint256[] memory liquidityWeights,
        uint256 totalUSDVLiquidityWeight
    ) internal view returns (uint256) {
        uint256 totalUSD;
        uint256 totalUSDV;
        uint256 totalPairs = usdvPairs.length;

        for (uint256 i; i < totalPairs; ++i) {
            IERC20 foreignAsset = usdvPairs[i];
            ExchangePair storage pairData = twapData[address(foreignAsset)];

            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));

            totalUSD +=
                (foreignPrice * liquidityWeights[i]) /
                totalUSDVLiquidityWeight;

            totalUSDV +=
                (pairData
                    .nativeTokenPriceAverage
                    .mul(pairData.foreignUnit)
                    .decode144() * liquidityWeights[i]) /
                totalUSDVLiquidityWeight;
        }

        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether
        return (totalUSD * 1 ether) / totalUSDV;
    }

    function setupUSDV(
        IERC20 foreignAsset,
        IAggregatorV3 oracle,
        uint256 updatePeriod,
        uint256 usdvPrice
    ) external onlyOwner {
        require(
            previousPrices[uint256(Paths.USDV)] == 0,
            ""LBTWAP::setupUSDV: Already Initialized""
        );

        previousPrices[uint256(Paths.USDV)] = usdvPrice;

        _addUSDVPair(foreignAsset, oracle, updatePeriod);
    }

    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level
    function addUSDVPair(
        IERC20 foreignAsset,
        IAggregatorV3 oracle,
        uint256 updatePeriod
    ) external onlyOwner {
        require(
            previousPrices[uint256(Paths.USDV)] != 0,
            ""LBTWAP::addUSDVPair: USDV Uninitialized""
        );

        _addUSDVPair(foreignAsset, oracle, updatePeriod);
    }

    function _addUSDVPair(
        IERC20 foreignAsset,
        IAggregatorV3 oracle,
        uint256 updatePeriod
    ) internal {
        require(
            updatePeriod != 0,
            ""LBTWAP::addUSDVPair: Incorrect Update Period""
        );

        require(oracle.decimals() == 8, ""LBTWAP::addUSDVPair: Non-USD Oracle"");

        oracles[address(foreignAsset)] = oracle;

        ExchangePair storage pairData = twapData[address(foreignAsset)];

        // NOTE: Redundant
        // pairData.foreignAsset = foreignAsset;

        pairData.foreignUnit = uint96(
            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())
        );

        pairData.updatePeriod = updatePeriod;
        pairData.lastMeasurement = block.timestamp;

        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(
            foreignAsset
        );

        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;

        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool
            .getReserves(foreignAsset);

        uint256 pairLiquidityEvaluation = (reserveNative *
            previousPrices[uint256(Paths.USDV)]) +
            (reserveForeign * getChainlinkPrice(address(foreignAsset)));

        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;

        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;

        usdvPairs.push(foreignAsset);

        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;
    }
}",3695,493,"H-03 Oracle doesn't calculate USDV/VADER price correctly Invalid values returned from oracle for USDV and VADER prices in situations where the oracle uses more than one foreign asset. H-04 Vader TWAP averages wrong The vader price in LiquidityBasedTWAP.getVaderPrice is computed using the pastLiquidityWeights and pastTotalLiquidityWeight return values of the syncVaderPrice. H-05 Oracle returns an improperly scaled USDV/VADER price The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value. H-09: USDV.sol Mint and Burn Amounts Are Incorrect The USDV.mint function queries the price of Vader from the LiquidityBasedTwap contract. The calculation to determine uAmount in mint is actually performed incorrectly. uAmount = (vPrice * vAmount) / 1e18; will return the USD amount for the provided Vader as vPrice is denominated in USD/Vader. This uAmount is subsequently used when minting tokens for the user (locked for a period of time) and fee to the contract owner. H-10: previousPrices Is Never Updated Upon Syncing Token Price The LiquidityBasedTWAP contract attempts to accurately track the price of VADER and USDV while still being resistant to flash loan manipulation and short-term volatility. The previousPrices array is meant to track the last queried price for the two available paths, namely VADER and USDV. M-02: Adding pair of the same foreignAsset would replace oracle of earlier entry Oracles are mapped to the foreignAsset but not to the specific pair. Pairs with the same foreignAsset (e.g. UniswapV2 and Sushi) will be forced to use the same oracle. Generally this should be the expected behavior but there are also possibility that while adding a new pair changed the oracle of an older pair unexpectedly. M-06 Oracle can be manipulted to consider only a single pair for pricing Loss of resilience of oracle to a faulty pricing for a single pair. In the oracle we calculate the TVL of each pool by pulling the reserves and multiplying both assets by the result of a supposedly manipulation resistant oracle (the oracle queries its previous value for USDV and pulls the foreign asset from chainlink). ",7
71_PoolTemplate.sol,"pragma solidity 0.8.7;

/**
 * @author InsureDAO
 * @title InsureDAO pool template contract
 * SPDX-License-Identifier: GPL-3.0
 */
import ""@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./InsureDAOERC20.sol"";
import ""./interfaces/IPoolTemplate.sol"";
import ""./interfaces/IUniversalMarket.sol"";

import ""./interfaces/IParameters.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IRegistry.sol"";
import ""./interfaces/IIndexTemplate.sol"";

contract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {
    /**
     * EVENTS
     */
    event Deposit(address indexed depositor, uint256 amount, uint256 mint);
    event WithdrawRequested(
        address indexed withdrawer,
        uint256 amount,
        uint256 time
    );
    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);
    event Unlocked(uint256 indexed id, uint256 amount);
    event Insured(
        uint256 indexed id,
        uint256 amount,
        bytes32 target,
        uint256 startTime,
        uint256 endTime,
        address insured,
        uint256 premium
    );
    event Redeemed(
        uint256 indexed id,
        address insured,
        bytes32 target,
        uint256 amount,
        uint256 payout
    );
    event CoverApplied(
        uint256 pending,
        uint256 payoutNumerator,
        uint256 payoutDenominator,
        uint256 incidentTimestamp,
        bytes32 merkleRoot,
        string rawdata,
        string memo
    );
    event TransferInsurance(uint256 indexed id, address from, address to);
    event CreditIncrease(address indexed depositor, uint256 credit);
    event CreditDecrease(address indexed withdrawer, uint256 credit);
    event MarketStatusChanged(MarketStatus statusValue);
    event Paused(bool paused);
    event MetadataChanged(string metadata);

    /**
     * Storage
     */
    /// @notice Market setting
    bool public initialized;
    bool public override paused;
    string public metadata;

    /// @notice External contract call addresses
    IParameters public parameters;
    IRegistry public registry;
    IVault public vault;

    /// @notice Market variables
    uint256 public attributionDebt; 
    //pool's attribution for indices
    uint256 public override lockedAmount; 
    //Liquidity locked when utilized
    uint256 public override totalCredit; 
    //Liquidity from index
    uint256 public rewardPerCredit; 
    //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.
    uint256 public pendingEnd; 
    //pending time when paying out

    /// @notice Market variables for margin account
    struct IndexInfo {
        uint256 credit; 
        //How many credit (equal to liquidity) the index has allocated
        uint256 rewardDebt; 
        // Reward debt. *See explanation below.
        bool exist; 
        //true if the index has allocated credit
    }

    mapping(address => IndexInfo) public indicies;
    address[] public indexList;

    //
    // * We do some fancy math for premium calculation of indicies.
    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:
    //
    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt
    //
    // When the pool receives premium, it updates rewardPerCredit
    //
    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:
    //   1. The index receives the pending reward sent to the index vault.
    //   2. The index's rewardDebt get updated.
    //
    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)
    //

    ///@notice Market status transition management
    enum MarketStatus {
        Trading,
        Payingout
    }
    MarketStatus public marketStatus;

    ///@notice user's withdrawal status management
    struct Withdrawal {
        uint256 timestamp;
        uint256 amount;
    }
    mapping(address => Withdrawal) public withdrawalReq;

    ///@notice insurance status management
    struct Insurance {
        uint256 id; 
        //each insuance has their own id
        uint256 startTime; 
        //timestamp of starttime
        uint256 endTime; 
        //timestamp of endtime
        uint256 amount; 
        //insured amount
        bytes32 target; 
        //target id in bytes32
        address insured; 
        //the address holds the right to get insured
        bool status; 
        //true if insurance is not expired or redeemed
    }
    mapping(uint256 => Insurance) public insurances;
    uint256 public allInsuranceCount;

    ///@notice incident status management
    struct Incident {
        uint256 payoutNumerator;
        uint256 payoutDenominator;
        uint256 incidentTimestamp;
        bytes32 merkleRoot;
    }
    Incident public incident;

    uint256 public constant MAGIC_SCALE_1E6 = 1e6; 
    //internal multiplication scale 1e6 to reduce decimal truncation

    modifier onlyOwner() {
        require(
            msg.sender == parameters.getOwner(),
            ""Restricted: caller is not allowed to operate""
        );
        _;
    }

    constructor() {
        initialized = true;
    }

    /**
     * Initialize interaction
     */

    /**
     * @notice Initialize market
     * This function registers market conditions.
     * references[0] = target governance token address
     * references[1] = underlying token address
     * references[2] = registry
     * references[3] = parameter
     * references[4] = initialDepositor
     * conditions[0] = minimim deposit amount defined by the factory
     * conditions[1] = initial deposit amount defined by the creator
     * @param _metaData arbitrary string to store market information
     * @param _conditions array of conditions
     * @param _references array of references
     */
    function initialize(
        string calldata _metaData,
        uint256[] calldata _conditions,
        address[] calldata _references
    ) external override {
        require(
            initialized == false &&
                bytes(_metaData).length > 0 &&
                _references[0] != address(0) &&
                _references[1] != address(0) &&
                _references[2] != address(0) &&
                _references[3] != address(0) &&
                _references[4] != address(0) &&
                _conditions[0] <= _conditions[1],
            ""ERROR: INITIALIZATION_BAD_CONDITIONS""
        );
        initialized = true;

        string memory _name = string(
            abi.encodePacked(
                ""InsureDAO-"",
                IERC20Metadata(_references[1]).name(),
                ""-PoolInsurance""
            )
        );
        string memory _symbol = string(
            abi.encodePacked(""i-"", IERC20Metadata(_references[1]).symbol())
        );
        uint8 _decimals = IERC20Metadata(_references[0]).decimals();

        initializeToken(_name, _symbol, _decimals);

        registry = IRegistry(_references[2]);
        parameters = IParameters(_references[3]);
        vault = IVault(parameters.getVault(_references[1]));

        metadata = _metaData;

        marketStatus = MarketStatus.Trading;

        if (_conditions[1] > 0) {
            _depositFrom(_conditions[1], _references[4]);
        }
    }

    /**
     * Pool interactions
     */

    /**
     * @notice A liquidity provider supplies tokens to the pool and receives iTokens
     * @param _amount amount of tokens to deposit
     * @return _mintAmount the amount of iTokens minted from the transaction
     */
    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {
        require(
            marketStatus == MarketStatus.Trading && paused == false,
            ""ERROR: DEPOSIT_DISABLED""
        );
        require(_amount > 0, ""ERROR: DEPOSIT_ZERO"");

        _mintAmount = worth(_amount);

        vault.addValue(_amount, msg.sender, address(this));

        emit Deposit(msg.sender, _amount, _mintAmount);

        //mint iToken
        _mint(msg.sender, _mintAmount);
    }

    /**
     * @notice Internal deposit function that allows third party to deposit
     * @param _amount amount of tokens to deposit
     * @param _from deposit beneficiary's address
     * @return _mintAmount the amount of iTokens minted from the transaction
     */
    function _depositFrom(uint256 _amount, address _from)
        internal
        returns (uint256 _mintAmount)
    {
        require(
            marketStatus == MarketStatus.Trading && paused == false,
            ""ERROR: DEPOSIT_DISABLED""
        );
        require(_amount > 0, ""ERROR: DEPOSIT_ZERO"");

        _mintAmount = worth(_amount);

        vault.addValue(_amount, _from, address(this));

        emit Deposit(_from, _amount, _mintAmount);

        //mint iToken
        _mint(_from, _mintAmount);
    }

    /**
     * @notice A liquidity provider request withdrawal of collateral
     * @param _amount amount of iTokens to burn
     */
    function requestWithdraw(uint256 _amount) external {
        uint256 _balance = balanceOf(msg.sender);
        require(_balance >= _amount, ""ERROR: REQUEST_EXCEED_BALANCE"");
        require(_amount > 0, ""ERROR: REQUEST_ZERO"");
        withdrawalReq[msg.sender].timestamp = block.timestamp;
        withdrawalReq[msg.sender].amount = _amount;
        emit WithdrawRequested(msg.sender, _amount, block.timestamp);
    }

    /**
     * @notice A liquidity provider burns iTokens and receives collateral from the pool
     * @param _amount amount of iTokens to burn
     * @return _retVal the amount underlying tokens returned
     */
    function withdraw(uint256 _amount) external returns (uint256 _retVal) {
        uint256 _supply = totalSupply();
        require(_supply != 0, ""ERROR: NO_AVAILABLE_LIQUIDITY"");

        uint256 _liquidity = originalLiquidity();
        _retVal = (_amount * _liquidity) / _supply;

        require(
            marketStatus == MarketStatus.Trading,
            ""ERROR: WITHDRAWAL_PENDING""
        );
        require(
            withdrawalReq[msg.sender].timestamp +
                parameters.getLockup(msg.sender) <
                block.timestamp,
            ""ERROR: WITHDRAWAL_QUEUE""
        );
        require(
            withdrawalReq[msg.sender].timestamp +
                parameters.getLockup(msg.sender) +
                parameters.getWithdrawable(msg.sender) >
                block.timestamp,
            ""ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST""
        );
        require(
            withdrawalReq[msg.sender].amount >= _amount,
            ""ERROR: WITHDRAWAL_EXCEEDED_REQUEST""
        );
        require(_amount > 0, ""ERROR: WITHDRAWAL_ZERO"");
        require(
            _retVal <= availableBalance(),
            ""ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY""
        );
        //reduce requested amount
        withdrawalReq[msg.sender].amount -= _amount;

        //Burn iToken
        _burn(msg.sender, _amount);

        //Withdraw liquidity
        vault.withdrawValue(_retVal, msg.sender);

        emit Withdraw(msg.sender, _amount, _retVal);
    }

    /**
     * @notice Unlocks an array of insurances
     * @param _ids array of ids to unlock
     */
    function unlockBatch(uint256[] calldata _ids) external {
        for (uint256 i = 0; i < _ids.length; i++) {
            unlock(_ids[i]);
        }
    }

    /**
     * @notice Unlock funds locked in the expired insurance
     * @param _id id of the insurance policy to unlock liquidity
     */
    function unlock(uint256 _id) public {
        require(
            insurances[_id].status == true &&
                marketStatus == MarketStatus.Trading &&
                insurances[_id].endTime + parameters.getGrace(msg.sender) <
                block.timestamp,
            ""ERROR: UNLOCK_BAD_COINDITIONS""
        );
        insurances[_id].status == false;

        lockedAmount = lockedAmount - insurances[_id].amount;

        emit Unlocked(_id, insurances[_id].amount);
    }

    /**
     * Index interactions
     */

    /**
     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.
     * @param _credit credit (liquidity amount) to be added to this pool
     * @return _pending pending preium for the caller index
     */

    function allocateCredit(uint256 _credit)
        external
        override
        returns (uint256 _pending)
    {
        require(
            IRegistry(registry).isListed(msg.sender),
            ""ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS""
        );
        IndexInfo storage _index = indicies[msg.sender];
        uint256 _rewardPerCredit = rewardPerCredit;
        if (_index.exist == false) {
            _index.exist = true;
            indexList.push(msg.sender);
        } else if (_index.credit > 0) {
            _pending = _sub(
                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,
                _index.rewardDebt
            );
            if (_pending > 0) {
                vault.transferAttribution(_pending, msg.sender);
                attributionDebt -= _pending;
            }
        }
        if (_credit > 0) {
            totalCredit += _credit;
            _index.credit += _credit;
            emit CreditIncrease(msg.sender, _credit);
        }
        _index.rewardDebt =
            (_index.credit * _rewardPerCredit) /
            MAGIC_SCALE_1E6;
    }

    /**
     * @notice An index withdraw credit and earn accrued premium
     * @param _credit credit (liquidity amount) to be withdrawn from this pool
     * @return _pending pending preium for the caller index
     */
    function withdrawCredit(uint256 _credit)
        external
        override
        returns (uint256 _pending)
    {
        IndexInfo storage _index = indicies[msg.sender];
        uint256 _rewardPerCredit = rewardPerCredit;
        require(
            IRegistry(registry).isListed(msg.sender) &&
                _index.credit >= _credit &&
                _credit <= availableBalance(),
            ""ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS""
        );

        //calculate acrrued premium
        _pending = _sub(
            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,
            _index.rewardDebt
        );

        //Withdraw liquidity
        if (_credit > 0) {
            totalCredit -= _credit;
            _index.credit -= _credit;
            emit CreditDecrease(msg.sender, _credit);
        }

        //withdraw acrrued premium
        if (_pending > 0) {
            vault.transferAttribution(_pending, msg.sender);
            attributionDebt -= _pending;
            _index.rewardDebt =
                (_index.credit * _rewardPerCredit) /
                MAGIC_SCALE_1E6;
        }
    }

    /**
     * Insurance interactions
     */

    /**
     * @notice Get insured for the specified amount for specified span
     * @param _amount target amount to get covered
     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher
     * @param _span length to get covered(e.g. 7 days)
     * @param _target target id
     * @return id of the insurance policy
     */
    function insure(
        uint256 _amount,
        uint256 _maxCost,
        uint256 _span,
        bytes32 _target
    ) external returns (uint256) {
        //Distribute premium and fee
        uint256 _endTime = _span + block.timestamp;
        uint256 _premium = getPremium(_amount, _span);
        uint256 _fee = parameters.getFeeRate(msg.sender);

        require(
            _amount <= availableBalance(),
            ""ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE""
        );
        require(_premium <= _maxCost, ""ERROR: INSURE_EXCEEDED_MAX_COST"");
        require(_span <= 365 days, ""ERROR: INSURE_EXCEEDED_MAX_SPAN"");
        require(
            parameters.getMinDate(msg.sender) <= _span,
            ""ERROR: INSURE_SPAN_BELOW_MIN""
        );

        require(
            marketStatus == MarketStatus.Trading,
            ""ERROR: INSURE_MARKET_PENDING""
        );
        require(paused == false, ""ERROR: INSURE_MARKET_PAUSED"");

        //current liquidity
        uint256 _liquidity = totalLiquidity();
        uint256 _totalCredit = totalCredit;

        //accrue premium/fee
        uint256[2] memory _newAttribution = vault.addValueBatch(
            _premium,
            msg.sender,
            [address(this), parameters.getOwner()],
            [MAGIC_SCALE_1E6 - _fee, _fee]
        );

        //Lock covered amount
        uint256 _id = allInsuranceCount;
        lockedAmount += _amount;
        Insurance memory _insurance = Insurance(
            _id,
            block.timestamp,
            _endTime,
            _amount,
            _target,
            msg.sender,
            true
        );
        insurances[_id] = _insurance;
        allInsuranceCount += 1;

        //Calculate liquidity for index
        if (_totalCredit > 0) {
            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /
                _liquidity;
            attributionDebt += _attributionForIndex;
            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /
                _totalCredit);
        }

        emit Insured(
            _id,
            _amount,
            _target,
            block.timestamp,
            _endTime,
            msg.sender,
            _premium
        );

        return _id;
    }

    /**
     * @notice Redeem an insurance policy
     * @param _id the id of the insurance policy
     * @param _merkleProof merkle proof (similar to ""verify"" function of MerkleProof.sol of OpenZeppelin
     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol
     */
    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {
        Insurance storage _insurance = insurances[_id];
        require(_insurance.status == true, ""ERROR: INSURANCE_NOT_ACTIVE"");

        uint256 _payoutNumerator = incident.payoutNumerator;
        uint256 _payoutDenominator = incident.payoutDenominator;
        uint256 _incidentTimestamp = incident.incidentTimestamp;
        bytes32 _targets = incident.merkleRoot;

        require(
            marketStatus == MarketStatus.Payingout,
            ""ERROR: NO_APPLICABLE_INCIDENT""
        );
        require(_insurance.insured == msg.sender, ""ERROR: NOT_YOUR_INSURANCE"");
        require(
            marketStatus == MarketStatus.Payingout &&
                _insurance.startTime <= _incidentTimestamp &&
                _insurance.endTime >= _incidentTimestamp,
            ""ERROR: INSURANCE_NOT_APPLICABLE""
        );
        require(
            MerkleProof.verify(
                _merkleProof,
                _targets,
                keccak256(
                    abi.encodePacked(_insurance.target, _insurance.insured)
                )
            ) ||
                MerkleProof.verify(
                    _merkleProof,
                    _targets,
                    keccak256(abi.encodePacked(_insurance.target, address(0)))
                ),
            ""ERROR: INSURANCE_EXEMPTED""
        );
        _insurance.status = false;
        lockedAmount -= _insurance.amount;

        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /
            _payoutDenominator;

        vault.borrowValue(_payoutAmount, msg.sender);

        emit Redeemed(
            _id,
            msg.sender,
            _insurance.target,
            _insurance.amount,
            _payoutAmount
        );
    }

    /**
     * @notice Transfers an active insurance
     * @param _id id of the insurance policy
     * @param _to receipient of of the policy
     */
    function transferInsurance(uint256 _id, address _to) external {
        Insurance storage insurance = insurances[_id];

        require(
            _to != address(0) &&
                insurance.insured == msg.sender &&
                insurance.endTime >= block.timestamp &&
                insurance.status == true,
            ""ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS""
        );

        insurance.insured = _to;
        emit TransferInsurance(_id, msg.sender, _to);
    }

    /**
     * @notice Get how much premium for the specified amount and span
     * @param _amount amount to get insured
     * @param _span span to get covered
     */
    function getPremium(uint256 _amount, uint256 _span)
        public
        view
        returns (uint256 premium)
    {
        return
            parameters.getPremium(
                _amount,
                _span,
                totalLiquidity(),
                lockedAmount,
                address(this)
            );
    }

    /**
     * Reporting interactions
     */

    /**
     * @notice Decision to make a payout
     * @param _pending length of time to allow policyholders to redeem their policy
     * @param _payoutNumerator Numerator of the payout *See below
     * @param _payoutDenominator Denominator of the payout *See below
     * @param _incidentTimestamp Unixtimestamp of the incident
     * @param _merkleRoot Merkle root of the payout id list
     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emiｔted within event)
     * @param _memo additional memo for the payout report (to be emmited within event)
     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout
     */
    function applyCover(
        uint256 _pending,
        uint256 _payoutNumerator,
        uint256 _payoutDenominator,
        uint256 _incidentTimestamp,
        bytes32 _merkleRoot,
        string calldata _rawdata,
        string calldata _memo
    ) external override onlyOwner {
        require(paused == false, ""ERROR: UNABLE_TO_APPLY"");
        incident.payoutNumerator = _payoutNumerator;
        incident.payoutDenominator = _payoutDenominator;
        incident.incidentTimestamp = _incidentTimestamp;
        incident.merkleRoot = _merkleRoot;
        marketStatus = MarketStatus.Payingout;
        pendingEnd = block.timestamp + _pending;
        for (uint256 i = 0; i < indexList.length; i++) {
            if (indicies[indexList[i]].credit > 0) {
                IIndexTemplate(indexList[i]).lock();
            }
        }
        emit CoverApplied(
            _pending,
            _payoutNumerator,
            _payoutDenominator,
            _incidentTimestamp,
            _merkleRoot,
            _rawdata,
            _memo
        );
        emit MarketStatusChanged(marketStatus);
    }

    /**
     * @notice Anyone can resume the market after a pending period ends
     */
    function resume() external {
        require(
            marketStatus == MarketStatus.Payingout &&
                pendingEnd < block.timestamp,
            ""ERROR: UNABLE_TO_RESUME""
        );

        uint256 _debt = vault.debts(address(this));
        uint256 _totalCredit = totalCredit;
        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /
            totalLiquidity();
        uint256 _actualDeduction;
        for (uint256 i = 0; i < indexList.length; i++) {
            address _index = indexList[i];
            uint256 _credit = indicies[_index].credit;
            if (_credit > 0) {
                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /
                    _totalCredit;
                uint256 _redeemAmount = _divCeil(
                    _deductionFromIndex,
                    _shareOfIndex
                );
                _actualDeduction += IIndexTemplate(_index).compensate(
                    _redeemAmount
                );
            }
        }

        uint256 _deductionFromPool = _debt -
            _deductionFromIndex /
            MAGIC_SCALE_1E6;
        uint256 _shortage = _deductionFromIndex /
            MAGIC_SCALE_1E6 -
            _actualDeduction;

        if (_deductionFromPool > 0) {
            vault.offsetDebt(_deductionFromPool, address(this));
        }

        vault.transferDebt(_shortage);

        marketStatus = MarketStatus.Trading;
        emit MarketStatusChanged(MarketStatus.Trading);
    }

    /**
     * Utilities
     */

    /**
     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)
     * @return The value against the underlying tokens balance.
     */
    function rate() external view returns (uint256) {
        if (totalSupply() > 0) {
            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();
        } else {
            return 0;
        }
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @param _owner the target address to look up value
     * @return The balance of underlying tokens for the specified address
     */
    function valueOfUnderlying(address _owner)
        public
        view
        override
        returns (uint256)
    {
        uint256 _balance = balanceOf(_owner);
        if (_balance == 0) {
            return 0;
        } else {
            return (_balance * originalLiquidity()) / totalSupply();
        }
    }

    /**
     * @notice Get the accrued value for an index
     * @param _index the address of index
     * @return The pending premium for the specified index
     */
    function pendingPremium(address _index)
        external
        view
        override
        returns (uint256)
    {
        uint256 _credit = indicies[_index].credit;
        if (_credit == 0) {
            return 0;
        } else {
            return
                _sub(
                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,
                    indicies[_index].rewardDebt
                );
        }
    }

    /**
     * @notice Get token number for the specified underlying value
     * @param _value amount of iToken
     * @return _amount The balance of underlying tokens for the specified amount
     */
    function worth(uint256 _value) public view returns (uint256 _amount) {
        uint256 _supply = totalSupply();
        uint256 _originalLiquidity = originalLiquidity();
        if (_supply > 0 && _originalLiquidity > 0) {
            _amount = (_value * _supply) / _originalLiquidity;
        } else if (_supply > 0 && _originalLiquidity == 0) {
            _amount = _value * _supply;
        } else {
            _amount = _value;
        }
    }

    /**
     * @notice Get allocated credit
     * @param _index address of an index
     * @return The balance of credit allocated by the specified index
     */
    function allocatedCredit(address _index)
        public
        view
        override
        returns (uint256)
    {
        return indicies[_index].credit;
    }

    /**
     * @notice Returns the amount of underlying tokens available for withdrawals
     * @return _balance available liquidity of this pool
     */
    function availableBalance()
        public
        view
        override
        returns (uint256 _balance)
    {
        if (totalLiquidity() > 0) {
            return totalLiquidity() - lockedAmount;
        } else {
            return 0;
        }
    }

    /**
     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)
     * @return _rate utilization rate
     */
    function utilizationRate() public view override returns (uint256 _rate) {
        if (lockedAmount > 0) {
            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();
        } else {
            return 0;
        }
    }

    /**
     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)
     * @return _balance total liquidity of this pool
     */
    function totalLiquidity() public view override returns (uint256 _balance) {
        return originalLiquidity() + totalCredit;
    }

    /**
     * @notice Pool's Liquidity
     * @return _balance total liquidity of this pool
     */
    function originalLiquidity() public view returns (uint256 _balance) {
        return
            vault.underlyingValue(address(this)) -
            vault.attributionValue(attributionDebt);
    }

    /**
     * Admin functions
     */

    /**
     * @notice Used for changing settlementFeeRecipient
     * @param _state true to set paused and vice versa
     */
    function setPaused(bool _state) external override onlyOwner {
        if (paused != _state) {
            paused = _state;
            emit Paused(_state);
        }
    }

    /**
     * @notice Change metadata string
     * @param _metadata new metadata string
     */
    function changeMetadata(string calldata _metadata)
        external
        override
        onlyOwner
    {
        metadata = _metadata;
        emit MetadataChanged(_metadata);
    }

    /**
     * Internal functions
     */

    /**
     * @notice Internal function to offset withdraw request and latest balance
     * @param from the account who send
     * @param to a
     * @param amount the amount of tokens to offset
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        if (from != address(0)) {
            uint256 _after = balanceOf(from) - amount;
            if (_after < withdrawalReq[from].amount) {
                withdrawalReq[from].amount = _after;
            }
        }
    }

    /**
     * @notice Internal function for safe division
     */
    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;
        if (a % b != 0) c = c + 1;
        return c;
    }

    /**
     * @notice Internal function for overflow free subtraction
     */
    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a < b) {
            return 0;
        } else {
            return a - b;
        }
    }
}",6718,962,"H-02: Typo in PoolTemplate unlock function results in user being able to unlock multiple times The function unlock() in PoolTemplate has a typo where it compares insurances[_id].status to false rather than setting it to false. If the conditions are met to unlock the funds for an id, the user should be able to call the unlock() function once for that id as insurances[_id].amount is subtracted from lockedAmount. However, since insurances[_id].status does not get set to false, a user can call unlock() multiple times for the same id, resulting in lockedAmount being way smaller than it should be since insurances[_id].amount is subtracted multiple times. H-04: Initial pool deposit can be stolen Note that the PoolTemplate.initialize function, called when creating a market with Factory.createMarket, calls a vault function to transfer an initial deposit amount (conditions[1]) from the initial depositor (_references[4]): H-06: the first depositor to a pool can drain all users L807 if there is no liquidity in the pool, the first deposit determines the total liquidity, if the amount is too small the minted liquidity for the next liquidity providers will round down to zero. H-11: PoolTemplate.sol#resume() Wrong implementation of resume() will compensate overmuch redeem amount from index pools Wrong arithmetic. L700-L717 M-02: Owner can call applyCover multiple times in PoolTemplate.sol",5
20_Pool.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iSYNTH.sol""; 
import ""./interfaces/iSYNTHFACTORY.sol""; 
import ""./interfaces/iBEP677.sol""; 

contract Pool is iBEP20 {  
    address public BASE;
    address public TOKEN;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    uint256 public baseAmount; 
    uint256 public tokenAmount; 

    uint private lastMonth; 
    uint public genesis; 

    uint256 public map30DPoolRevenue; 
    uint256 public mapPast30DPoolRevenue; 
    uint256 [] public revenueArray; 

    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);
    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);
    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);
    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);
    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    constructor (address _base, address _token) {
        BASE = _base;
        TOKEN = _token;
        string memory poolName = ""-SpartanProtocolPool"";
        string memory poolSymbol = ""-SPP"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));
        decimals = 18;
        genesis = block.timestamp;
        DEPLOYER = msg.sender;
        lastMonth = 0;
    }

    //========================================iBEP20=========================================//

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { 
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }

    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        // Max approval (saves an SSTORE)
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    //iBEP677 approveAndCall
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _approve(msg.sender, recipient, type(uint256).max); 
      // Give recipient max approval
      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); 
      // Amount is passed thru to recipient
      return true;
    }

    //iBEP677 transferAndCall
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _transfer(msg.sender, recipient, amount);
      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); 
      // Amount is passed thru to recipient 
      return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //====================================POOL FUNCTIONS =================================//

    // User adds liquidity to the pool
    function add() external returns(uint liquidityUnits){
        liquidityUnits = addForMember(msg.sender);
        return liquidityUnits;
    }

    // Contract adds liquidity for user 
    function addForMember(address member) public returns(uint liquidityUnits){
        uint256 _actualInputBase = _getAddedBaseAmount(); 
        // Get the received SPARTA amount
        uint256 _actualInputToken = _getAddedTokenAmount(); 
        // Get the received TOKEN amount
        if(baseAmount == 0 || tokenAmount == 0){
        require(_actualInputBase != 0 && _actualInputToken != 0, ""!Balanced"");
        }
        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); 
        // Calculate LP tokens to mint
        _incrementPoolBalances(_actualInputBase, _actualInputToken); 
        // Update recorded BASE and TOKEN amounts
        _mint(member, liquidityUnits); 
        // Mint the LP tokens directly to the user
        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);
        return liquidityUnits;
    }
    
    // User removes liquidity from the pool 
    function remove() external returns (uint outputBase, uint outputToken) {
        return removeForMember(msg.sender);
    } 

    // Contract removes liquidity for the user
    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {
        uint256 _actualInputUnits = balanceOf(address(this)); 
        // Get the received LP units amount
        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); 
        // Get the SPARTA value of LP units
        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); 
        // Get the TOKEN value of LP units
        _decrementPoolBalances(outputBase, outputToken); 
        // Update recorded BASE and TOKEN amounts
        _burn(address(this), _actualInputUnits); 
        // Burn the LP tokens
        iBEP20(BASE).transfer(member, outputBase); 
        // Transfer the SPARTA to user
        iBEP20(TOKEN).transfer(member, outputToken); 
        // Transfer the TOKENs to user
        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);
        return (outputBase, outputToken);
    }

    // Caller swaps tokens
    function swap(address token) external returns (uint outputAmount, uint fee){
        (outputAmount, fee) = swapTo(token, msg.sender);
        return (outputAmount, fee);
    }

    // Contract swaps tokens for the member
    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {
        require((token == BASE || token == TOKEN), ""!BASE||TOKEN""); 
        // Must be SPARTA or the pool's relevant TOKEN
        address _fromToken; uint _amount;
        if(token == BASE){
            _fromToken = TOKEN; 
            // If SPARTA is selected; swap from TOKEN
            _amount = _getAddedTokenAmount(); 
            // Get the received TOKEN amount
            (outputAmount, fee) = _swapTokenToBase(_amount); 
            // Calculate the SPARTA output from the swap
        } else {
            _fromToken = BASE; 
            // If TOKEN is selected; swap from SPARTA
            _amount = _getAddedBaseAmount(); 
            // Get the received SPARTA amount
            (outputAmount, fee) = _swapBaseToToken(_amount); 
            // Calculate the TOKEN output from the swap
        }
        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);
        iBEP20(token).transfer(member, outputAmount); 
        // Transfer the swap output to the selected user
        return (outputAmount, fee);
    }

    // Swap SPARTA for Synths
    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, ""!synth""); 
        // Must be a valid Synth
        uint256 _actualInputBase = _getAddedBaseAmount(); 
        // Get received SPARTA amount
        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); 
        // Calculate value of swapping SPARTA to the relevant underlying TOKEN
        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); 
        // Calculate LP tokens to be minted
        _incrementPoolBalances(_actualInputBase, 0); 
        // Update recorded SPARTA amount
        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); 
        // Calc slip fee in TOKEN
        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); 
        // Convert TOKEN fee to SPARTA
        _mint(synthOut, _liquidityUnits); 
        // Mint the LP tokens directly to the Synth contract to hold
        iSYNTH(synthOut).mintSynth(member, output); 
        // Mint the Synth tokens directly to the user
        _addPoolMetrics(fee); 
        // Add slip fee to the revenue metrics
        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);
      return (output, fee);
    }
    
    // Swap Synths for SPARTA
    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, ""!synth""); 
        // Must be a valid Synth
        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); 
        // Get received SYNTH amount
        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); 
        // Calculate value of swapping relevant underlying TOKEN to SPARTA
        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); 
        // Calc slip fee in SPARTA
        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); 
        // Transfer SYNTH to relevant synth contract
        iSYNTH(synthIN).burnSynth(); 
        // Burn the SYNTH units
        _decrementPoolBalances(outputBase, 0); 
        // Update recorded SPARTA amount
        iBEP20(BASE).transfer(member, outputBase); 
        // Transfer SPARTA to user
        _addPoolMetrics(fee); 
        // Add slip fee to the revenue metrics
        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);
      return (outputBase, fee);
    }

    //=======================================INTERNAL MATHS======================================//

    // Check the SPARTA amount received by this Pool
    function _getAddedBaseAmount() internal view returns(uint256 _actual){
        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); 
        if(_baseBalance > baseAmount){
            _actual = _baseBalance-(baseAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }
  
    // Check the TOKEN amount received by this Pool
    function _getAddedTokenAmount() internal view returns(uint256 _actual){
        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); 
        if(_tokenBalance > tokenAmount){
            _actual = _tokenBalance-(tokenAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }

    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts
    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = baseAmount;
        uint256 _Y = tokenAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); 
        // Calc TOKEN output
        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); 
        // Calc TOKEN fee
        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee);
         // Convert TOKEN fee to SPARTA
        _setPoolAmounts(_X + _x, _Y - _y); 
        // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); 
        // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts
    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = tokenAmount;
        uint256 _Y = baseAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); 
        // Calc SPARTA output
        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); 
        // Calc SPARTA fee
        _setPoolAmounts(_Y - _y, _X + _x); 
        // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); 
        // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    //=======================================BALANCES=========================================//

    // Sync internal balances to actual
    function sync() external {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }

    // Increment internal balances
    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount += _baseAmount;
        tokenAmount += _tokenAmount;
    }

    // Set internal balances
    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {
        baseAmount = _baseAmount;
        tokenAmount = _tokenAmount; 
    }

    // Decrement internal balances
    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount -= _baseAmount;
        tokenAmount -= _tokenAmount; 
    }

    //===========================================POOL FEE ROI=================================//

    function _addPoolMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            // 30Days
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        } else {
            lastMonth = block.timestamp;
            mapPast30DPoolRevenue = map30DPoolRevenue;
            addRevenue(mapPast30DPoolRevenue);
            map30DPoolRevenue = 0;
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; 
        // 2
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",4067,418,"H-02: Pool.sol & Synth.sol: Failing Max Value Allowance L-03: Pool.sol: swapTo() should not be payable",2
20_Synth.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./Pool.sol"";  
import ""./interfaces/iPOOLFACTORY.sol"";

contract Synth is iBEP20 {
    address public BASE;
    address public LayerONE; 
    // Underlying relevant layer1 token
    uint public genesis;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;

    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    mapping(address => uint) public mapSynth_LPBalance;
    mapping(address => uint) public mapSynth_LPDebt;
   
    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }
    
    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER, ""!DAO"");
        _;
    }

    // Restrict access
    modifier onlyPool() {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, ""!curated"");
        _;
    }
    
    constructor (address _base, address _token) {
        BASE = _base;
        LayerONE = _token;
        string memory synthName = ""-SpartanProtocolSynthetic"";
        string memory synthSymbol = ""-SPS"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));
        decimals = iBEP20(_token).decimals();
        DEPLOYER = msg.sender;
        genesis = block.timestamp;
    }

    //========================================iBEP20=========================================//

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    // iBEP20 Transfer function
    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    // iBEP20 Approve, change allowance functions
    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { 
            // No need to re-approve if already max
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }
    
    // iBEP20 TransferFrom function
    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        // Unlimited approval (saves an SSTORE)
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    //iBEP677 approveAndCall
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _approve(msg.sender, recipient, type(uint256).max); 
        // Give recipient max approval
        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); 
        // Amount is passed thru to recipient
        return true;
    }

    //iBEP677 transferAndCall
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _transfer(msg.sender, recipient, amount);
        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); 
        // Amount is passed thru to recipient 
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    // Burn supply
    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //==================================== SYNTH FUNCTIONS =================================//

    // Handle received LP tokens and mint Synths
    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){
        uint lpUnits = _getAddedLPAmount(msg.sender); 
        // Get the received LP units
        mapSynth_LPDebt[msg.sender] += amount; 
        // Increase debt by synth amount
        mapSynth_LPBalance[msg.sender] += lpUnits; 
        // Increase lp balance by LPs received
        _mint(member, amount); 
        // Mint the synths & tsf to user
        return amount;
    }
    
    // Handle received Synths and burn the LPs and Synths
    function burnSynth() external returns (bool){
        uint _syntheticAmount = balanceOf(address(this)); 
        // Get the received synth units
        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; 
        // share = amount * part/total
        mapSynth_LPBalance[msg.sender] -= _amountUnits; 
        // Reduce lp balance
        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; 
        // Reduce debt by synths being burnt
        if(_amountUnits > 0){
            _burn(address(this), _syntheticAmount); 
            // Burn the synths
            Pool(msg.sender).burn(_amountUnits); 
            // Burn the LP tokens
        }
        return true;
    }

    // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)
    function realise(address pool) external {
        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); 
        // Get the SPARTA value of the LP tokens
        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); 
        // Get the SPARTA value of the synths
        if(baseValueLP > baseValueSynth){
            uint premium = baseValueLP - baseValueSynth; 
            // Get the premium between the two values
            if(premium > 10**18){
                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); 
                // Get the LP value of the premium
                mapSynth_LPBalance[pool] -= premiumLP; 
                // Reduce the LP balance
                Pool(pool).burn(premiumLP); 
                // Burn the premium of the LP tokens
            }
        }
    }

    // Check the received token amount
    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){
        if(_amount > 0) {
            uint startBal = iBEP20(_token).balanceOf(address(this)); 
            // Get existing balance
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            // Transfer tokens in
            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; 
            // Calculate received amount
        }
        return _actual;
    }

    // Check the received LP tokens amount
    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){
        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); 
        // Get total balance held
        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){
            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; 
            // Get received amount
        } else {
            _actual = 0;
        }
        return _actual;
    }

    function getmapAddress_LPBalance(address pool) external view returns (uint){
        return mapSynth_LPBalance[pool];
    }

    function getmapAddress_LPDebt(address pool) external view returns (uint){
        return mapSynth_LPDebt[pool];
    }
}",2248,255,"H-02: Pool.sol & Synth.sol: Failing Max Value Allowance H-05: Synth realise is vulnerable to flash loan attacks",2
83_Shelter.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IShelter } from ""./interfaces/IShelter.sol"";
import { IShelterClient } from ""./interfaces/IShelterClient.sol"";

contract Shelter is IShelter {
    using SafeERC20 for IERC20;

    IShelterClient public immutable client;

    uint256 public constant GRACE_PERIOD = 1 weeks;

    mapping(IERC20 => mapping(address => bool)) public override claimed;

    mapping(IERC20 => uint256) public activated;

    mapping(IERC20 => uint256) public savedTokens;

    modifier onlyClient {
        require(msg.sender == address(client), ""!client"");
        _;
    }

    constructor(IShelterClient _client){
        client = _client;
    }

    function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function activate(IERC20 _token) external override onlyClient {
        activated[_token] = block.timestamp;
        savedTokens[_token] = _token.balanceOf(address(this));
        emit ShelterActivated(_token);
    }

    function deactivate(IERC20 _token) external override onlyClient {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, ""too late"");
        activated[_token] = 0;
        savedTokens[_token] = 0;
        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));
        emit ShelterDeactivated(_token);
    }

    function withdraw(IERC20 _token, address _to) external override {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, ""shelter not activated"");
        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);
        claimed[_token][_to] = true;
        emit ExitShelter(_token, msg.sender, _to, amount);
        _token.safeTransfer(_to, amount);
    }
}",511,60,"H-03: Repeated Calls to Shelter.withdraw Can Drain All Funds in Shelter (L52-L57) H-07: Shelter claimed mapping is set with _to address and not msg.sender L55 M-01: Deposits after the grace period should not be allowed. L34, L54 M-07: Fee-on-transfer token donations in Shelter break withdrawals L34 M-08: Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated L32-L36",5
113_NFTPair.sol,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";

struct TokenLoanParams {
    uint128 valuation; 
    // How much will you get? OK to owe until expiration.
    uint64 duration; 
    // Length of loan in seconds
    uint16 annualInterestBPS; 
    // Variable cost of taking out the loan
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPair
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPair is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPair public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration && params.valuation <= cur.valuation && params.annualInterestBPS <= cur.annualInterestBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral as the lender. The loan has to be
            // expired and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");
            require(
                // Addition is safe: both summands are smaller than 256 bits
                uint256(loan.startTime) + tokenLoanParams[tokenId].duration <= block.timestamp,
                ""NFTPair: not expired""
            );
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS,
            ""NFTPair: bad params""
        );

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x06bcca6f35b7c1b98f11abbb10957d273a681069ba90358de25404f49e2430f8;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xf2c9128b0fb8406af3168320897e5ff08f3bb536dd5f804c29ed276e93ec4336;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        if (v == 0 && r == bytes32(0) && s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    nonce,
                    deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), v, r, s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        require(block.timestamp <= deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                nonce,
                deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); 
        // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (
                    uint256 tokenId,
                    address borrower,
                    TokenLoanParams memory params,
                    bool skimFunds,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = abi.decode(datas[i], (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8152,737,M-01: Reentrancy at _requestLoan allows requesting a loan without supplying collateral  L218,1
107_yVault.sol,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/IYVault.sol"";

/// @title JPEG'd yVault
/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).
/// Non whitelisted contracts can't deposit/withdraw.
/// Owner is DAO
contract YVault is ERC20, Ownable {
    using SafeERC20 for ERC20;
    using Address for address;

    event Deposit(address indexed depositor, uint256 wantAmount);
    event Withdrawal(address indexed withdrawer, uint256 wantAmount);

    struct Rate {
        uint128 numerator;
        uint128 denominator;
    }

    ERC20 public immutable token;
    IController public controller;
    
    address public farm;
    
    Rate internal availableTokensRate;

    mapping(address => bool) public whitelistedContracts;

    /// @param _token The token managed by this vault
    /// @param _controller The JPEG'd strategies controller
    constructor(
        address _token,
        address _controller,
        Rate memory _availableTokensRate
    )
        ERC20(
            string(
                abi.encodePacked(""JPEG\xE2\x80\x99d "", ERC20(_token).name())
            ),
            string(abi.encodePacked(""JPEGD"", ERC20(_token).symbol()))
        )
    {
        setController(_controller);
        setAvailableTokensRate(_availableTokensRate);
        token = ERC20(_token);
    }

    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.
    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.
    /// The {isContract} function returns false when `_account` is a contract executing constructor code.
    /// This may lead to some contracts being able to bypass this check.
    /// @param _account Address to check
    modifier noContract(address _account) {
        require(
            !_account.isContract() || whitelistedContracts[_account],
            ""Contracts not allowed""
        );
        _;
    }

    /// @inheritdoc ERC20
    function decimals() public view virtual override returns (uint8) {
        return token.decimals();
    }

    /// @return The total amount of tokens managed by this vault and the underlying strategy
    function balance() public view returns (uint256) {
        return
            token.balanceOf(address(this)) +
            controller.balanceOf(address(token));
    }

    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}
    function balanceOfJPEG() external view returns (uint256) {
        return controller.balanceOfJPEG(address(token));
    }

    /// @notice Allows the owner to whitelist/blacklist contracts
    /// @param _contract The contract address to whitelist/blacklist
    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`
    function setContractWhitelisted(address _contract, bool _isWhitelisted)
        external
        onlyOwner
    {
        whitelistedContracts[_contract] = _isWhitelisted;
    }

    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow
    /// @param _rate The new rate
    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {
        require(
            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,
            ""INVALID_RATE""
        );
        availableTokensRate = _rate;
    }

    /// @notice ALlows the owner to set this vault's controller
    /// @param _controller The new controller
    function setController(address _controller) public onlyOwner {
        require(_controller != address(0), ""INVALID_CONTROLLER"");
        controller = IController(_controller);
    }

    /// @notice Allows the owner to set the yVault LP farm
    /// @param _farm The new farm
    function setFarmingPool(address _farm) public onlyOwner {
        require(_farm != address(0), ""INVALID_FARMING_POOL"");
        farm = _farm;
    }

    /// @return How much the vault allows to be borrowed by the underlying strategy.
    /// Sets minimum required on-hand to keep small withdrawals cheap
    function available() public view returns (uint256) {
        return
            (token.balanceOf(address(this)) * availableTokensRate.numerator) /
            availableTokensRate.denominator;
    }

    /// @notice Deposits `token` into the underlying strategy
    function earn() external {
        uint256 _bal = available();
        token.safeTransfer(address(controller), _bal);
        controller.earn(address(token), _bal);
    }

    /// @notice Allows users to deposit their entire `token` balance
    function depositAll() external {
        deposit(token.balanceOf(msg.sender));
    }

    /// @notice Allows users to deposit `token`. Contracts can't call this function
    /// @param _amount The amount to deposit
    function deposit(uint256 _amount) public noContract(msg.sender) {
        require(_amount > 0, ""INVALID_AMOUNT"");
        uint256 balanceBefore = balance();
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 supply = totalSupply();
        uint256 shares;
        if (supply == 0) {
            shares = _amount;
        } else {
            //balanceBefore can't be 0 if totalSupply is > 0
            shares = (_amount * supply) / balanceBefore;
        }
        _mint(msg.sender, shares);

        emit Deposit(msg.sender, _amount);
    }

    /// @notice Allows users to withdraw all their deposited balance
    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    /// @notice Allows users to withdraw tokens. Contracts can't call this function
    /// @param _shares The amount of shares to burn
    function withdraw(uint256 _shares) public noContract(msg.sender) {
        require(_shares > 0, ""INVALID_AMOUNT"");

        uint256 supply = totalSupply();
        require(supply > 0, ""NO_TOKENS_DEPOSITED"");

        uint256 backingTokens = (balance() * _shares) / supply;
        _burn(msg.sender, _shares);

        // Check balance
        uint256 vaultBalance = token.balanceOf(address(this));
        if (vaultBalance < backingTokens) {
            uint256 toWithdraw = backingTokens - vaultBalance;
            controller.withdraw(address(token), toWithdraw);
        }

        token.safeTransfer(msg.sender, backingTokens);
        emit Withdrawal(msg.sender, backingTokens);
    }

    /// @notice Allows anyone to withdraw JPEG to `farm` 
    function withdrawJPEG() external {
        require(farm != address(0), ""NO_FARM"");
        controller.withdrawJPEG(address(token), farm);
    }

    /// @return The underlying tokens per share
    function getPricePerFullShare() external view returns (uint256) {
        uint256 supply = totalSupply();
        if (supply == 0) return 0;
        return (balance() * 1e18) / supply;
    }

    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs
    function renounceOwnership() public view override onlyOwner {
        revert(""Cannot renounce ownership"");
    }
}",1617,204,"H-01: yVault: First depositor can break minting of shares L148-L153 H-04: Reentrancy issue in yVault.deposit   L144-145 H-06: Setting new controller can break YVaultLPFarming   L108 M-07: Wrong calculation for yVault price per share if decimals != 18.  ",4
66_sYETIToken.sol,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}

// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)
// modified by BoringCrypto for DictatorDAO


// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 
// Each rebase increases the effective yetibalance by a certain amount of the total value
// of the contract, which is equal to the yusd balance + the last price which the buyback 
// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200
// of the total value of the contract is added to the effective yetibalance. Also updated on 
// mint and withdraw, because that is actual value that is added to the contract. 

contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; 
    // 100% = 1e18. Amount to transfer over each rebase. 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain
    // and do that one. 
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    /// @notice owner > balance mapping.
    mapping(address => User) public users;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public override allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); 
                // Moved down so other failed calls safe some gas
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; 
                // Underflow is checked
                users[to].balance = toUser.balance + shares128; 
                // Can't overflow because totalSupply would be greater than 2^128-1;
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; 
            // Underflow is checked
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.
    /// @param to The address to move the tokens.
    /// @param shares of the tokens to move.
    /// @return (bool) Returns True if succeeded.
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.
    /// @param from Address to draw tokens from.
    /// @param to The address to move the tokens.
    /// @param shares The token shares to move.
    /// @return (bool) Returns True if succeeded.
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18
    /// theoretically you can grow the amount/share ratio, but it's not practical and useless
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); 
        // Must check underflow
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    /** 
     * Buyback function called by owner of function. Keeps track of the 
     */
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    /** 
     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.
     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock 
     * in order to activate. 
     * No YUSDToSell param since this just does 5% of the YUSD in the contract.
     */
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        // Get 5% of the YUSD in the contract
        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. 
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        // Checks internal mapping to see if router is valid
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    // Rebase function for adding new value to the sYETI - YETI ratio. 
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns 
        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance

        // raw balance of the contract
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        // amount of YETI free / available to give out
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        // in YETI, amount that should be eligible to give out.
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        // in YETI, amount to rebase
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. 
        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        // rebase amount joins the effective supply. 
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        // update rebase time
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    // Sums YUSD balance + old price. 
    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI 
    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    // Sets new transfer ratio for rebasing
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    // TODO - add time delay for setting new valid router. 
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    // TODO - add time delay for invalidating router. 
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    // Safe divide
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",3607,345,M-01: Wrong lastBuyBackPrice  ,1
20_synthVault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";

contract SynthVault {
    address public BASE;
    address public DEPLOYER;

    uint256 public minimumDepositTime;  
    // Withdrawal & Harvest lockout period; intended to be 1 hour
    uint256 public totalWeight;        
     // Total weight of the whole SynthVault
    uint256 public erasToEarn;          
    // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public vaultClaim;          
    // The SynthVaults's portion of rewards; intended to be ~10% initially
    address [] public stakedSynthAssets; 
    // Array of all synth assets that have ever been staked in (scope: vault)
    uint private lastMonth;             
    // Timestamp of the start of current metric period (For UI)
    uint public genesis;                
    // Timestamp from when the synth was first deployed (For UI)

    uint256 public map30DVaultRevenue; 
    // Tally of revenue during current incomplete metric period (for UI)
    uint256 public mapPast30DVaultRevenue; 
    // Tally of revenue from last full metric period (for UI)
    uint256 [] public revenueArray; 
    // Array of the last two metric periods (For UI)

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor(address _base) {
        BASE = _base;
        DEPLOYER = msg.sender;
        erasToEarn = 30;
        minimumDepositTime = 3600; 
        // 1 hour
        vaultClaim = 1000;
        genesis = block.timestamp;
        lastMonth = 0;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;
    mapping(address => uint256) private mapMemberTotal_weight;
    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;

    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;
    mapping(address => uint256) private mapMember_depositTime;
    mapping(address => uint256) public lastBlock;
    mapping(address => bool) private isStakedSynth;
    mapping(address => mapping(address => bool)) private isSynthMember;

    event MemberDeposits(
        address indexed synth,
        address indexed member,
        uint256 newDeposit,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberWithdraws(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberHarvests(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );

    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {
        erasToEarn = one;
        minimumDepositTime = two;
        vaultClaim = three;
    }

    //====================================== DEPOSIT ========================================//

    // User deposits Synths in the SynthVault
    function deposit(address synth, uint256 amount) external {
        depositForMember(synth, msg.sender, amount);
    }

    // Contract deposits Synths in the SynthVault for user
    function depositForMember(address synth, address member, uint256 amount) public {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); 
        // Must be a valid synth
        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); 
        // Must successfuly transfer in
        _deposit(synth, member, amount); 
        // Assess and record the deposit
    }

    // Check and record the deposit
    function _deposit(address _synth, address _member, uint256 _amount) internal {
        if(!isStakedSynth[_synth]){
            isStakedSynth[_synth] = true; 
            // Record as a staked synth
            stakedSynthAssets.push(_synth); 
            // Add to staked synth array
        }
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; 
        // Record deposit time (scope: member -> synth)
        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; 
        // Record deposit time (scope: member)
        mapMemberSynth_deposit[_member][_synth] += _amount; 
        // Record balance for member
        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); 
        // Get the SPARTA weight of the deposit
        mapMemberSynth_weight[_member][_synth] += _weight; 
        // Add the weight to the user (scope: member -> synth)
        mapMemberTotal_weight[_member] += _weight; 
        // Add to the user's total weight (scope: member)
        totalWeight += _weight; 
        // Add to the total weight (scope: vault)
        isSynthMember[_member][_synth] = true; 
        // Record user as a member
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    //====================================== HARVEST ========================================//

    // User harvests all of their available rewards
    function harvestAll() external returns (bool) {
        for(uint i = 0; i < stakedSynthAssets.length; i++){
            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){
                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);
                if(reward > 0){
                    harvestSingle(stakedSynthAssets[i]);
                }
            }
            
        }
        return true;
    }

    // User harvests available rewards of the chosen asset
    function harvestSingle(address synth) public returns (bool) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); 
        // Must be valid synth
        require(iRESERVE(_DAO().RESERVE()).emissions(), ""!emissions""); 
        // RESERVE emissions must be on
        uint256 _weight;
        uint256 reward = calcCurrentReward(synth, msg.sender); 
        // Calc user's current SPARTA reward
        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; 
        // Set last harvest time as now
        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); 
        // Get pool address
        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); 
        // Send the SPARTA from RESERVE to POOL
        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); 
        // Mint synths & tsf to SynthVault
        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); 
        // Calc reward's SPARTA value
        mapMemberSynth_deposit[msg.sender][synth] += synthReward; 
        // Record deposit for the user (scope: member -> synth)
        mapMemberSynth_weight[msg.sender][synth] += _weight; 
        // Add the weight to the user (scope: member -> synth)
        mapMemberTotal_weight[msg.sender] += _weight; 
        // Add to the user's total weight (scope: member)
        totalWeight += _weight; 
        // Add to the total weight (scope: vault)
        _addVaultMetrics(reward); 
        // Add to the revenue metrics (for UI)
        iSYNTH(synth).realise(_poolOUT); 
        // Check synth-held LP value for premium; burn if so
        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);
        return true;
    }

    // Calculate the user's current incentive-claim per era based on selected asset
    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){
        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), ""!unlocked""); 
        // Must not harvest before lockup period passed
        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; 
        // Get seconds passed since last claim
        uint256 _share = calcReward(synth, member); 
        // Get member's share of RESERVE incentives
        reward = (_share * _secondsSinceClaim) / iBASE(BASE).secondsPerEra(); 
        // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address synth, address member) public view returns (uint256) {
        uint256 _weight = mapMemberSynth_weight[member][synth]; 
        // Get user's weight (scope: member -> synth)
        uint256 _reserve = reserveBASE() / erasToEarn; 
        // Aim to deplete reserve over a number of days
        uint256 _vaultReward = (_reserve * vaultClaim) / 10000; 
        // Get the SynthVault's share of that
        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); 
        // Get member's share of that
    }

    //====================================== WITHDRAW ========================================//

    // User withdraws a percentage of their synths from the vault
    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); 
        // Perform the withdrawal
        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); 
        // Transfer from SynthVault to user
        return redeemedAmount;
    }

    // Contract withdraws a percentage of user's synths from the vault
    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {
        require((block.timestamp > mapMember_depositTime[_member]), ""lockout""); 
        // Must not withdraw before lockup period passed
        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); 
        // Calc amount to withdraw
        mapMemberSynth_deposit[_member][_synth] -= _principle; 
        // Remove from user's recorded vault holdings
        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); 
        // Calc SPARTA value of amount
        mapMemberTotal_weight[_member] -= _weight; 
        // Remove from member's total weight (scope: member)
        mapMemberSynth_weight[_member][_synth] -= _weight; 
        // Remove from member's synth weight (scope: member -> synth)
        totalWeight -= _weight; 
        // Remove from total weight (scope: vault)
        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);
        return (_principle + synthReward);
    }

    //================================ Helper Functions ===============================//

    function reserveBASE() public view returns (uint256) {
        return iBEP20(BASE).balanceOf(_DAO().RESERVE());
    }

    function getMemberDeposit(address synth, address member) external view returns (uint256){
        return mapMemberSynth_deposit[member][synth];
    }

    function getMemberWeight(address member) external view returns (uint256) {
        return mapMemberTotal_weight[member];
    }

    function getStakeSynthLength() external view returns (uint256) {
        return stakedSynthAssets.length;
    }

    function getMemberLastTime(address member) external view returns (uint256) {
        return mapMember_depositTime[member];
    }

    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){
        return mapMemberSynth_lastTime[member][synth];
    }

    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {
        return mapMemberSynth_weight[member][synth];
    }

    //=============================== SynthVault Metrics =================================//

    function _addVaultMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            // 30 days
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        } else {
            lastMonth = block.timestamp;
            mapPast30DVaultRevenue = map30DVaultRevenue;
            addRevenue(mapPast30DVaultRevenue);
            map30DVaultRevenue = 0;
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; 
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",3059,313,"H-01: SynthVault withdraw forfeits rewards The SynthVault.withdraw function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The synthReward variable in _processWithdraw is also never used - it was probably intended that this variable captures the claimed rewards. H-06: SynthVault rewards can be gamed The SynthVault._deposit function adds weight for the user that depends on the spot value of the deposit synth amount in BASE.",2
112_TopUpAction.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); 
        // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}",8076,947,"H-03: Customers cannot be topUp()ed a second time TopUpAction.sol#L847. Customers cannot be topped up a second time, which will cause them to be liquidated even though they think they're protected. M-03: Lack of safeApprove(0) prevents some registrations, and the changing of stakers and LP tokens TopUpAction.sol#L50",2
28_SushiToken.sol,"pragma solidity 0.6.12;

import ""./ERC20.sol"";
import ""../interfaces/IMisoToken.sol"";
import ""../OpenZeppelin/access/AccessControl.sol"";

// ---------------------------------------------------------------------
//
// SushiToken with Governance.
//
// From the MISO Token Factory
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

contract SushiToken is IMisoToken, AccessControl, ERC20 {
    /// @notice Miso template id for the token factory.
    /// @dev For different token types, this must be incremented.
    uint256 public constant override tokenTemplate = 3;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    function initToken(string memory _name, string memory _symbol, address _owner, uint256 _initialSupply) public {
        _initERC20(_name, _symbol);
        _setupRole(DEFAULT_ADMIN_ROLE, _owner);
        _setupRole(MINTER_ROLE, _owner);
        _mint(msg.sender, _initialSupply);
    }

    function init(bytes calldata _data) external override payable {}

    function initToken(
        bytes calldata _data
    ) public override {
        (string memory _name,
        string memory _symbol,
        address _owner,
        uint256 _initialSupply) = abi.decode(_data, (string, string, address, uint256));

        initToken(_name,_symbol,_owner,_initialSupply);
    }

    /** 
     * @dev Generates init data for Token Factory
     * @param _name - Token name
     * @param _symbol - Token symbol
     * @param _owner - Contract owner
     * @param _initialSupply Amount of tokens minted on creation
     */
    function getInitData(
        string calldata _name,
        string calldata _symbol,
        address _owner,
        uint256 _initialSupply
    )
        external
        pure
        returns (bytes memory _data)
    {
        return abi.encode(_name, _symbol, _owner, _initialSupply);
    }

    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).
    function mint(address _to, uint256 _amount) public  {
        require(hasRole(MINTER_ROLE, _msgSender()), ""SushiToken: must have minter role to mint"");
        _mint(_to, _amount);
        _moveDelegates(address(0), _delegates[_to], _amount);
    }

    // Copied and modified from YAM code:
    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol
    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol
    // Which is copied and modified from COMPOUND:
    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol

    /// @notice A record of each accounts delegate
    mapping (address => address) internal _delegates;

    /// @notice A checkpoint for marking number of votes from a given block
    struct Checkpoint {
        uint32 fromBlock;
        uint256 votes;
    }

    /// @notice A record of votes checkpoints for each account, by index
    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping (address => uint32) public numCheckpoints;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    /// @notice The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH = keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    /// @notice A record of states for signing / validating signatures
    mapping (address => uint) public sigNonces;

    /// @notice An event thats emitted when an account changes its delegate
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);

    /// @notice An event thats emitted when a delegate account's vote balance changes
    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);

    /**
     * @notice Delegate votes from `msg.sender` to `delegatee`
     * @param delegator The address to get delegatee for
     */
    function delegates(address delegator)
        external
        view
        returns (address)
    {
        return _delegates[delegator];
    }

   /**
    * @notice Delegate votes from `msg.sender` to `delegatee`
    * @param delegatee The address to delegate votes to
    */
    function delegate(address delegatee) external {
        return _delegate(msg.sender, delegatee);
    }

    /**
     * @notice Delegates votes from signatory to `delegatee`
     * @param delegatee The address to delegate votes to
     * @param nonce The contract state required to match the signature
     * @param expiry The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function delegateBySig(
        address delegatee,
        uint nonce,
        uint expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        external
    {
        bytes32 domainSeparator = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(name())),
                getChainId(),
                address(this)
            )
        );

        bytes32 structHash = keccak256(
            abi.encode(
                DELEGATION_TYPEHASH,
                delegatee,
                nonce,
                expiry
            )
        );

        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                domainSeparator,
                structHash
            )
        );

        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), ""SUSHI::delegateBySig: invalid signature"");
        require(nonce == sigNonces[signatory]++, ""SUSHI::delegateBySig: invalid nonce"");
        require(now <= expiry, ""SUSHI::delegateBySig: signature expired"");
        return _delegate(signatory, delegatee);
    }

    /**
     * @notice Gets the current votes balance for `account`
     * @param account The address to get votes balance
     * @return The number of current votes for `account`
     */
    function getCurrentVotes(address account)
        external
        view
        returns (uint256)
    {
        uint32 nCheckpoints = numCheckpoints[account];
        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
    }

    /**
     * @notice Determine the prior number of votes for an account as of a block number
     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
     * @param account The address of the account to check
     * @param blockNumber The block number to get the vote balance at
     * @return The number of votes the account had as of the given block
     */
    function getPriorVotes(address account, uint blockNumber)
        external
        view
        returns (uint256)
    {
        require(blockNumber < block.number, ""SUSHI::getPriorVotes: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; 
            // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _delegate(address delegator, address delegatee)
        internal
    {
        address currentDelegate = _delegates[delegator];
        if (currentDelegate != delegatee){
            uint256 delegatorBalance = balanceOf(delegator); 
            // balance of underlying SUSHIs (not scaled);
            _delegates[delegator] = delegatee;

            emit DelegateChanged(delegator, currentDelegate, delegatee);

            _moveDelegates(currentDelegate, delegatee, delegatorBalance);
        }
    }

    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                // decrease old representative
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint256 srcRepNew = srcRepOld.sub(amount);
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                // increase new representative
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
                uint256 dstRepNew = dstRepOld.add(amount);
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint256 oldVotes,
        uint256 newVotes
    )
        internal
    {
        uint32 blockNumber = safe32(block.number, ""SUSHI::_writeCheckpoint: block number exceeds 32 bits"");

        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function getChainId() internal pure returns (uint) {
        uint256 chainId;
        assembly { chainId := chainid() }
        return chainId;
    }
    
    /**
     * @inheritdoc ERC20
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override { 
        _moveDelegates(from, _delegates[to], amount);
        super._beforeTokenTransfer(from, to, amount);
    }
}",2538,317,"H-02: SushiToken transfers are broken due to wrong delegates accounting on transfers When minting / transferring / burning tokens, the SushiToken._beforeTokenTransfer function is called and supposed to correctly shift the voting power due to the increase/decrease in tokens for the from and to accounts. However, it does not correctly do that, it tries to shift the votes from the from account, instead of the _delegates[from] account. This can lead to transfers reverting.",1
8_NFTXFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.8;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";

import ""hardhat/console.sol"";

contract NFTXFeeDistributor is INFTXFeeDistributor, PausableUpgradeable {

  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;
  uint256 public override defaultTreasuryAlloc;
  uint256 public override defaultLPAlloc;

  mapping(uint256 => uint256) public override allocTotal;
  mapping(uint256 => uint256) public override specificTreasuryAlloc;
  mapping(uint256 => FeeReceiver[]) feeReceivers;

  event AddFeeReceiver(uint256 vaultId, address receiver, uint256 allocPoint);
  event FeeReceiverAllocChange(uint256 vaultId, address receiver, uint256 allocPoint);
  event RemoveFeeReceiver(uint256 vaultId, address receiver);
  
  function __FeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    lpStaking = _lpStaking;
    treasury = _treasury; 
    defaultTreasuryAlloc = 0.2 ether;
    defaultLPAlloc = 0.5 ether;
  }

  function rescue(address token) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));
    IERC20Upgradeable(token).transfer(msg.sender, balance);
  }

  function distribute(uint256 vaultId) external override {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
    if (tokenBalance <= 10**9) {
      return;
    }
    // Leave some balance for dust since we know we have more than 10**9.
    tokenBalance -= 1000;
    
    uint256 _treasuryAlloc = specificTreasuryAlloc[vaultId];
    if (_treasuryAlloc == 0) {
      _treasuryAlloc = defaultTreasuryAlloc;
    }

    uint256 _allocTotal = allocTotal[vaultId] + _treasuryAlloc;
    uint256 amountToSend = tokenBalance * _treasuryAlloc / _allocTotal;
    amountToSend = amountToSend > tokenBalance ? tokenBalance : amountToSend;
    IERC20Upgradeable(_vault).safeTransfer(treasury, amountToSend);

    if (distributionPaused) {
      return;
    } 

    FeeReceiver[] memory _feeReceivers = feeReceivers[vaultId];
    for (uint256 i = 0; i < _feeReceivers.length; i++) {
      _sendForReceiver(_feeReceivers[i], vaultId, _vault, tokenBalance, _allocTotal);
    } 
  }

  function addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) external override onlyOwner  {
    _addReceiver(_vaultId, _allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    _addReceiver(_vaultId, defaultLPAlloc, lpStaking, true);
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _vaultId, uint256 _receiverIdx, uint256 _allocPoint) external override onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_vaultId][_receiverIdx];
    allocTotal[_vaultId] -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal[_vaultId] += _allocPoint;
    emit FeeReceiverAllocChange(_vaultId, feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _vaultId, uint256 _receiverIdx, address _address, bool _isContract) external override onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_vaultId][_receiverIdx];
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
  }

  function removeReceiver(uint256 _vaultId, uint256 _receiverIdx) external override onlyOwner {
    FeeReceiver[] storage feeReceiversForVault = feeReceivers[_vaultId];
    uint256 arrLength = feeReceiversForVault.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(_vaultId, feeReceiversForVault[_receiverIdx].receiver);
    allocTotal[_vaultId] -= feeReceiversForVault[_receiverIdx].allocPoint;
    feeReceiversForVault[_receiverIdx] = feeReceiversForVault[arrLength-1];
    feeReceiversForVault.pop();
  }

  function setTreasuryAddress(address _treasury) external override onlyOwner {
    treasury = _treasury;
  }

  function setDefaultTreasuryAlloc(uint256 _allocPoint) external override onlyOwner {
    defaultTreasuryAlloc = _allocPoint;
  }

  function setSpecificTreasuryAlloc(uint256 vaultId, uint256 _allocPoint) external override onlyOwner {
    specificTreasuryAlloc[vaultId] = _allocPoint;
  }

  function setLPStakingAddress(address _lpStaking) external override onlyOwner {
    lpStaking = _lpStaking;
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
  }

  function setDefaultLPAlloc(uint256 _allocPoint) external override onlyOwner {
    defaultLPAlloc = _allocPoint;
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
  }

  function rescueTokens(uint256 _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).transfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) internal  {
    allocTotal[_vaultId] += _allocPoint;
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers[_vaultId].push(_feeReceiver);
    emit AddFeeReceiver(_vaultId, _receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 _tokenBalance, uint256 _allocTotal) internal {
    uint256 amountToSend = _tokenBalance * _receiver.allocPoint / _allocTotal;
    // If we're at this point we know we have more than enough to perform this safely.
    uint256 balance = IERC20Upgradeable(_vault).balanceOf(address(this)) - 1000;
    amountToSend = amountToSend > balance ? balance : amountToSend;
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);
      bool tokensReceived = abi.decode(returnData, (bool));
      if (!success || !tokensReceived) {
        console.log(""treasury fallback"");
        IERC20Upgradeable(_vault).safeTransfer(treasury, amountToSend);
      }
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1766,173,"M-03: Reentrancy The distribute function of NFTXFeeDistributor has no access control and will invoke a fallback on the fee receivers, meaning that a fee receiver can re-enter via this function to acquire their allocation repeatedly potentially draining the full balance and sending zero amounts to the rest of the recipients.",1
66_BorrowerOperations.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/ReentrancyGuard.sol"";
import ""./Interfaces/IWAsset.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, ""BO:MIN_NET_DEBT==0"");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, ""WrongLeverage"");
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), ""BO:RouteLeverUpNotSent"");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), ""BO:YUSDNotSentUnLever"");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), ""BO:TransferCollsFailed"");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), ""BO:BadColl"");
            require(_amounts[i] != 0, ""BO:NoAmounts"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BO:0Adjust""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), ""BO:TroveInactive"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), ""BO:TroveActive"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, ""BO:NoDebtChange"");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BO:InRecMode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BO:InRecMode""
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, ""BOps:Len0"");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, ""BO:LenMismatch"");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BO:ReqICR>MCR""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BO:ReqICR>CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BO:RecMode:ICR<oldICR""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BO:ReqTCR>CCR""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BO:netDebt<2000""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BO:InvalidYUSDRepay""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BO:InsuffYUSDBal""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert(""BO:InvalidMaxFee"");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  ""_requireValidRouterParams: _finalRoutedColls length mismatch"");
    //     require(_amounts.length == _routers.length, ""_requireValidRouterParams: _routers length mismatch"");
    //     require(_amounts.length == _minSwapAmounts.length, ""_minSwapAmounts: finalRoutedColls length mismatch"");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), ""_requireValidRouterParams: not a valid router"");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], ""_requireRouterAVAXIndicesInOrder: indices out of order"");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}",13817,1418,"M-05: Reentrancy There are several potential re-entrant functions in contracts/BorrowerOperations.sol: Function addColl() on line 346",1
29_IndexPool.sol,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IBentoBoxMinimal.sol"";
import ""../interfaces/IMasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""./TridentERC20.sol"";

/// @notice Trident exchange pool template with constant mean formula for swapping among an array of ERC-20 tokens.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract IndexPool is IPool, TridentERC20 {
    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);
    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);

    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;

    uint256 internal constant BASE = 10**18;
    uint256 internal constant MIN_TOKENS = 2;
    uint256 internal constant MAX_TOKENS = 8;
    uint256 internal constant MIN_FEE = BASE / 10**6;
    uint256 internal constant MAX_FEE = BASE / 10;
    uint256 internal constant MIN_WEIGHT = BASE;
    uint256 internal constant MAX_WEIGHT = BASE * 50;
    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;
    uint256 internal constant MIN_BALANCE = BASE / 10**12;
    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;
    uint256 internal constant MIN_POW_BASE = 1;
    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;
    uint256 internal constant POW_PRECISION = BASE / 10**10;
    uint256 internal constant MAX_IN_RATIO = BASE / 2;
    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;
    
    uint136 internal totalWeight;
    address[] internal tokens;
    
    uint256 public barFee;
    
    bytes32 public constant override poolIdentifier = ""Trident:Index"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    mapping(address => Record) public records;
    struct Record {
        uint120 reserve;
        uint136 weight;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address[] memory _tokens, uint136[] memory _weights, uint256 _swapFee) = abi.decode(
            _deployData,
            (address[], uint136[], uint256)
        );
        // @dev Factory ensures that the tokens are sorted.
        require(_tokens.length == _weights.length, ""INVALID_ARRAYS"");
        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, ""INVALID_TOKENS_LENGTH"");

        for (uint256 i = 0; i < _tokens.length; i++) {
            require(_tokens[i] != address(0), ""ZERO_ADDRESS"");
            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, ""INVALID_WEIGHT"");
            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});
            tokens.push(_tokens[i]);
            totalWeight += _weights[i];
        }
        
        require(totalWeight <= MAX_TOTAL_WEIGHT, ""MAX_TOTAL_WEIGHT"");
        // @dev This burns initial LP supply.
        _mint(address(0), INIT_POOL_SUPPLY); 

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));
        
        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        unlocked = 1;
    }
    
    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));
        
        uint120 ratio = uint120(_div(toMint, totalSupply));

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenIn = tokens[i];
            uint120 reserve = records[tokenIn].reserve;
            // @dev If token balance is '0', initialize with `ratio`.
            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;
            require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");
            // @dev Check Trident router has sent `amountIn` for skim into pool.
            unchecked { 
                // @dev This is safe from overflow - only logged amounts handled.
                require(_balance(tokenIn) >= amountIn + reserve, ""NOT_RECEIVED"");
                records[tokenIn].reserve += amountIn;
            }
            emit Mint(msg.sender, tokenIn, amountIn, recipient);
        }
        _mint(recipient, toMint);
        liquidity = toMint;
    }
    
    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));
        
        uint256 ratio = _div(toBurn, totalSupply);
        
        withdrawnAmounts = new TokenAmount[](tokens.length);
        
        _burn(address(this), toBurn);

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenOut = tokens[i];
            uint256 balance = records[tokenOut].reserve;
            uint120 amountOut = uint120(_mul(ratio, balance));
            require(amountOut != 0, ""ZERO_OUT"");
            // @dev This is safe from underflow - only logged amounts handled.
            unchecked {
                records[tokenOut].reserve -= amountOut;
            }
            _transfer(tokenOut, amountOut, recipient, unwrapBento);
            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});
            emit Burn(msg.sender, tokenOut, amountOut, recipient);
        }
    }
    
    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(
            data,
            (address, address, bool, uint256)
        );

        Record storage outRecord = records[tokenOut];

        amountOut = _computeSingleOutGivenPoolIn(
            outRecord.reserve,
            outRecord.weight,
            totalSupply,
            totalWeight,
            toBurn,
            swapFee
        );

        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), ""MAX_OUT_RATIO"");
        // @dev This is safe from underflow - only logged amounts handled.
        unchecked {
            outRecord.reserve -= uint120(amountOut);
        }
        _burn(address(this), toBurn);
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Burn(msg.sender, tokenOut, amountOut, recipient);
    }
    
    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(
            data,
            (address, address, address, bool, uint256)
        );

        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked { 
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (
            address tokenIn,
            address tokenOut,
            address recipient,
            bool unwrapBento,
            uint256 amountIn,
            bytes memory context
        ) = abi.decode(data, (address, address, address, bool, uint256, bytes));

        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);

        ITridentCallee(msg.sender).tridentSwapCallback(context);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked { 
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }
    
    function _balance(address token) internal view returns (uint256 balance) {
        (, bytes memory data) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, 
            token, address(this)));
        balance = abi.decode(data, (uint256));
    }

    function _getAmountOut(
        uint256 tokenInAmount,
        uint256 tokenInBalance,
        uint256 tokenInWeight,
        uint256 tokenOutBalance,
        uint256 tokenOutWeight
    ) internal view returns (uint256 amountOut) {
        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);
        // @dev This is safe from under/overflow - only logged amounts handled.
        unchecked {
            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));
            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);
            uint256 b = _compute(a, weightRatio);
            uint256 c = BASE - b;
            amountOut = _mul(tokenOutBalance, c);
        }
    }

    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {
        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, ""INVALID_BASE"");
        
        uint256 whole = (exp / BASE) * BASE;   
        uint256 remain = exp - whole;
        uint256 wholePow = _pow(base, whole / BASE);
        
        if (remain == 0) output = wholePow;
        
        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);
        output = _mul(wholePow, partialResult);
    }

    function _computeSingleOutGivenPoolIn(
        uint256 tokenOutBalance,
        uint256 tokenOutWeight,
        uint256 _totalSupply,
        uint256 _totalWeight,
        uint256 toBurn,
        uint256 _swapFee
    ) internal pure returns (uint256 amountOut) {
        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);
        uint256 newPoolSupply = _totalSupply - toBurn;
        uint256 poolRatio = _div(newPoolSupply, _totalSupply);
        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));
        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);
        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;
        uint256 zaz = (BASE - normalizedWeight) * _swapFee;
        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));
    }
    
    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {
        output = n % 2 != 0 ? a : BASE;
        for (n /= 2; n != 0; n /= 2) 
            a = a * a;
            if (n % 2 != 0) output = output * a;
    }
    
    function _powApprox(uint256 base, uint256 exp, uint256 precision) internal pure returns (uint256 sum) {
        uint256 a = exp;
        (uint256 x, bool xneg) = _subFlag(base, BASE);
        uint256 term = BASE;
        sum = term;
        bool negative;

        for (uint256 i = 1; term >= precision; i++) {
            uint256 bigK = i * BASE;
            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));
            term = _mul(term, _mul(c, x));
            term = _div(term, bigK);
            if (term == 0) break;
            if (xneg) negative = !negative;
            if (cneg) negative = !negative;
            if (negative) {
                sum = sum - term;
            } else {
                sum = sum + term;
            }
        }
    }
    
    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {
        // @dev This is safe from underflow - if/else flow performs checks. 
        unchecked {
            if (a >= b) {
                (difference, flag) = (a - b, false);
            } else {
                (difference, flag) = (b - a, true);
            }
        }
    }
    
    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * b;
        uint256 c1 = c0 + (BASE / 2);
        c2 = c1 / BASE;
    }
    
    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * BASE;
        uint256 c1 = c0 + (b / 2);
        c2 = c1 / b;
    }
    
    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, 
                token, address(this), to, 0, shares));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, 
                token, address(this), to, shares));
            require(success, ""TRANSFER_FAILED"");
        }
    }
    
    function getAssets() public view override returns (address[] memory assets) {
        assets = tokens;
    }
    
    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {
        (
            uint256 tokenInAmount,
            uint256 tokenInBalance,
            uint256 tokenInWeight,
            uint256 tokenOutBalance,
            uint256 tokenOutWeight
        ) = abi.decode(data, (uint256, uint256, uint256, uint256, uint256));
        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);
    }
    
    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {
        uint256 length = tokens.length;
        reserves = new uint256[](length);
        weights = new uint136[](length);
        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.
        unchecked {
            for (uint256 i = 0; i < length; i++) {
                reserves[i] = records[tokens[i]].reserve;
                weights[i] = records[tokens[i]].weight;
            }
        }
    }
}",3822,387,"H-01: Flash swap call back prior to transferring tokens in indexPool IndexPool.sol#L196-L223 H-02: Index Pool always swap to Zero IndexPool.sol#L286-L291 H-03: IndexPool pow overflows when weightRatio > 10. In the IndexPool contract, pow is used in calculating price. (IndexPool.sol L255-L266). However, Pow is easy to cause overflow. If the weightRatio is large (e.g. 10), there's always overflow. H-04: IndexPool's INIT_POOL_SUPPLY is not fair. H-06: IndexPool: Poor conversion from Balancer V1's corresponding functions H-07: IndexPool.mint The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss H-09: Unsafe cast in IndexPool mint leads to attack H-10: IndexPool initial LP supply computation is wrong H-13: Overflow in the mint function of IndexPool causes LPs' funds to be stolen L110 H-14: Incorrect usage of _pow in _computeSingleOutGivenPoolIn of IndexPool H-15: Incorrect multiplication in _computeSingleOutGivenPoolIn of IndexPool. L282",11
16_Trader.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./Interfaces/ITracerPerpetualSwaps.sol"";
import ""./Interfaces/Types.sol"";
import ""./Interfaces/ITrader.sol"";
import ""./lib/LibPerpetuals.sol"";
import ""./lib/LibBalances.sol"";
import {ECDSA} from ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";

/**
 * The Trader contract is used to validate and execute off chain signed and matched orders
 */
contract Trader is ITrader {
    // EIP712 Constants
    // https://eips.ethereum.org/EIPS/eip-712
    string private constant EIP712_DOMAIN_NAME = ""Tracer Protocol"";
    string private constant EIP712_DOMAIN_VERSION = ""1.0"";
    bytes32 private constant EIP712_DOMAIN_SEPERATOR =
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"");

    // EIP712 Types
    bytes32 private constant ORDER_TYPE =
        keccak256(
            ""Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)""
        );

    uint256 public constant override chainId = 1337; 
    bytes32 public immutable override EIP712_DOMAIN;

    // order hash to memory
    mapping(bytes32 => Perpetuals.Order) public orders;
    // maps an order hash to its signed order if seen before
    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;
    // order hash to amount filled
    mapping(bytes32 => uint256) public override filled;
    // order hash to average execution price thus far
    mapping(bytes32 => uint256) public override averageExecutionPrice;

    constructor() {
        // Construct the EIP712 Domain
        EIP712_DOMAIN = keccak256(
            abi.encode(
                EIP712_DOMAIN_SEPERATOR,
                keccak256(bytes(EIP712_DOMAIN_NAME)),
                keccak256(bytes(EIP712_DOMAIN_VERSION)),
                chainId,
                address(this)
            )
        );
    }

    function filledAmount(Perpetuals.Order memory order) external view override returns (uint256) {
        return filled[Perpetuals.orderId(order)];
    }

    function getAverageExecutionPrice(Perpetuals.Order memory order) external view override returns (uint256) {
        return averageExecutionPrice[Perpetuals.orderId(order)];
    }

    /**
     * @notice Batch executes maker and taker orders against a given market. Currently matching works
     *         by matching orders 1 to 1
     * @param makers An array of signed make orders
     * @param takers An array of signed take orders
     */
    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)
        external
        override
    {
        require(makers.length == takers.length, ""TDR: Lengths differ"");

        // safe as we've already bounds checked the array lengths
        uint256 n = makers.length;

        require(n > 0, ""TDR: Received empty arrays"");

        for (uint256 i = 0; i < n; i++) {
            // verify each order individually and together
            if (
                !isValidSignature(makers[i].order.maker, makers[i]) ||
                !isValidSignature(takers[i].order.maker, takers[i]) ||
                !isValidPair(takers[i], makers[i])
            ) {
                // skip if either order is invalid
                continue;
            }

            // retrieve orders
            // if the order does not exist, it is created here
            Perpetuals.Order memory makeOrder = grabOrder(makers, i);
            Perpetuals.Order memory takeOrder = grabOrder(takers, i);

            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);
            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);

            uint256 makeOrderFilled = filled[makerOrderId];
            uint256 takeOrderFilled = filled[takerOrderId];

            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);

            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);
            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(
                makeOrderFilled,
                averageExecutionPrice[makerOrderId],
                fillAmount,
                executionPrice
            );
            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(
                takeOrderFilled,
                averageExecutionPrice[takerOrderId],
                fillAmount,
                executionPrice
            );

            // match orders
            // referencing makeOrder.market is safe due to above require
            // make low level call to catch revert
            // todo this could be succeptible to re-entrancy as
            // market is never verified
            (bool success, ) = makeOrder.market.call(
                abi.encodePacked(
                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,
                    abi.encode(makeOrder, takeOrder, fillAmount)
                )
            );

            // ignore orders that cannot be executed
            if (!success) continue;

            // update order state
            filled[makerOrderId] = makeOrderFilled + fillAmount;
            filled[takerOrderId] = takeOrderFilled + fillAmount;
            averageExecutionPrice[makerOrderId] = newMakeAverage;
            averageExecutionPrice[takerOrderId] = newTakeAverage;
        }
    }

    /**
     * @notice Retrieves and validates an order from an order array
     * @param signedOrders an array of signed orders
     * @param index the index into the array where the desired order is
     * @return the specified order
     * @dev Should only be called with a verified signedOrder and with index
     *      < signedOrders.length
     */
    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index)
        internal
        returns (Perpetuals.Order memory)
    {
        Perpetuals.Order memory rawOrder = signedOrders[index].order;

        bytes32 orderHash = Perpetuals.orderId(rawOrder);
        // check if order exists on chain, if not, create it
        if (orders[orderHash].maker == address(0)) {
            // store this order to keep track of state
            orders[orderHash] = rawOrder;
            // map the order hash to the signed order
            orderToSig[orderHash] = signedOrders[index];
        }

        return orders[orderHash];
    }

    /**
     * @notice hashes a limit order type in order to verify signatures, per EIP712
     * @param order the limit order being hashed
     * @return an EIP712 compliant hash (with headers) of the limit order
     */
    function hashOrder(Perpetuals.Order memory order) public view override returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    ""\x19\x01"",
                    EIP712_DOMAIN,
                    keccak256(
                        abi.encode(
                            ORDER_TYPE,
                            order.maker,
                            order.market,
                            order.price,
                            order.amount,
                            uint256(order.side),
                            order.expires,
                            order.created
                        )
                    )
                )
            );
    }

    /**
     * @notice Gets the EIP712 domain hash of the contract
     */
    function getDomain() external view override returns (bytes32) {
        return EIP712_DOMAIN;
    }

    /**
     * @notice Verifies a given limit order has been signed by a given signer and has a correct nonce
     * @param signer The signer who is being verified against the order
     * @param signedOrder The signed order to verify the signature of
     * @return if an order has a valid signature and a valid nonce
     * @dev does not throw if the signature is invalid.
     */
    function isValidSignature(address signer, Types.SignedLimitOrder memory signedOrder) internal view returns (bool) {
        return verifySignature(signer, signedOrder);
    }

    /**
     * @notice Validates a given pair of signed orders against each other
     * @param signedOrder1 the first signed order
     * @param signedOrder2 the second signed order
     * @return if signedOrder1 is compatible with signedOrder2
     * @dev does not throw if pairs are invalid
     */
    function isValidPair(Types.SignedLimitOrder memory signedOrder1, Types.SignedLimitOrder memory signedOrder2)
        internal
        pure
        returns (bool)
    {
        return (signedOrder1.order.market == signedOrder2.order.market);
    }

    /**
     * @notice Verifies the signature component of a signed order
     * @param signer The signer who is being verified against the order
     * @param signedOrder The unsigned order to verify the signature of
     * @return true is signer has signed the order, else false
     */
    function verifySignature(address signer, Types.SignedLimitOrder memory signedOrder)
        public
        view
        override
        returns (bool)
    {
        return
            signer == ECDSA.recover(hashOrder(signedOrder.order), signedOrder.sigV, signedOrder.sigR, signedOrder.sigS);
    }

    /**
     * @return An order that has been previously created in contract, given a user-supplied order
     * @dev Useful for checking to see if a supplied order has actually been created
     */
    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {
        bytes32 orderId = Perpetuals.orderId(order);
        return orders[orderId];
    }
}",2063,250,H-01: Wrong trading pricing calculations,1
14_PrizePool.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";

/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.
/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.
/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens
abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  /// @dev Emitted when an instance is initialized
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  /// @dev Event emitted when controlled token is added
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  /// @dev Emitted when reserve is captured.
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  /// @dev Event emitted when assets are deposited
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  /// @dev Event emitted when timelocked funds are re-deposited
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when interest is awarded to a winner
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are awarded to a winner
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are transferred out
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC721s are awarded to a winner
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  /// @dev Event emitted when assets are withdrawn instantly
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  /// @dev Event emitted upon a withdrawal with timelock
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  /// @dev Event emitted when timelocked funds are swept back to a user
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  /// @dev Event emitted when the Liquidity Cap is set
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  /// @dev Event emitted when the Credit plan is set
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  /// @dev Event emitted when the Prize Strategy is set
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  /// @dev Emitted when credit is minted
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  /// @dev Emitted when credit is burned
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  /// @dev Reserve to which reserve fees are sent
  RegistryInterface public reserveRegistry;

  /// @dev A linked list of all the controlled tokens
  MappedSinglyLinkedList.Mapping internal _tokens;

  /// @dev The Prize Strategy that this Prize Pool is bound to.
  TokenListenerInterface public prizeStrategy;

  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.
  /// For example, if the maxExitFeeMantissa is ""0.1 ether"", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai
  uint256 public maxExitFeeMantissa;

  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).
  uint256 public maxTimelockDuration;

  /// @dev The total funds that are timelocked.
  uint256 public timelockTotalSupply;

  /// @dev The total funds that have been allocated to the reserve
  uint256 public reserveTotalSupply;

  /// @dev The total amount of funds that the prize pool can hold.
  uint256 public liquidityCap;

  /// @dev the The awardable balance
  uint256 internal _currentAwardBalance;

  /// @dev The timelocked balances for each user
  mapping(address => uint256) internal _timelockBalances;

  /// @dev The unlock timestamps for each user
  mapping(address => uint256) internal _unlockTimestamps;

  /// @dev Stores the credit plan for each token.
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  /// @dev Stores each users balance of credit per token.
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  /// @notice Initializes the Prize Pool
  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.
  /// @param _maxExitFeeMantissa The maximum exit fee size
  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  /// @dev Returns the address of the underlying ERC20 asset
  /// @return The address of the asset
  function token() external override view returns (address) {
    return address(_token());
  }

  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.
  /// @return The underlying balance of assets
  function balance() external returns (uint256) {
    return _balance();
  }

  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.
  /// @param to The address receiving the tokens
  /// @param amount The amount of timelocked assets to re-deposit
  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  /// @notice Deposit assets into the Prize Pool in exchange for tokens
  /// @param to The address receiving the newly minted tokens
  /// @param amount The amount of assets to deposit
  /// @param controlledToken The address of the type of token the user is minting
  /// @param referrer The referrer of the deposit
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.
  /// @param from The address to redeem tokens from.
  /// @param amount The amount of tokens to redeem for assets.
  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)
  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.
  /// @return The actual exit fee paid
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    // burn the credit
    _burnCredit(from, controlledToken, burnedCredit);

    // burn the tickets
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    // redeem the tickets less the fee
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  /// @notice Limits the exit fee to the maximum as hard-coded into the contract
  /// @param withdrawalAmount The amount that is attempting to be withdrawn
  /// @param exitFee The exit fee to check against the limit
  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.
  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.
  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.
  /// If the existing timelocked funds are still locked, then the incoming
  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.
  /// @param from The address to withdraw from
  /// @param amount The amount to withdraw
  /// @param controlledToken The type of token being withdrawn
  /// @return The timestamp from which the funds can be swept
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    // return the block at which the funds will be available
    return unlockTimestamp;
  }

  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.
  /// Note that this will overwrite the previous unlock timestamp.
  /// @param user The user whose timelock balance should increase
  /// @param amount The amount to increase by
  /// @param timestamp The new unlock timestamp
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    // Sweep the old balance, if any
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    // if the funds should already be unlocked
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  /// @notice Updates the Prize Strategy when tokens are transferred between holders.
  /// @param from The address the tokens are being transferred from (0 if minting)
  /// @param to The address the tokens are being transferred to (0 if burning)
  /// @param amount The amount of tokens being trasferred
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      // first accrue credit for their old balance
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        // if they are sending funds to someone else, we need to limit their accrued credit to their new balance
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    // if we aren't minting
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  /// @notice Returns the balance that is available to award.
  /// @dev captureAwardBalance() should be called first
  /// @return The total amount of assets to be awarded for the current prize
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  /// @notice Captures any available interest as award balance.
  /// @dev This function also captures the reserve fees.
  /// @return The total amount of assets to be awarded for the current prize
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  /// @notice Called by the prize strategy to award prizes.
  /// @dev The amount awarded must be less than the awardBalance()
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of assets to be awarded
  /// @param controlledToken The address of the asset token being awarded
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens
  /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  /// @notice Called by the Prize-Strategy to award external ERC20 prizes
  /// @dev Used to award any arbitrary tokens held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.
  /// @param to The user who is receiving the tokens
  /// @param amount The amount of tokens they are receiving
  /// @param controlledToken The token that is going to be minted
  /// @param referrer The user who referred the minting
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  /// @notice Called by the prize strategy to award external ERC721 prizes
  /// @dev Used to award any arbitrary NFTs held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param externalToken The address of the external NFT token being awarded
  /// @param tokenIds An array of NFT Token IDs to be transferred
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.
  /// @param amount The prize amount
  /// @return The size of the reserve portion of the prize
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts
  /// @param users An array of account addresses to sweep balances for
  /// @return The total amount of assets swept from the Prize Pool
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.
  /// @param users An array of owner addresses
  /// @return The total amount of assets swept from the Prize Pool
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    // if there is nothing to do, just quit
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  /// @notice Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  /// @dev Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  /// @return burnedCredit The credit that was burned
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  /// @notice Calculates the early exit fee for the given amount
  /// @param from The user who is withdrawing
  /// @param controlledToken The type of collateral being withdrawn
  /// @param amount The amount of collateral to be withdrawn
  /// @return exitFee The exit fee
  /// @return burnedCredit The user's credit that was burned
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  /// @dev Calculates the early exit fee for the given amount
  /// @param amount The amount of collateral to be withdrawn
  /// @return Exit fee
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    // interest = credit rate * principal * time
    // => time = interest / (credit rate * principal)
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  /// @notice Burns a users credit.
  /// @param user The user whose credit should be burned
  /// @param credit The amount of credit to burn
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.
  /// @param user The user for whom to accrue credit
  /// @param controlledToken The controlled token whose balance we are checking
  /// @param controlledTokenBalance The balance to use for the user
  /// @param extra Additional credit to be added
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)
  /// @param creditBalance The new credit balance to be checked
  /// @return The users new credit balance.  Will not exceed the credit limit.
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  /// @notice Calculates the accrued interest for a user
  /// @param user The user whose credit should be calculated.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The user's current balance of the controlled tokens.
  /// @return The credit that has accrued since the last credit update.
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.
  /// @param user The user whose credit balance should be returned
  /// @return The balance of the users credit
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  /// @notice Sets the rate at which credit accrues per second.  The credit rate is a fixed point 18 number (like Ether).
  /// @param _controlledToken The controlled token for whom to set the credit plan
  /// @param _creditRateMantissa The credit rate to set.  Is a fixed point 18 decimal (like Ether).
  /// @param _creditLimitMantissa The credit limit to set.  Is a fixed point 18 decimal (like Ether).
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  /// @notice Returns the credit rate of a controlled token
  /// @param controlledToken The controlled token to retrieve the credit rates for
  /// @return creditLimitMantissa The credit limit fraction.  This number is used to calculate both the credit limit and early exit fee.
  /// @return creditRateMantissa The credit rate. This is the amount of tokens that accrue per second.
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  /// @notice Calculate the early exit for a user given a withdrawal amount.  The user's credit is taken into account.
  /// @param from The user who is withdrawing
  /// @param controlledToken The token they are withdrawing
  /// @param amount The amount of funds they are withdrawing
  /// @return earlyExitFee The additional exit fee that should be charged.
  /// @return creditBurned The amount of credit that will be burned
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    /*
    The credit is used *last*.  Always charge the fees up-front.

    How to calculate:

    Calculate their remaining exit fee.  I.e. full exit fee of their balance less their credit.

    If the exit fee on their withdrawal is greater than the remaining exit fee, then they'll have to pay the difference.
    */

    // Determine available usable credit based on withdraw amount
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    // Determine amount of credit to burn and amount of fees required
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold
  /// @param _liquidityCap The new liquidity cap for the prize pool
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  /// @notice Adds a new controlled token
  /// @param _controlledToken The controlled token to add.  Cannot be a duplicate.
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)
  /// @return An array of controlled token addresses
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  /// @dev Gets the current time as represented by the current block
  /// @return The timestamp of the current block
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  /// @notice The timestamp at which an account's timelocked balance will be made available to sweep
  /// @param user The address of an account with timelocked assets
  /// @return The timestamp at which the locked assets will be made available
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  /// @notice The balance of timelocked assets for an account
  /// @param user The address of an account with timelocked assets
  /// @return The amount of assets that have been timelocked
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool
  /// @param compLike The COMP-like token held by the prize pool that should be delegated
  /// @param to The address to delegate to 
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  /// @dev Checks if the Prize Pool can receive liquidity based on the current cap
  /// @param _amount The amount of liquidity to be added to the Prize Pool
  /// @return True if the Prize Pool can receive the specified amount of liquidity
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  /// @dev Checks if a specific token is controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  /// @return True if the token is a controlled token, false otherwise
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  /// @notice Determines whether the passed token can be transferred out as an external award.
  /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
  /// prize strategy should not be allowed to move those tokens.
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return The ERC20 asset token
  function _token() internal virtual view returns (IERC20Upgradeable);

  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
  /// @return The underlying balance of asset tokens
  function _balance() internal virtual returns (uint256);

  /// @notice Supplies asset tokens to the yield source.
  /// @param mintAmount The amount of asset tokens to be supplied
  function _supply(uint256 mintAmount) internal virtual;

  /// @notice Redeems asset tokens from the yield source.
  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed
  /// @return The actual amount of tokens that were redeemed.
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  /// @dev Function modifier to ensure usage of tokens controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  /// @dev Function modifier to ensure caller is the prize-strategy
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}",10191,1130,"H-04: withdraw timelock can be circumvented One can withdraw the entire PrizePool deposit by circumventing the timelock. Assume the user has no credits for ease of computation",1
78_FlashGovernanceArbiter.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./Governable.sol"";
import ""hardhat/console.sol"";
import ""../facades/Burnable.sol"";

///@title Flash Governance Arbiter
///@author Justin Goro
/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.
 * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.
 * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.
 * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed
 * By default, the asset is EYE.
 */
contract FlashGovernanceArbiter is Governable {
  /**
   * @param actor user making flash governance decision
   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.
   * @param amount is the amount of the deposit_asset to be put up as decision collateral.
   * @param target is the contract that will be affected by the flash governance decision.
   */
  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);

  mapping(address => bool) enforceLimitsActive;

  constructor(address dao) Governable(dao) {}

  struct FlashGovernanceConfig {
    address asset;
    uint256 amount;
    uint256 unlockTime;
    bool assetBurnable;
  }

  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.
  struct SecurityParameters {
    uint8 maxGovernanceChangePerEpoch; 
    //prevents flash governance from wrecking the incentives.
    uint256 epochSize; 
    //only one flash governance action can happen per epoch to prevent governance DOS
    uint256 lastFlashGovernanceAct;
    uint8 changeTolerance; 
    //1-100 maximum percentage any numeric variable can be changed through flash gov
  }

  //the current parameters determining the rules of flash governance
  FlashGovernanceConfig public flashGovernanceConfig;
  SecurityParameters public security;

  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules
   *without undermining the terms under which pending decisions were made.
   */
  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; 
  //contract->user->config

  /**
   *@notice An attempt is made to withdraw the current deposit requirement.
   * For a given user, flash governance decisions can only happen one at a time
   *@param sender is the user making the flash governance decision
   *@param target is the contract that will be affected by the flash governance decision.
   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.
   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.
   */
  function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
    if (
      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&
      pendingFlashDecision[target][sender].unlockTime < block.timestamp
    ) {
      require(
        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),
        ""Limbo: flash governance disabled for rest of epoch""
      );
      pendingFlashDecision[target][sender] = flashGovernanceConfig;
      pendingFlashDecision[target][sender].unlockTime += block.timestamp;

      security.lastFlashGovernanceAct = block.timestamp;
      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);
    } else {
      revert(""LIMBO: governance decision rejected."");
    }
  }

  /**
   *@param asset is the asset type put up as decision collateral. Must be burnable.
   *@param amount is the amount of the deposit_asset to be put up as decision collateral.
   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision
   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.
   */
  function configureFlashGovernance(
    address asset,
    uint256 amount,
    uint256 unlockTime,
    bool assetBurnable
  ) public virtual onlySuccessfulProposal {
    flashGovernanceConfig.asset = asset;
    flashGovernanceConfig.amount = amount;
    flashGovernanceConfig.unlockTime = unlockTime;
    flashGovernanceConfig.assetBurnable = assetBurnable;
  }

  /**
    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS
    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations
    @param changeTolerance is the amount by which a variable can be changed through flash governance.
    */
  function configureSecurityParameters(
    uint8 maxGovernanceChangePerEpoch,
    uint256 epochSize,
    uint8 changeTolerance
  ) public virtual onlySuccessfulProposal {
    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;
    security.epochSize = epochSize;
    require(security.changeTolerance < 100, ""Limbo: % between 0 and 100"");
    security.changeTolerance = changeTolerance;
  }

  /**
    @notice LimboDAO proposals for burning flash governance collateral act through this function
    @param targetContract is the contract that is affected by the flash governance decision.
    @param user is the user who made the flash governance decision
    @param asset is the collateral asset to be burnt
    @param amount is the amount of the collateral to be burnt
    */
  function burnFlashGovernanceAsset(
    address targetContract,
    address user,
    address asset,
    uint256 amount
  ) public virtual onlySuccessfulProposal {
    if (pendingFlashDecision[targetContract][user].assetBurnable) {
      Burnable(asset).burn(amount);
    }

    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
  }

  /**
   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset
   *@param targetContract is the contract that is affected by the flash governance decision.
   *@param asset is the collateral asset to be withdrawn
   */
  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }

  /**
   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance
   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.
   * @param enforce for the given context, set whether variable movement limits are enforced or not.
   */
  function setEnforcement(bool enforce) public {
    enforceLimitsActive[msg.sender] = enforce;
  }

  ///@dev for negative values, relative comparisons need to be calculated correctly.
  function enforceToleranceInt(int256 v1, int256 v2) public view {
    if (!configured) return;
    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);
    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);
    enforceTolerance(uv1, uv2);
  }

  ///@notice Allows functions to enforce maximum limits on a per variable basis
  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.
  function enforceTolerance(uint256 v1, uint256 v2) public view {
    if (!configured || !enforceLimitsActive[msg.sender]) return;
    //bonus points for readability
    if (v1 > v2) {
      if (v2 == 0) require(v1 <= 1, ""FE1"");
      else require(((v1 - v2) * 100) < security.changeTolerance * v1, ""FE1"");
    } else {
      if (v1 == 0) require(v2 <= 1, ""FE1"");
      else require(((v2 - v1) * 100) < security.changeTolerance * v1, ""FE1"");
    }
  }
}",1932,191,"H-01: Lack of access control on assertGovernanceApproved can cause funds to be locked DAO/FlashGovernanceArbiter.sol#L60-L81 H-04: Logic error in burnFlashGovernanceAsset can cause locked assets to be stolen DAO/FlashGovernanceArbiter.sol#L134 DAO/FlashGovernanceArbiter.sol#L146",2
12_Witch.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./utils/access/AccessControl.sol"";
import ""./interfaces/vault/ILadle.sol"";
import ""./interfaces/vault/ICauldron.sol"";
import ""./interfaces/vault/DataTypes.sol"";
import ""./math/WMul.sol"";
import ""./math/WDiv.sol"";
import ""./math/WDivUp.sol"";
import ""./math/CastU256U128.sol"";


contract Witch is AccessControl() {
    using WMul for uint256;
    using WDiv for uint256;
    using WDivUp for uint256;
    using CastU256U128 for uint256;

    event AuctionTimeSet(uint128 indexed auctionTime);
    event InitialProportionSet(uint128 indexed initialProportion);
    event Bought(bytes12 indexed vaultId, address indexed buyer, uint256 ink, uint256 art);
  
    uint128 public auctionTime = 4 * 60 * 60; 
    uint128 public initialProportion = 5e17; 

    ICauldron immutable public cauldron;
    ILadle immutable public ladle;
    mapping(bytes12 => address) public vaultOwners;

    constructor (ICauldron cauldron_, ILadle ladle_) {
        cauldron = cauldron_;
        ladle = ladle_;
    }

    /// @dev Set the auction time to calculate liquidation prices
    function setAuctionTime(uint128 auctionTime_) public auth {
        auctionTime = auctionTime_;
        emit AuctionTimeSet(auctionTime_);
    }

    /// @dev Set the proportion of the collateral that will be sold at auction start
    function setInitialProportion(uint128 initialProportion_) public auth {
        require (initialProportion_ <= 1e18, ""Only at or under 100%"");
        initialProportion = initialProportion_;
        emit InitialProportionSet(initialProportion_);
    }

    /// @dev Put an undercollateralized vault up for liquidation.
    function grab(bytes12 vaultId) public {
        DataTypes.Vault memory vault = cauldron.vaults(vaultId);
        vaultOwners[vaultId] = vault.owner;
        cauldron.grab(vaultId, address(this));
    }

    /// @dev Buy an amount of collateral off a vault in liquidation, paying at most `max` underlying.
    function buy(bytes12 vaultId, uint128 art, uint128 min) public {
        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);

        require (balances_.art > 0, ""Nothing to buy"");                                    
        uint256 elapsed = uint32(block.timestamp) - cauldron.auctions(vaultId);           
        uint256 price;
        {
            // Price of a collateral unit, in underlying, at the present moment, for a given vault
            //
            //                ink                     min(auction, elapsed)
            // price = 1 / (------- * (p + (1 - p) * -----------------------))
            //                art                          auction
            (uint256 auctionTime_, uint256 initialProportion_) = (auctionTime, initialProportion);
            uint256 term1 = uint256(balances_.ink).wdiv(balances_.art);
            uint256 dividend2 = auctionTime_ < elapsed ? auctionTime_ : elapsed;
            uint256 divisor2 = auctionTime_;
            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2));
            price = uint256(1e18).wdiv(term1.wmul(term2));
        }
        uint256 ink = uint256(art).wdivup(price);                                              
        require (ink >= min, ""Not enough bought"");

        ladle.settle(vaultId, msg.sender, ink.u128(), art);                                     
        if (balances_.art - art == 0) {
            cauldron.give(vaultId, vaultOwners[vaultId]);
            delete vaultOwners[vaultId];
        }

        emit Bought(vaultId, msg.sender, ink, art);
    }
}",867,87,"M-03: Witch can't give back vault after 2x grab The witch.sol contract gets access to a vault via the grab function in case of liquidation. If the witch.sol contract can't sell the debt within a certain amount of time, a second grab can occur.",1
19_TransactionManager.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.4;

import ""./interfaces/IFulfillHelper.sol"";
import ""./interfaces/ITransactionManager.sol"";
import ""./lib/LibAsset.sol"";
import ""./lib/LibERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";

// Outstanding qs:
// - what happens if you have unique user data, but duplicate tx ids?
//   no requires here would catch this, the tx would be properly prepared
//
// - we validate all the inputs but the amount, bidSignature, and encodedBid.
//   bidSignature and encodedBid could be used as slashing later, and their
//   validation is out of scope of this function. But, do we want to be able
//   to use this to send 0-value amounts? basically as some incentivized
//   relayer? would that break bidding?


/// @title TransactionManager
/// @author Connext <support@connext.network>
/// @notice This contract holds the logic to facilitate crosschain transactions.
///         Transactions go through three phases:
///
///         1. Route Auction: User broadcasts to our network signalling their 
///         desired route. Routers respond with sealed bids containing 
///         commitments to fulfilling the transaction within a certain time and 
///         price range.
///
///         2. Prepare: Once the auction is completed, the transaction can be 
///         prepared. The user submits a transaction to `TransactionManager` 
///         contract on sender-side chain containing router's signed bid. This 
///         transaction locks up the users funds on the sending chiain. Upon 
///         detecting an event containing their signed bid from the chain, 
///         router submits the same transaction to `TransactionManager` on the 
///         receiver-side chain, and locks up a corresponding amount of 
///         liquidity. The amount locked on the receiving chain is `sending 
///         amount - auction fee` so the router is incentivized to complete the 
///         transaction.
///
///         3. Fulfill: Upon detecting the `TransactionPrepared` event on the 
///         receiver-side chain, the user signs a message and sends it to a 
///         relayer, who will earn a fee for submission. The relayer (which may 
///         be the router) then submits the message to the `TransactionManager` 
///         to complete their transaction on receiver-side chain and claim the 
///         funds locked by the router. A relayer is used here to allow users 
///         to submit transactions with arbitrary calldata on the receiving 
///         chain without needing gas to do so. The router then submits the 
///         same signed message and completes transaction on sender-side, 
///         unlocking the original `amount`.
///
///         If a transaction is not fulfilled within a fixed timeout, it 
///         reverts and can be reclaimed by the party that called `prepare` on 
///         each chain (initiator). Additionally, transactions can be cancelled 
///         unilaterally by the person owed funds on that chain (router for 
///         sending chain, user for receiving chain) prior to expiry.

contract TransactionManager is ReentrancyGuard, ITransactionManager {
  /// @dev Mapping of router to balance specific to asset
  mapping(address => mapping(address => uint256)) public routerBalances;

  /// @dev Mapping of user address to blocks where active transfers
  ///      were created.
  mapping(address => uint256[]) public activeTransactionBlocks;

  /// @dev Mapping of hash of `InvariantTransactionData` to the hash
  //       of the `VariantTransactionData`
  mapping(bytes32 => bytes32) public variantTransactionData;

  /// @dev The chain id of the contract, is passed in to avoid any evm issues
  uint256 public immutable chainId;

  /// @dev Minimum timeout (will be the lowest on the receiving chain)
  uint256 public constant MIN_TIMEOUT = 24 hours;

  constructor(uint256 _chainId) {
    chainId = _chainId;
  }

  /// @notice This is used by any router to increase their available
  ///         liquidity for a given asset.
  /// @param amount The amount of liquidity to add for the router
  /// @param assetId The address (or `address(0)` if native asset) of the
  ///                asset you're adding liquidity for
  /// @param router The router you are adding liquidity on behalf of
  function addLiquidity(uint256 amount, address assetId, address router) external payable override nonReentrant {
    // Sanity check: nonzero amounts
    require(amount > 0, ""addLiquidity: AMOUNT_IS_ZERO"");

    // Validate correct amounts are transferred
    if (LibAsset.isEther(assetId)) {
      require(msg.value == amount, ""addLiquidity: VALUE_MISMATCH"");
    } else {
      require(msg.value == 0, ""addLiquidity: ETH_WITH_ERC_TRANSFER"");
      require(LibERC20.transferFrom(assetId, router, address(this), amount), ""addLiquidity: ERC20_TRANSFER_FAILED"");
    }

    // Update the router balances
    routerBalances[router][assetId] += amount;

    // Emit event
    emit LiquidityAdded(router, assetId, amount, msg.sender);
  }

  /// @notice This is used by any router to decrease their available
  ///         liquidity for a given asset.
  /// @param amount The amount of liquidity to remove for the router
  /// @param assetId The address (or `address(0)` if native asset) of the
  ///                asset you're removing liquidity for
  /// @param recipient The address that will receive the liquidity being removed
  function removeLiquidity(
    uint256 amount,
    address assetId,
    address payable recipient
  ) external override nonReentrant {
    // Sanity check: nonzero amounts
    require(amount > 0, ""removeLiquidity: AMOUNT_IS_ZERO"");

    // Sanity check: amount can be deducted for the router
    require(routerBalances[msg.sender][assetId] >= amount, ""removeLiquidity: INSUFFICIENT_FUNDS"");

    // Update router balances
    routerBalances[msg.sender][assetId] -= amount;

    // Transfer from contract to specified recipient
    require(LibAsset.transferAsset(assetId, recipient, amount), ""removeLiquidity: TRANSFER_FAILED"");

    // Emit event
    emit LiquidityRemoved(msg.sender, assetId, amount, recipient);
  }

  /// @notice This function creates a crosschain transaction. When called on
  ///         the sending chain, the user is expected to lock up funds. When
  ///         called on the receiving chain, the router deducts the transfer
  ///         amount from the available liquidity. The majority of the
  ///         information about a given transfer does not change between chains,
  ///         with three notable exceptions: `amount`, `expiry`, and 
  ///         `preparedBlock`. The `amount` and `expiry` are decremented
  ///         between sending and receiving chains to provide an incentive for 
  ///         the router to complete the transaction and time for the router to
  ///         fulfill the transaction on the sending chain after the unlocking
  ///         signature is revealed, respectively.
  /// @param invariantData The data for a crosschain transaction that will
  ///                      not change between sending and receiving chains.
  ///                      The hash of this data is used as the key to store 
  ///                      the inforamtion that does change between chains 
  ///                      (amount, expiry,preparedBlock) for verification
  /// @param amount The amount of the transaction on this chain
  /// @param expiry The block.timestamp when the transaction will no longer be
  ///               fulfillable and is freely cancellable on this chain
  /// @param encryptedCallData The calldata to be executed when the tx is
  ///                          fulfilled. Used in the function to allow the user
  ///                          to reconstruct the tx from events. Hash is stored
  ///                          onchain to prevent shenanigans.
  /// @param encodedBid The encoded bid that was accepted by the user for this
  ///                   crosschain transfer. It is supplied as a param to the
  ///                   function but is only used in event emission
  /// @param bidSignature The signature of the bidder on the encoded bid for
  ///                     this transaction. Only used within the function for
  ///                     event emission. The validity of the bid and
  ///                     bidSignature are enforced offchain
  function prepare(
    InvariantTransactionData calldata invariantData,
    uint256 amount,
    uint256 expiry,
    bytes calldata encryptedCallData,
    bytes calldata encodedBid,
    bytes calldata bidSignature
  ) external payable override nonReentrant returns (TransactionData memory) {
    // Sanity check: user is sensible
    require(invariantData.user != address(0), ""prepare: USER_EMPTY"");

    // Sanity check: router is sensible
    require(invariantData.router != address(0), ""prepare: ROUTER_EMPTY"");

    // Sanity check: valid fallback
    require(invariantData.receivingAddress != address(0), ""prepare: RECEIVING_ADDRESS_EMPTY"");

    // Make sure the chains are different
    require(invariantData.sendingChainId != invariantData.receivingChainId, ""prepare: SAME_CHAINIDS"");

    // Make sure the chains are relevant
    require(invariantData.sendingChainId == chainId || invariantData.receivingChainId == chainId, ""prepare: INVALID_CHAINIDS"");

    // Make sure the expiry is greater than min
    require((expiry - block.timestamp) >= MIN_TIMEOUT, ""prepare: TIMEOUT_TOO_LOW"");

    // Make sure the hash is not a duplicate
    bytes32 digest = keccak256(abi.encode(invariantData));
    require(variantTransactionData[digest] == bytes32(0), ""prepare: DIGEST_EXISTS"");

    // NOTE: the `encodedBid` and `bidSignature` are simply passed through
    //       to the contract emitted event to ensure the availability of
    //       this information. Their validity is asserted offchain, and
    //       is out of scope of this contract. They are used as inputs so
    //       in the event of a router or user crash, they may recover the
    //       correct bid information without requiring an offchain store.

    // Store the transaction variants
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: amount,
      expiry: expiry,
      preparedBlockNumber: block.number
    })));

    // Store active blocks
    activeTransactionBlocks[invariantData.user].push(block.number);

    // First determine if this is sender side or receiver side
    if (invariantData.sendingChainId == chainId) {
      // Sanity check: amount is sensible
      // Only check on sending chain to enforce router fees. Transactions could
      // be 0-valued on receiving chain if it is just a value-less call to some
      // `IFulfillHelper`
      require(amount > 0, ""prepare: AMOUNT_IS_ZERO"");

      // This is sender side prepare. The user is beginning the process of 
      // submitting an onchain tx after accepting some bid. They should
      // lock their funds in the contract for the router to claim after
      // they have revealed their signature on the receiving chain via
      // submitting a corresponding `fulfill` tx

      // Validate correct amounts on msg and transfer from user to
      // contract
      if (LibAsset.isEther(invariantData.sendingAssetId)) {
        require(msg.value == amount, ""prepare: VALUE_MISMATCH"");
      } else {
        require(msg.value == 0, ""prepare: ETH_WITH_ERC_TRANSFER"");
        require(
          LibERC20.transferFrom(invariantData.sendingAssetId, msg.sender, address(this), amount),
          ""prepare: ERC20_TRANSFER_FAILED""
        );
      }
    } else {
      // This is receiver side prepare. The router has proposed a bid on the
      // transfer which the user has accepted. They can now lock up their
      // own liquidity on th receiving chain, which the user can unlock by
      // calling `fulfill`. When creating the `amount` and `expiry` on the
      // receiving chain, the router should have decremented both. The
      // expiry should be decremented to ensure the router has time to
      // complete the sender-side transaction after the user completes the
      // receiver-side transactoin. The amount should be decremented to act as
      // a fee to incentivize the router to complete the transaction properly.

      // Check that the caller is the router
      require(msg.sender == invariantData.router, ""prepare: ROUTER_MISMATCH"");

      // Check that the router isnt accidentally locking funds in the contract
      require(msg.value == 0, ""prepare: ETH_WITH_ROUTER_PREPARE"");

      // Check that router has liquidity
      require(
        routerBalances[invariantData.router][invariantData.receivingAssetId] >= amount,
        ""prepare: INSUFFICIENT_LIQUIDITY""
      );

      // Decrement the router liquidity
      routerBalances[invariantData.router][invariantData.receivingAssetId] -= amount;
    }

    // Emit event
    TransactionData memory txData = TransactionData({
      user: invariantData.user,
      router: invariantData.router,
      sendingAssetId: invariantData.sendingAssetId,
      receivingAssetId: invariantData.receivingAssetId,
      sendingChainFallback: invariantData.sendingChainFallback,
      callTo: invariantData.callTo,
      receivingAddress: invariantData.receivingAddress,
      callDataHash: invariantData.callDataHash,
      transactionId: invariantData.transactionId,
      sendingChainId: invariantData.sendingChainId,
      receivingChainId: invariantData.receivingChainId,
      amount: amount,
      expiry: expiry,
      preparedBlockNumber: block.number
    });
    emit TransactionPrepared(txData.user, txData.router, txData.transactionId, txData, msg.sender, encryptedCallData, encodedBid, bidSignature);
    return txData;
  }



  /// @notice This function completes a crosschain transaction. When called on
  ///         the receiving chain, the user reveals their signature on the
  ///         invariant parts of the transaction data and is sent the 
  ///         appropriate amount. The router then uses this signature to
  ///         unlock the corresponding funds on the receiving chain, which are
  ///         then added back to their available liquidity. The user includes a
  ///         relayer fee since it is not assumed they will have gas on the
  ///         receiving chain. This function *must* be called before the
  ///         transaction expiry has elapsed.
  /// @param txData All of the data (invariant and variant) for a crosschain
  ///               transaction. The variant data provided is checked against
  ///               what was stored when the `prepare` function was called.
  /// @param relayerFee The fee that should go to the relayer when they are
  ///                   calling the function on the receiving chain for the user
  /// @param signature The users signature on the invariant data + fee that
  ///                  can be used by the router to unlock the transaction on 
  ///                  the sending chain
  function fulfill(
    TransactionData calldata txData,
    uint256 relayerFee,
    bytes calldata signature, // signature on fee + digest
    bytes calldata callData
  ) external override nonReentrant returns (TransactionData memory) {
    // Get the hash of the invariant tx data. This hash is the same
    // between sending and receiving chains. The variant data is stored
    // in the contract when `prepare` is called within the mapping.
    bytes32 digest = hashInvariantTransactionData(txData);

    // Make sure that the variant data matches what was stored
    require(variantTransactionData[digest] == hashVariantTransactionData(txData), ""fulfill: INVALID_VARIANT_DATA"");

    // Make sure the expiry has not elapsed
    require(txData.expiry > block.timestamp, ""fulfill: EXPIRED"");

    // Make sure the transaction wasn't already completed
    require(txData.preparedBlockNumber > 0, ""fulfill: ALREADY_COMPLETED"");

    // Validate the user has signed
    require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, ""fulfill: INVALID_SIGNATURE"");

    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute
    // 0-value crosschain tx, so only providing the fee amount
    require(relayerFee <= txData.amount, ""fulfill: INVALID_RELAYER_FEE"");

    // Check provided callData matches stored hash
    require(keccak256(callData) == txData.callDataHash, ""fulfill: INVALID_CALL_DATA"");

    // To prevent `fulfill` / `cancel` from being called multiple times, the
    // preparedBlockNumber is set to 0 before being hashed. The value of the
    // mapping is explicitly *not* zeroed out so users who come online without
    // a store can tell the difference between a transaction that has not been
    // prepared, and a transaction that was already completed on the receiver
    // chain.
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: 0
    })));

    // Remove the transaction prepared block from the active blocks
    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);

    if (txData.sendingChainId == chainId) {
      // The router is completing the transaction, they should get the
      // amount that the user deposited credited to their liquidity
      // reserves.

      // Make sure that the user is not accidentally fulfilling the transaction
      // on the sending chain
      require(msg.sender == txData.router, ""fulfill: ROUTER_MISMATCH"");

      // Complete tx to router for original sending amount
      routerBalances[txData.router][txData.sendingAssetId] += txData.amount;
    } else {
      // The user is completing the transaction, they should get the
      // amount that the router deposited less fees for relayer.

      // Get the amount to send
      uint256 toSend = txData.amount - relayerFee;

      // Send the relayer the fee
      if (relayerFee > 0) {
        require(
          LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),
          ""fulfill: FEE_TRANSFER_FAILED""
        );
      }

      // Handle receiver chain external calls if needed
      if (txData.callTo == address(0)) {
        // No external calls, send directly to receiving address
        require(
          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
          ""fulfill: TRANSFER_FAILED""
        );
      } else {
        // Handle external calls with a fallback to the receiving
        // address in case the call fails so the funds dont remain
        // locked.

        // First, approve the funds to the helper if needed
        if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {
          require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), ""fulfill: APPROVAL_FAILED"");
        }

        // Next, call `addFunds` on the helper. Helpers should internally
        // track funds to make sure no one user is able to take all funds
        // for tx
        if (toSend > 0) {
          try
            IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(
              txData.user,
              txData.transactionId,
              txData.receivingAssetId,
              toSend
            )
          {} catch {
            // Regardless of error within the callData execution, send funds
            // to the predetermined fallback address
            require(
              LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
              ""fulfill: TRANSFER_FAILED""
            );
          }
        }

        // Call `execute` on the helper
        try
          IFulfillHelper(txData.callTo).execute(
            txData.user,
            txData.transactionId,
            txData.receivingAssetId,
            toSend,
            callData
          )
        {} catch {
          // Regardless of error within the callData execution, send funds
          // to the predetermined fallback address
          require(
            LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
            ""fulfill: TRANSFER_FAILED""
          );
        }
      }
    }

    // Emit event
    emit TransactionFulfilled(txData.user, txData.router, txData.transactionId, txData, relayerFee, signature, callData, msg.sender);

    return txData;
  }

  /// @notice Any crosschain transaction can be cancelled after it has been
  ///         created to prevent indefinite lock up of funds. After the
  ///         transaction has expired, anyone can cancel it. Before the
  ///         expiry, only the recipient of the funds on the given chain is
  ///         able to cancel. On the sending chain, this means only the router
  ///         is able to cancel before the expiry, while only the user can
  ///         prematurely cancel on the receiving chain.
  /// @param txData All of the data (invariant and variant) for a crosschain
  ///               transaction. The variant data provided is checked against
  ///               what was stored when the `prepare` function was called.
  /// @param relayerFee The fee that should go to the relayer when they are
  ///                   calling the function for the user
  /// @param signature The user's signature that allows a transaction to be
  ///                  cancelled on the receiving chain.
  function cancel(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)
    external
    override
    nonReentrant
    returns (TransactionData memory)
  {
    // Make sure params match against stored data
    // Also checks that there is an active transfer here
    // Also checks that sender or receiver chainID is this chainId (bc we checked it previously)

    // Get the hash of the invariant tx data. This hash is the same
    // between sending and receiving chains. The variant data is stored
    // in the contract when `prepare` is called within the mapping.
    bytes32 digest = hashInvariantTransactionData(txData);

    // Verify the variant data is correct
    require(variantTransactionData[digest] == hashVariantTransactionData(txData), ""cancel: INVALID_VARIANT_DATA"");

    // Make sure the transaction wasn't already completed
    require(txData.preparedBlockNumber > 0, ""cancel: ALREADY_COMPLETED"");

    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute
    // 0-value crosschain tx, so only providing the fee amount
    require(relayerFee <= txData.amount, ""cancel: INVALID_RELAYER_FEE"");

    // To prevent `fulfill` / `cancel` from being called multiple times, the
    // preparedBlockNumber is set to 0 before being hashed. The value of the
    // mapping is explicitly *not* zeroed out so users who come online without
    // a store can tell the difference between a transaction that has not been
    // prepared, and a transaction that was already completed on the receiver
    // chain.
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: 0
    })));

    // Remove active blocks
    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);

    // Return the appropriate locked funds
    if (txData.sendingChainId == chainId) {
      // Sender side, funds must be returned to the user
      if (txData.expiry >= block.timestamp) {
        // Timeout has not expired and tx may only be cancelled by router
        // NOTE: no need to validate the signature here, since you are requiring
        // the router must be the sender when the cancellation is during the
        // fulfill-able window
        require(msg.sender == txData.router, ""cancel: ROUTER_MUST_CANCEL"");

        // Return totality of locked funds to provided fallbacl
        require(
          LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), txData.amount),
          ""cancel: TRANSFER_FAILED""
        );
      } else {
        // When the user could be unlocking funds through a relayer, validate
        // their signature and payout the relayer.
        if (relayerFee > 0) {
          require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, ""cancel: INVALID_SIGNATURE"");

          require(
            LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),
            ""cancel: FEE_TRANSFER_FAILED""
          );
        }

        // Get the amount to refund the user
        uint256 toRefund = txData.amount - relayerFee;

        // Return locked funds to sending chain fallback
        if (toRefund > 0) {
          require(
            LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), toRefund),
            ""cancel: TRANSFER_FAILED""
          );
        }
      }

    } else {
      // Receiver side, router liquidity is returned
      if (txData.expiry >= block.timestamp) {
        // Timeout has not expired and tx may only be cancelled by user
        // Validate signature
        require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, ""cancel: INVALID_SIGNATURE"");

        // NOTE: there is no incentive here for relayers to submit this on
        // behalf of the user (i.e. fee not respected) because the user has not
        // locked funds on this contract.
      }

      // Return liquidity to router
      routerBalances[txData.router][txData.receivingAssetId] += txData.amount;
    }

    // Emit event
    emit TransactionCancelled(txData.user, txData.router, txData.transactionId, txData, relayerFee, msg.sender);

    // Return
    return txData;
  }

  // helper method to get full array of active blocks
  function getActiveTransactionBlocks(address user) external override view returns (uint256[] memory) {
    return activeTransactionBlocks[user];
  }

  //////////////////////////
  /// Private functions ///
  //////////////////////////

  /// @notice Removes a given block from the tracked activeTransactionBlocks
  ///         array for the user. Called when transactions are completed.
  /// @param user User who has completed a transaction
  /// @param preparedBlock The TransactionData.preparedBlockNumber to remove
  function removeUserActiveBlocks(address user, uint256 preparedBlock) internal {
    // Remove active blocks
    uint256 newLength = activeTransactionBlocks[user].length - 1;
    uint256[] memory updated = new uint256[](newLength);
    bool removed = false;
    uint256 updatedIdx = 0;
    for (uint256 i; i < newLength + 1; i++) {
      // Handle case where there could be more than one tx added in a block
      // And only one should be removed
      if (!removed && activeTransactionBlocks[user][i] == preparedBlock) {
        removed = true;
        continue;
      }
      updated[updatedIdx] = activeTransactionBlocks[user][i];
      updatedIdx++;
    }
    activeTransactionBlocks[user] = updated;
  }

  /// @notice Recovers the signer from the signature provided to the `fulfill`
  ///         function. Returns the address recovered
  /// @param txData TransactionData of the transaction being fulfilled
  /// @param relayerFee The fee paid to the relayer for submitting the fulfill
  ///                   tx on behalf of the user.
  /// @param signature The signature you are recovering the signer from
  function recoverFulfillSignature(
    TransactionData calldata txData,
    uint256 relayerFee,
    bytes calldata signature
  ) internal pure returns (address) {
    // Create the signed payload
    SignedFulfillData memory payload = SignedFulfillData({transactionId: txData.transactionId, relayerFee: relayerFee});

    // Recover
    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);
  }

  /// @notice Recovers the signer from the signature provided to the `cancel`
  ///         function. Returns the address recovered
  /// @param txData TransactionData of the transaction being fulfilled
  /// @param relayerFee The fee paid to the relayer for submitting the cancel
  ///                   tx on behalf of the user.
  /// @param signature The signature you are recovering the signer from
  function recoverCancelSignature(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)
    internal
    pure
    returns (address)
  {
    // Create the signed payload
    SignedCancelData memory payload = SignedCancelData({transactionId: txData.transactionId, cancel: ""cancel"", relayerFee: relayerFee});

    // Recover
    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);
  }

  /// @notice Returns the hash of only the invariant portions of a given
  ///         crosschain transaction
  /// @param txData TransactionData to hash
  function hashInvariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {
    InvariantTransactionData memory invariant = InvariantTransactionData({
      user: txData.user,
      router: txData.router,
      sendingAssetId: txData.sendingAssetId,
      receivingAssetId: txData.receivingAssetId,
      sendingChainFallback: txData.sendingChainFallback,
      callTo: txData.callTo,
      receivingAddress: txData.receivingAddress,
      sendingChainId: txData.sendingChainId,
      receivingChainId: txData.receivingChainId,
      callDataHash: txData.callDataHash,
      transactionId: txData.transactionId
    });
    return keccak256(abi.encode(invariant));
  }

  /// @notice Returns the hash of only the variant portions of a given
  ///         crosschain transaction
  /// @param txData TransactionData to hash
  function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {
    return keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: txData.preparedBlockNumber
    })));
  }
}",6657,653,"H-01: Anyone can arbitrarily add router liquidity. L88-L98.  H-03: Router liquidity on receiving chain can be double-dipped by the user  L395-L409 and L413-L428. H-04: Expired transfers will lock user funds on the sending chain.  L514.",3
23_CompoundToNotionalV2.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/compound/CTokenInterface.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract CompoundToNotionalV2 {
    NotionalProxy public immutable NotionalV2;
    address public owner;

    constructor(NotionalProxy notionalV2_) {
        NotionalV2 = notionalV2_;
        owner = msg.sender;
    }

    function enableToken(address token, address spender) external {
        require(msg.sender == owner, ""Unauthorized"");
        CTokenInterface(token).approve(spender, type(uint256).max);
    }

    function migrateBorrowFromCompound(
        address cTokenBorrow,
        uint256 cTokenRepayAmount,
        uint16[] memory notionalV2CollateralIds,
        uint256[] memory notionalV2CollateralAmounts,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        // borrow on notional via special flash loan facility
        //  - borrow repayment amount
        //  - withdraw to wallet, redeem to underlying
        // receive callback (tokens transferred to borrowing account)
        //   -> inside callback
        //   -> repayBorrowBehalf(account, repayAmount)
        //   -> deposit cToken to notional (account needs to have set approvals)
        //   -> exit callback
        // inside original borrow, check FC
        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);
        if (cTokenRepayAmount == 0) {
            // Set the entire borrow balance if it is not set
            cTokenRepayAmount = borrowBalance;
        } else {
            // Check that the cToken repayment amount is not more than required
            require(cTokenRepayAmount <= borrowBalance, ""Invalid repayment amount"");
        }

        bytes memory encodedData = abi.encode(
            cTokenBorrow,
            cTokenRepayAmount,
            notionalV2CollateralIds,
            notionalV2CollateralAmounts
        );
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");

        (
            address cTokenBorrow,
            uint256 cTokenRepayAmount,
            uint16[] memory notionalV2CollateralIds,
            uint256[] memory notionalV2CollateralAmounts
        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));

        // Transfer in the underlying amount that was borrowed
        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();
        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);
        require(success, ""Transfer of repayment failed"");

        // Use the amount transferred to repay the borrow
        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);
        require(code == 0, ""Repay borrow behalf failed"");

        for (uint256 i; i < notionalV2CollateralIds.length; i++) {
            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);
            // Transfer the collateral to this contract so we can deposit it
            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);
            require(success, ""cToken transfer failed"");

            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here
            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);
        }

        // When this exits a free collateral check will be triggered
    }

    receive() external payable {
        // This contract cannot migrate ETH loans because there is no way
        // to do transferFrom on ETH
        revert(""Cannot transfer ETH"");
    }
}",924,99,"H-03: CompoundToNotionalV2.notionalCallback ERC20 return values not checked H-04: Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed M-04: CompoundToNotionalV2.enableToken ERC20 missing return value check",3
8_NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.8;

import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IPrevNftxContract.sol"";
import ""./interface/IRewardDistributionToken.sol"";
import ""./token/ERC20BurnableUpgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

import ""hardhat/console.sol"";

contract NFTXVaultUpgradeable is
    PausableUpgradeable,
    ERC20BurnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721HolderUpgradeable,
    ERC1155HolderUpgradeable
{
    using SafeMathUpgradeable for uint256;
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public vaultId;
    address public manager;
    address public assetAddress;
    INFTXVaultFactory public vaultFactory;
    INFTXEligibility public eligibilityStorage;

    uint256 randNonce;
    uint256 public mintFee;
    uint256 public redeemFee;
    uint256 public directRedeemFee;
    uint256 public swapFee;

    // Purposely putting these on a new slot to make sure they're together.
    bool public is1155;
    bool public allowAllItems;
    bool public enableMint;
    bool public enableRedeem;
    bool public enableDirectRedeem;
    bool public enableSwap;
    bool[20] _bool_gap;

    string public description;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    event VaultInit(
        uint256 indexed vaultId,
        address assetAddress,
        bool is1155,
        bool allowAllItems
    );

    event ManagerSet(address manager);
    event EligibilityDeployed(address eligibilityAddr);

    event EnableMintUpdated(bool enabled);
    event EnableRedeemUpdated(bool enabled);
    event EnableDirectRedeemUpdated(bool enabled);
    event EnableSwapUpdated(bool enabled);

    event MintFeeUpdated(uint256 mintFee);
    event RedeemFeeUpdated(uint256 redeemFee);
    event DirectRedeemFeeUpdated(uint256 directRedeemFee);
    event SwapFeeUpdated(uint256 swapFee);

    event Minted(uint256[] nftIds, uint256[] amounts, address sender);
    event Redeemed(uint256[] nftIds, address sender);
    event Swapped(
        uint256[] nftIds,
        uint256[] amounts,
        uint256[] specificIds,
        address sender
    );

    constructor() public {
        __Pausable_init();
        __ERC20_init("""", """");
        __ERC20Burnable_init_unchained();
        __ERC20FlashMint_init();
    }

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public initializer {
        __Pausable_init();
        __ERC20_init(_name, _symbol);
        __ERC20Burnable_init_unchained();
        __ERC20FlashMint_init();
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
    }

    function finalizeFund() external virtual {
        setManager(address(0));
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRedeem,
        bool _enableDirectRedeem,
        bool _enableSwap
    ) external virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRedeem = _enableRedeem;
        enableDirectRedeem = _enableDirectRedeem;
        enableSwap = _enableSwap;

        emit EnableMintUpdated(enableMint);
        emit EnableRedeemUpdated(enableRedeem);
        emit EnableDirectRedeemUpdated(enableDirectRedeem);
        emit EnableSwapUpdated(enableSwap);
    }

    // Should we do defaults?
    function setFees(
        uint256 _mintFee,
        uint256 _redeemFee,
        uint256 _directRedeemFee,
        uint256 _swapFee
    ) external virtual {
        onlyPrivileged();
        mintFee = _mintFee;
        redeemFee = _redeemFee;
        directRedeemFee = _directRedeemFee;
        swapFee = _swapFee;

        emit MintFeeUpdated(_mintFee);
        emit RedeemFeeUpdated(_redeemFee);
        emit DirectRedeemFeeUpdated(_directRedeemFee);
        emit SwapFeeUpdated(_swapFee);
    }

    // This function alls for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external virtual returns (address) {
        onlyPrivileged();
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        setEligibilityStorage(_eligibility);
        return _eligibility;
    }

    // This function allows for the manager to set their own arbitrary eligibility contract.
    // Once eligiblity is set, it cannot be unset or changed.
    function setEligibilityStorage(address _newEligibility) public virtual {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        eligibilityStorage = INFTXEligibility(_newEligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(address(_newEligibility));
    }

    // The manager has control over options like fees and features
    function setManager(address _manager) public virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        uint256 count = receiveNFTs(tokenIds, amounts);

        uint256 fee = mintFee.mul(count);
        _mint(to, base.mul(count).sub(fee));
        _distributeFees(fee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(enableRedeem, ""Redeeming not enabled"");
        require(
            specificIds.length == 0 || enableDirectRedeem,
            ""Direct redeem not enabled""
        );
        uint256 fee = directRedeemFee.mul(specificIds.length).add(
            redeemFee.mul(amount.sub(specificIds.length))
        );
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burnFrom(msg.sender, base.mul(amount).add(fee));
        _distributeFees(fee);

        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        afterRedeemHook(redeemedIds);

        emit Redeemed(redeemedIds, to);
        return redeemedIds;
    }

    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external virtual nonReentrant returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public virtual returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        require(enableSwap, ""Swapping not enabled"");
        require(
            specificIds.length == 0 || enableDirectRedeem,
            ""Direct redeem not enabled""
        );
        uint256 count = receiveNFTs(tokenIds, amounts);
        uint256 fee = directRedeemFee.mul(specificIds.length).add(
            swapFee.mul(count.sub(specificIds.length))
        );
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burnFrom(msg.sender, fee);
        _distributeFees(fee);
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);
        emit Swapped(tokenIds, amounts, specificIds, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public virtual override returns (bool) {
        onlyOwnerIfPaused(4);
        super.flashLoan(receiver, token, amount, data);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        returns (bool)
    {
        // add allow all check here
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] = quantity1155[tokenId].add(amount);
                count = count.add(amount);
            }
            return count;
        } else {
            IERC721Upgradeable erc721 = IERC721Upgradeable(assetAddress);
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                erc721.safeTransferFrom(msg.sender, address(this), tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);

        for (uint256 i = 0; i < amount; i++) {
            uint256 tokenId = i < specificIds.length
                ? specificIds[i]
                : getRandomTokenIdFromFund();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );

                quantity1155[tokenId] = quantity1155[tokenId].sub(1);
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }
            } else {
                IERC721Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId
                );
                holdings.remove(tokenId);
            }
        }
        return redeemedIds;
    }

    function _distributeFees(uint256 amount) internal virtual {
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeReceiver = vaultFactory.feeReceiver();
            _mint(feeReceiver, amount);
            INFTXFeeDistributor(feeReceiver).distribute(vaultId);
        }
    }

    function getRandomTokenIdFromFund() internal virtual returns (uint256) {
        uint256 randomIndex = getPseudoRand(holdings.length());
        return holdings.at(randomIndex);
    }

    function getPseudoRand(uint256 modulus) internal virtual returns (uint256) {
        randNonce += 1;
        return
            uint256(
                keccak256(
                    abi.encodePacked(blockhash(block.number - 1), randNonce)
                )
            ) %
            modulus;
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    // TODO: recount this.
    uint256[25] ___gap;
}",3228,440,"H-03: getRandomTokenIdFromFund yields wrong probabilities for ERC1155 NFTXVaultUpgradeable.getRandomTokenIdFromFund does not work with ERC1155 as it does not take the deposited quantity1155 into account.",1
83_ConvexStakingWrapper.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""./external/ConvexInterfaces.sol"";
import ""./interfaces/IConcurRewardClaim.sol"";
import ""./MasterChef.sol"";

contract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    struct RewardType {
        address token;
        address pool;
        uint128 integral;
        uint128 remaining;
    }

    struct Reward {
        uint128 integral;
    }

    //constants/immutables
    address public constant convexBooster =
        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv =
        address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx =
        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);

    uint256 public constant CRV_INDEX = 0;
    uint256 public constant CVX_INDEX = 1;
    uint256 public constant VOTECYCLE_START = 1645002000; 
    //Feb 16 2022 09:00:00 GMT+0000
    MasterChef public immutable masterChef;

    //convex rewards
    mapping(uint256 => address) public convexPool;
    mapping(uint256 => RewardType[]) public rewards;
    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))
        public userReward;
    mapping(uint256 => mapping(address => uint256)) public registeredRewards;

    //management
    address public treasury;
    IConcurRewardClaim public claimContract;

    struct Deposit {
        uint64 epoch;
        uint192 amount;
    }

    struct WithdrawRequest {
        uint64 epoch;
        uint192 amount;
    }

    mapping(address => uint256) public pids;
    mapping(uint256 => mapping(address => Deposit)) public deposits;
    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;

    event Deposited(address indexed _user, uint256 _amount);
    event Withdrawn(address indexed _user, uint256 _amount);

    constructor(address _treasury, MasterChef _masterChef) {
        treasury = _treasury;
        masterChef = _masterChef;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function changeTreasury(address _treasury) external onlyOwner {
        treasury = _treasury;
    }

    function setRewardPool(address _claimContract) external onlyOwner {
        claimContract = IConcurRewardClaim(_claimContract);
    }

    /// @notice function to bootstrap the reward pool and extra rewards of convex booster
    /// @dev should be able to be called more than once
    /// @param _pid pid of the curve lp. same as convex booster pid
    function addRewards(uint256 _pid) public {
        address mainPool = IRewardStaking(convexBooster)
            .poolInfo(_pid)
            .crvRewards;
        if (rewards[_pid].length == 0) {
            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;
            convexPool[_pid] = mainPool;
            rewards[_pid].push(
                RewardType({
                    token: crv,
                    pool: mainPool,
                    integral: 0,
                    remaining: 0
                })
            );
            rewards[_pid].push(
                RewardType({
                    token: cvx,
                    pool: address(0),
                    integral: 0,
                    remaining: 0
                })
            );
            registeredRewards[_pid][crv] = CRV_INDEX + 1; 
            //mark registered at index+1
            registeredRewards[_pid][cvx] = CVX_INDEX + 1; 
            //mark registered at index+1
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        for (uint256 i = 0; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            address extraToken = IRewardStaking(extraPool).rewardToken();
            if (extraToken == cvx) {
                //no-op for cvx, crv rewards
                rewards[_pid][CVX_INDEX].pool = extraPool;
            } else if (registeredRewards[_pid][extraToken] == 0) {
                //add new token to list
                rewards[_pid].push(
                    RewardType({
                        token: IRewardStaking(extraPool).rewardToken(),
                        pool: extraPool,
                        integral: 0,
                        remaining: 0
                    })
                );
                registeredRewards[_pid][extraToken] = rewards[_pid].length; 
                //mark registered at index+1
            }
        }
    }

    function rewardLength(uint256 _pid) external view returns (uint256) {
        return rewards[_pid].length;
    }

    function _getDepositedBalance(uint256 _pid, address _account)
        internal
        view
        virtual
        returns (uint256)
    {
        return deposits[_pid][_account].amount;
    }

    function _getTotalSupply(uint256 _pid)
        internal
        view
        virtual
        returns (uint256)
    {
        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));
    }

    function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        // send 20 % of cvx / crv reward to treasury
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        //update user integrals
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }

    function _checkpoint(uint256 _pid, address _account) internal {
        //if shutdown, no longer checkpoint in case there are problems
        if (paused()) return;

        uint256 supply = _getTotalSupply(_pid);
        uint256 depositedBalance = _getDepositedBalance(_pid, _account);

        IRewardStaking(convexPool[_pid]).getReward(address(this), true);

        uint256 rewardCount = rewards[_pid].length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);
        }
    }

    /// @notice deposit curve lp token
    /// @dev should approve curve lp token to this address before calling this function
    /// @param _pid pid to deposit, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function deposit(uint256 _pid, uint256 _amount)
        external
        whenNotPaused
        nonReentrant
    {
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].epoch = currentEpoch();
        deposits[_pid][msg.sender].amount += uint192(_amount);
        if (_amount > 0) {
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );

            lpToken.safeTransferFrom(msg.sender, address(this), _amount);
            lpToken.safeApprove(convexBooster, _amount);
            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);
            lpToken.safeApprove(convexBooster, 0);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.deposit(msg.sender, pid, _amount);
        }

        emit Deposited(msg.sender, _amount);
    }

    /// @notice withdraw curve lp token
    /// @dev should request withdraw before calling this function
    /// @param _pid pid to withdraw, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {
        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];
        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), ""wait"");
        require(request.amount >= _amount, ""too much"");
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].amount -= uint192(_amount);
        if (_amount > 0) {
            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );
            lpToken.safeTransfer(msg.sender, _amount);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.withdraw(msg.sender, pid, _amount);
        }
        delete withdrawRequest[_pid][msg.sender];
        //events
        emit Withdrawn(msg.sender, _amount);
    }

    /// @notice epoch for voting cycle
    /// @return returns the epoch in uint64 type
    function currentEpoch() public view returns(uint64) {
        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;
    }

    /// @notice request withdraw to be eligible for withdrawal after currentEpoch
    /// @dev prior withdrawal request will be overwritten
    /// @param _pid pid to withdraw
    /// @param _amount amount to request withdrawal
    function requestWithdraw(uint256 _pid, uint256 _amount) external {
        require(_amount <= uint256(deposits[_pid][msg.sender].amount), ""too much"");
        withdrawRequest[_pid][msg.sender] = WithdrawRequest({
            epoch : currentEpoch(),
            amount : uint192(_amount)
        });
    }
}",2485,298,"H-04: ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver. L246 H-06: ConvexStakingWrapper.sol#_calcRewardIntegral Wrong implementation can disrupt rewards calculation and distribution. L175-L204 H-09: deposit in ConvexStakingWrapper will most certainly revert.  L94-L99 H-10: ConvexStakingWrapper.exitShelter() Will Lock LP Tokens, Preventing Users From Withdrawing  L121-L130 H-11: ConvexStakingWrapper._calcRewardIntegral() Can Be Manipulated To Steal Tokens From Other Pools L216-259",5
18_LendingPair.sol,"// SPDX-License-Identifier: UNLICENSED

// Copyright (c) 2021 0xdev0 - All rights reserved
// https://twitter.com/0xdev0

pragma solidity ^0.8.0;

import './interfaces/IERC20.sol';
import './interfaces/ILPTokenMaster.sol';
import './interfaces/ILendingPair.sol';
import './interfaces/IController.sol';
import './interfaces/IRewardDistribution.sol';
import './interfaces/IInterestRateModel.sol';

import './external/Math.sol';
import './external/Ownable.sol';
import './external/Address.sol';
import './external/Clones.sol';
import './external/ERC20.sol';

import './TransferHelper.sol';

contract LendingPair is TransferHelper {

  // Prevents division by zero and other undesirable behaviour
  uint public constant MIN_RESERVE = 1000;

  using Address for address;
  using Clones for address;

  mapping (address => mapping (address => uint)) public debtOf;
  mapping (address => mapping (address => uint)) public accountInterestSnapshot;
  mapping (address => uint) public cumulativeInterestRate; 
  mapping (address => uint) public totalDebt;
  mapping (address => IERC20) public lpToken;

  IController public controller;
  address public tokenA;
  address public tokenB;
  uint public lastBlockAccrued;

  event Liquidation(
    address indexed account,
    address indexed repayToken,
    address indexed supplyToken,
    uint repayAmount,
    uint supplyAmount
  );

  event Deposit(address indexed account, address indexed token, uint amount);
  event Withdraw(address indexed token, uint amount);
  event Borrow(address indexed token, uint amount);
  event Repay(address indexed account, address indexed token, uint amount);

  receive() external payable {}

  function initialize(
    address _lpTokenMaster,
    address _controller,
    IERC20 _tokenA,
    IERC20 _tokenB
  ) external {
    require(address(tokenA) == address(0), ""LendingPair: already initialized"");
    require(address(_tokenA) != address(0) && address(_tokenB) != address(0), ""LendingPair: cannot be ZERO address"");

    controller = IController(_controller);
    tokenA = address(_tokenA);
    tokenB = address(_tokenB);
    lastBlockAccrued = block.number;

    lpToken[tokenA] = _createLpToken(_lpTokenMaster);
    lpToken[tokenB] = _createLpToken(_lpTokenMaster);
  }

  function depositRepay(address _account, address _token, uint _amount) external {
    _validateToken(_token);
    accrueAccount(_account);

    _depositRepay(_account, _token, _amount);
    _safeTransferFrom(_token, msg.sender, _amount);
  }

  function depositRepayETH(address _account) external payable {
    accrueAccount(_account);

    _depositRepay(_account, address(WETH), msg.value);
    _depositWeth();
  }

  function deposit(address _account, address _token, uint _amount) external {
    _validateToken(_token);
    accrueAccount(_account);

    _deposit(_account, _token, _amount);
    _safeTransferFrom(_token, msg.sender, _amount);
  }

  function withdrawBorrow(address _token, uint _amount) external {
    _validateToken(_token);
    accrueAccount(msg.sender);

    _withdrawBorrow(_token, _amount);
    _safeTransfer(IERC20(_token), msg.sender, _amount);
  }

  function withdrawBorrowETH(uint _amount) external {
    accrueAccount(msg.sender);

    _withdrawBorrow(address(WETH), _amount);
    _wethWithdrawTo(msg.sender, _amount);
    _checkMinReserve(address(WETH));
  }

  function withdraw(address _token, uint _amount) external {
    _validateToken(_token);
    accrueAccount(msg.sender);

    _withdraw(_token, _amount);
    _safeTransfer(IERC20(_token), msg.sender, _amount);
  }

  function withdrawAll(address _token) external {
    _validateToken(_token);
    accrueAccount(msg.sender);

    uint amount = lpToken[address(_token)].balanceOf(msg.sender);
    _withdraw(_token, amount);
    _safeTransfer(IERC20(_token), msg.sender, amount);
  }

  function withdrawAllETH() external {
    accrueAccount(msg.sender);

    uint amount = lpToken[address(WETH)].balanceOf(msg.sender);
    _withdraw(address(WETH), amount);
    _wethWithdrawTo(msg.sender, amount);
  }

  function borrow(address _token, uint _amount) external {
    _validateToken(_token);
    accrueAccount(msg.sender);

    _borrow(_token, _amount);
    _safeTransfer(IERC20(_token), msg.sender, _amount);
  }

  function repayAll(address _account, address _token) external {
    _validateToken(_token);
    accrueAccount(_account);

    uint amount = debtOf[_token][_account];
    _repay(_account, _token, amount);
    _safeTransferFrom(_token, msg.sender, amount);
  }

  function repayAllETH(address _account) external payable {
    accrueAccount(_account);

    uint amount = debtOf[address(WETH)][_account];
    require(msg.value >= amount, ""LendingPair: insufficient ETH deposit"");

    _depositWeth();
    _repay(_account, address(WETH), amount);
    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;

    if (refundAmount > 0) {
      _wethWithdrawTo(msg.sender, refundAmount);
    }
  }

  function repay(address _account, address _token, uint _amount) external {
    _validateToken(_token);
    accrueAccount(_account);

    _repay(_account, _token, _amount);
    _safeTransferFrom(_token, msg.sender, _amount);
  }

  function accrue() public {
    if (lastBlockAccrued < block.number) {
      _accrueInterest(tokenA);
      _accrueInterest(tokenB);
      lastBlockAccrued = block.number;
    }
  }

  function accrueAccount(address _account) public {
    _distributeReward(_account);
    accrue();
    _accrueAccountInterest(_account);

    if (_account != feeRecipient()) {
      _accrueAccountInterest(feeRecipient());
    }
  }

  function accountHealth(address _account) public view returns(uint) {

    if (debtOf[tokenA][_account] == 0 && debtOf[tokenB][_account] == 0) {
      return controller.LIQ_MIN_HEALTH();
    }

    uint totalAccountSupply  = _supplyCredit(_account, tokenA, tokenA)  + _supplyCredit(_account, tokenB, tokenA);
    uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);

    return totalAccountSupply * 1e18 / totalAccountBorrrow;
  }

  // Get borow balance converted to the units of _returnToken
  function borrowBalance(
    address _account,
    address _borrowedToken,
    address _returnToken
  ) external view returns(uint) {

    _validateToken(_borrowedToken);
    _validateToken(_returnToken);

    return _borrowBalance(_account, _borrowedToken, _returnToken);
  }

  function supplyBalance(
    address _account,
    address _suppliedToken,
    address _returnToken
  ) external view returns(uint) {

    _validateToken(_suppliedToken);
    _validateToken(_returnToken);

    return _supplyBalance(_account, _suppliedToken, _returnToken);
  }

  function supplyRatePerBlock(address _token) external view returns(uint) {
    _validateToken(_token);
    return controller.interestRateModel().supplyRatePerBlock(ILendingPair(address(this)), _token);
  }

  function borrowRatePerBlock(address _token) external view returns(uint) {
    _validateToken(_token);
    return _borrowRatePerBlock(_token);
  }

  // Sell collateral to reduce debt and increase accountHealth
  // Set _repayAmount to uint(-1) to repay all debt, inc. pending interest
  function liquidateAccount(
    address _account,
    address _repayToken,
    uint    _repayAmount,
    uint    _minSupplyOutput
  ) external {

    // Input validation and adjustments

    _validateToken(_repayToken);
    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;

    // Check account is underwater after interest

    _accrueAccountInterest(_account);
    _accrueAccountInterest(feeRecipient());
    uint health = accountHealth(_account);
    require(health < controller.LIQ_MIN_HEALTH(), ""LendingPair: account health > LIQ_MIN_HEALTH"");

    // Calculate balance adjustments

    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);

    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);
    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;
    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;
    uint supplyBurn   = supplyDebt + callerFee + systemFee;
    uint supplyOutput = supplyDebt + callerFee;

    require(supplyOutput >= _minSupplyOutput, ""LendingPair: supplyOutput >= _minSupplyOutput"");

    // Adjust balances

    _burnSupply(supplyToken, _account, supplyBurn);
    _mintSupply(supplyToken, feeRecipient(), systemFee);
    _burnDebt(_repayToken, _account, _repayAmount);

    // Settle token transfers

    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);
    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);

    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);
  }

  function pendingSupplyInterest(address _token, address _account) external view returns(uint) {
    _validateToken(_token);
    uint newInterest = _newInterest(lpToken[_token].balanceOf(_account), _token, _account);
    return newInterest * _lpRate(_token) / 100e18;
  }

  function pendingBorrowInterest(address _token, address _account) external view returns(uint) {
    _validateToken(_token);
    return _pendingBorrowInterest(_token, _account);
  }

  function feeRecipient() public view returns(address) {
    return controller.feeRecipient();
  }

  function checkAccountHealth(address _account) public view  {
    uint health = accountHealth(_account);
    require(health >= controller.LIQ_MIN_HEALTH(), ""LendingPair: insufficient accountHealth"");
  }

  function convertTokenValues(
    address _fromToken,
    address _toToken,
    uint    _inputAmount
  ) external view returns(uint) {

    _validateToken(_fromToken);
    _validateToken(_toToken);

    return _convertTokenValues(_fromToken, _toToken, _inputAmount);
  }

  function _depositRepay(address _account, address _token, uint _amount) internal {

    uint debt = debtOf[_token][_account];
    uint repayAmount = debt > _amount ? _amount : debt;

    if (repayAmount > 0) {
      _repay(_account, _token, repayAmount);
    }

    uint depositAmount = _amount - repayAmount;

    if (depositAmount > 0) {
      _deposit(_account, _token, depositAmount);
    }
  }

  function _withdrawBorrow(address _token, uint _amount) internal {

    uint supplyAmount = lpToken[_token].balanceOf(msg.sender);
    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;

    if (withdrawAmount > 0) {
      _withdraw(_token, withdrawAmount);
    }

    uint borrowAmount = _amount - withdrawAmount;

    if (borrowAmount > 0) {
      _borrow(_token, borrowAmount);
    }
  }

  function _distributeReward(address _account) internal {
    IRewardDistribution rewardDistribution = controller.rewardDistribution();

    if (address(rewardDistribution) != address(0)) {
      rewardDistribution.distributeReward(_account, tokenA);
      rewardDistribution.distributeReward(_account, tokenB);
    }
  }

  function _mintSupply(address _token, address _account, uint _amount) internal {
    if (_amount > 0) {
      lpToken[_token].mint(_account, _amount);
    }
  }

  function _burnSupply(address _token, address _account, uint _amount) internal {
    if (_amount > 0) {
      lpToken[_token].burn(_account, _amount);
    }
  }

  function _mintDebt(address _token, address _account, uint _amount) internal {
    debtOf[_token][_account] += _amount;
    totalDebt[_token] += _amount;
  }

  function _burnDebt(address _token, address _account, uint _amount) internal {
    debtOf[_token][_account] -= _amount;
    totalDebt[_token] -= _amount;
  }

  function _accrueAccountInterest(address _account) internal {
    uint lpBalanceA = lpToken[tokenA].balanceOf(_account);
    uint lpBalanceB = lpToken[tokenB].balanceOf(_account);

    _accrueAccountSupply(tokenA, lpBalanceA, _account);
    _accrueAccountSupply(tokenB, lpBalanceB, _account);
    _accrueAccountDebt(tokenA, _account);
    _accrueAccountDebt(tokenB, _account);

    accountInterestSnapshot[tokenA][_account] = cumulativeInterestRate[tokenA];
    accountInterestSnapshot[tokenB][_account] = cumulativeInterestRate[tokenB];
  }

  function _accrueAccountSupply(address _token, uint _amount, address _account) internal {
    if (_amount > 0) {
      uint supplyInterest   = _newInterest(_amount, _token, _account);
      uint newSupplyAccount = supplyInterest * _lpRate(_token) / 100e18;
      uint newSupplySystem  = supplyInterest * _systemRate(_token) / 100e18;

      _mintSupply(_token, _account, newSupplyAccount);
      _mintSupply(_token, feeRecipient(), newSupplySystem);
    }
  }

  function _accrueAccountDebt(address _token, address _account) internal {
    if (debtOf[_token][_account] > 0) {
      uint newDebt = _pendingBorrowInterest(_token, _account);
      _mintDebt(_token, _account, newDebt);
    }
  }

  function _withdraw(address _token, uint _amount) internal {

    lpToken[address(_token)].burn(msg.sender, _amount);

    checkAccountHealth(msg.sender);

    emit Withdraw(_token, _amount);
  }

  function _borrow(address _token, uint _amount) internal {

    require(lpToken[address(_token)].balanceOf(msg.sender) == 0, ""LendingPair: cannot borrow supplied token"");

    _mintDebt(_token, msg.sender, _amount);

    _checkBorrowLimits(_token, msg.sender);
    checkAccountHealth(msg.sender);

    emit Borrow(_token, _amount);
  }

  function _repay(address _account, address _token, uint _amount) internal {
    _burnDebt(_token, _account, _amount);
    emit Repay(_account, _token, _amount);
  }

  function _deposit(address _account, address _token, uint _amount) internal {

    _checkOracleSupport(tokenA);
    _checkOracleSupport(tokenB);

    require(debtOf[_token][_account] == 0, ""LendingPair: cannot deposit borrowed token"");

    _mintSupply(_token, _account, _amount);
    _checkDepositLimit(_token);

    emit Deposit(_account, _token, _amount);
  }

  function _accrueInterest(address _token) internal {
    uint blocksElapsed = block.number - lastBlockAccrued;
    uint newInterest = _borrowRatePerBlock(_token) * blocksElapsed;
    cumulativeInterestRate[_token] += newInterest;
  }

  function _createLpToken(address _lpTokenMaster) internal returns(IERC20) {
    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());
    newLPToken.initialize();
    return IERC20(newLPToken);
  }

  function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {
    if (_amount > 0) {
      bool success = _token.transfer(_recipient, _amount);
      require(success, ""LendingPair: transfer failed"");
      _checkMinReserve(address(_token));
    }
  }

  function _wethWithdrawTo(address _to, uint _amount) internal override {
    if (_amount > 0) {
      TransferHelper._wethWithdrawTo(_to, _amount);
      _checkMinReserve(address(WETH));
    }
  }

  function _borrowRatePerBlock(address _token) internal view returns(uint) {
    return controller.interestRateModel().borrowRatePerBlock(ILendingPair(address(this)), _token);
  }

  function _pendingBorrowInterest(address _token, address _account) internal view returns(uint) {
    return _newInterest(debtOf[_token][_account], _token, _account);
  }

  function _borrowBalance(
    address _account,
    address _borrowedToken,
    address _returnToken
  ) internal view returns(uint) {

    return _convertTokenValues(_borrowedToken, _returnToken, debtOf[_borrowedToken][_account]);
  }

  // Get supply balance converted to the units of _returnToken
  function _supplyBalance(
    address _account,
    address _suppliedToken,
    address _returnToken
  ) internal view returns(uint) {

    return _convertTokenValues(_suppliedToken, _returnToken, lpToken[_suppliedToken].balanceOf(_account));
  }

  function _supplyCredit(
    address _account,
    address _suppliedToken,
    address _returnToken
  ) internal view returns(uint) {

    return _supplyBalance(_account, _suppliedToken, _returnToken) * controller.colFactor(_suppliedToken) / 100e18;
  }

  function _convertTokenValues(
    address _fromToken,
    address _toToken,
    uint    _inputAmount
  ) internal view returns(uint) {

    uint priceFrom = controller.tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();
    uint priceTo   = controller.tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();

    return _inputAmount * priceFrom / priceTo;
  }

  function _validateToken(address _token) internal view {
    require(_token == tokenA || _token == tokenB, ""LendingPair: invalid token"");
  }

  function _checkOracleSupport(address _token) internal view {
    require(controller.tokenSupported(_token), ""LendingPair: token not supported"");
  }

  function _checkMinReserve(address _token) internal view {
    require(IERC20(_token).balanceOf(address(this)) >= MIN_RESERVE, ""LendingPair: below MIN_RESERVE"");
  }

  function _checkDepositLimit(address _token) internal view {
    require(controller.depositsEnabled(), ""LendingPair: deposits disabled"");

    uint depositLimit = controller.depositLimit(address(this), _token);

    if (depositLimit > 0) {
      require((lpToken[_token].totalSupply()) <= depositLimit, ""LendingPair: deposit limit reached"");
    }
  }

  function _checkBorrowLimits(address _token, address _account) internal view {
    require(controller.borrowingEnabled(), ""LendingPair: borrowing disabled"");

    uint accountBorrowUSD = debtOf[_token][_account] * controller.tokenPrice(_token) / 1e18;
    require(accountBorrowUSD >= controller.minBorrowUSD(), ""LendingPair: borrow amount below minimum"");

    uint borrowLimit = controller.borrowLimit(address(this), _token);

    if (borrowLimit > 0) {
      require(totalDebt[_token] <= borrowLimit, ""LendingPair: borrow limit reached"");
    }
  }

  function _systemRate(address _token) internal view returns(uint) {
    return controller.interestRateModel().systemRate(ILendingPair(address(this)), _token);
  }

  function _lpRate(address _token) internal view returns(uint) {
    return 100e18 - _systemRate(_token);
  }

  function _newInterest(uint _balance, address _token, address _account) internal view returns(uint) {
    return _balance * (cumulativeInterestRate[_token] - accountInterestSnapshot[_token][_account]) / 100e18;
  }
}",4587,578,"H-01: Reward computation is wrong H-02: LendingPair.liquidateAccount does not accrue and update cumulativeInterestRate H-03: LendingPair.liquidateAccount fails if tokens are lent out",3
25_CompositeMultiOracle.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../../utils/access/AccessControl.sol"";
import ""../../interfaces/vault/IOracle.sol"";
import ""../../math/CastBytes32Bytes6.sol"";


/**
 * @title CompositeMultiOracle
 */
contract CompositeMultiOracle is IOracle, AccessControl {
    using CastBytes32Bytes6 for bytes32;

    uint8 public constant override decimals = 18;   
    // All prices are converted to 18 decimals

    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);
    event PathSet(bytes6 indexed baseId, bytes6 indexed quoteId, bytes6[] indexed path);

    struct Source {
        address source;
        uint8 decimals;
    }

    mapping(bytes6 => mapping(bytes6 => Source)) public sources;
    mapping(bytes6 => mapping(bytes6 => bytes6[])) public paths;

    /**
     * @notice Set or reset an oracle source
     */
    function setSource(bytes6 base, bytes6 quote, address source) external auth {
        _setSource(base, quote, source);
    }

    /**
     * @notice Set or reset a number of oracle sources
     */
    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {
        require(
            bases.length == quotes.length && 
            bases.length == sources_.length,
            ""Mismatched inputs""
        );
        for (uint256 i = 0; i < bases.length; i++) {
            _setSource(bases[i], quotes[i], sources_[i]);
        }
    }

    /**
     * @notice Set or reset an price path
     */
    function setPath(bytes6 base, bytes6 quote, bytes6[] memory path) external auth {
        _setPath(base, quote, path);
    }

    /**
     * @notice Set or reset a number of price paths
     */
    function setPaths(bytes6[] memory bases, bytes6[] memory quotes, bytes6[][] memory paths_) external auth {
        require(
            bases.length == quotes.length && 
            bases.length == paths_.length,
            ""Mismatched inputs""
        );
        for (uint256 i = 0; i < bases.length; i++) {
            _setPath(bases[i], quotes[i], paths_[i]);
        }
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @return value
     */
    function peek(bytes32 base, bytes32 quote, uint256 amount)
        external view virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price = 1e18;
        bytes6 base_ = base.b6();
        bytes6 quote_ = quote.b6();
        bytes6[] memory path = paths[base_][quote_];
        for (uint256 p = 0; p < path.length; p++) {
            (price, updateTime) = _peek(base_, path[p], price, updateTime);
            base_ = path[p];
        }
        (price, updateTime) = _peek(base_, quote_, price, updateTime);
        value = price * amount / 1e18;
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.. Same as `peek` for this oracle.
     * @return value
     */
    function get(bytes32 base, bytes32 quote, uint256 amount)
        external virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price = 1e18;
        bytes6 base_ = base.b6();
        bytes6 quote_ = quote.b6();
        bytes6[] memory path = paths[base_][quote_];
        for (uint256 p = 0; p < path.length; p++) {
            (price, updateTime) = _get(base_, path[p], price, updateTime);
            base_ = path[p];
        }
        (price, updateTime) = _get(base_, quote_, price, updateTime);
        value = price * amount / 1e18;
    }

    function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)
        private view returns (uint priceOut, uint updateTimeOut)
    {
        Source memory source = sources[base][quote];
        require (source.source != address(0), ""Source not found"");
        (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   
        // Get price for one unit
        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       
        // Fixed point according to decimals
        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 
        // Take the oldest update time
    }

    function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)
        private returns (uint priceOut, uint updateTimeOut)
    {
        Source memory source = sources[base][quote];
        require (source.source != address(0), ""Source not found"");
        (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    
        // Get price for one unit
        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       
        // Fixed point according to decimals
        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 
        // Take the oldest update time
    }

    function _setSource(bytes6 base, bytes6 quote, address source) internal {
        uint8 decimals_ = IOracle(source).decimals();
        require (decimals_ <= 18, ""Unsupported decimals"");
        sources[base][quote] = Source({
            source: source,
            decimals: decimals_
        });
        emit SourceSet(base, quote, source);
    }

    function _setPath(bytes6 base, bytes6 quote, bytes6[] memory path) internal {
        bytes6 base_ = base;
        for (uint256 p = 0; p < path.length; p++) {
            require (sources[base_][path[p]].source != address(0), ""Source not found"");
            base_ = path[p];
        }
        paths[base][quote] = path;
        emit PathSet(base, quote, path);
    }
}",1354,157,H-01: CompositeMultiOracle returns wrong decimals for prices?,1
14_SushiYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""./ISushiBar.sol"";
import ""./ISushi.sol"";

/// @title A pooltogether yield source for sushi token
/// @author Steffel Fenix
contract SushiYieldSource is IYieldSource {
    
    using SafeMath for uint256;
    
    ISushiBar public immutable sushiBar;
    ISushi public immutable sushiAddr;
    
    mapping(address => uint256) public balances;

    constructor(ISushiBar _sushiBar, ISushi _sushiAddr) public {
        sushiBar = _sushiBar;
        sushiAddr = _sushiAddr;
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() public view override returns (address) {
        return address(sushiAddr);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = sushiBar.totalSupply();
        uint256 barSushiBalance = sushiAddr.balanceOf(address(sushiBar));

        return balances[addr].mul(barSushiBalance).div(totalShares);       
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param amount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 amount, address to) public override {
        sushiAddr.transferFrom(msg.sender, address(this), amount);
        sushiAddr.approve(address(sushiBar), amount);

        ISushiBar bar = sushiBar;
        uint256 beforeBalance = bar.balanceOf(address(this));
        
        bar.enter(amount);
        
        uint256 afterBalance = bar.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        
        balances[to] = balances[to].add(balanceDiff);
    }

    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.
    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @dev The maxiumum that can be called for token() is calculated by balanceOfToken() above.
    /// @return The actual amount of tokens that were redeemed. This may be different from the amount passed due to the fractional math involved. 
    function redeemToken(uint256 amount) public override returns (uint256) {
        ISushiBar bar = sushiBar;
        ISushi sushi = sushiAddr;

        uint256 totalShares = bar.totalSupply();
        if(totalShares == 0) return 0; 

        uint256 barSushiBalance = sushi.balanceOf(address(bar));
        if(barSushiBalance == 0) return 0;

        uint256 sushiBeforeBalance = sushi.balanceOf(address(this));

        uint256 requiredShares = ((amount.mul(totalShares) + totalShares)).div(barSushiBalance);
        if(requiredShares == 0) return 0;
        
        uint256 requiredSharesBalance = requiredShares.sub(1);
        bar.leave(requiredSharesBalance);

        uint256 sushiAfterBalance = sushi.balanceOf(address(this));
        
        uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        sushi.transfer(msg.sender, sushiBalanceDiff);
        
        return (sushiBalanceDiff);
    }

}",818,94,"M-02: Return values of ERC20 transfer and transferFrom are unchecked M-03: SafeMath not completely used in yield source contracts.  L78",2
113_NFTPairWithOracle.sol,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; 
    // How much will you get? OK to owe until expiration.
    uint64 duration; 
    // Length of loan in seconds
    uint16 annualInterestBPS; 
    // Variable cost of taking out the loan
    uint16 ltvBPS; 
    // Required to avoid liquidation
    INFTOracle oracle; 
    // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); 
        // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); 
            // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8427,762,"H-02: The return value success of the get function of the INFTOracle interface is not checked. L287 H-03: Critical Oracle Manipulation Risk by Lender.  L286-L288 H-04: Lender is able to seize the collateral by changing the loan parameters. L198 H-5: Mistake while checking LTV to lender accepted LTV.  L316",4
69_NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
      // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",4834,481,H-03: A vault can be locked from MarketplaceZap and StakingZap,1
5_Pools.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iFACTORY.sol"";

contract Pools {

    // Parameters
    bool private inited;
    uint public pooledVADER;
    uint public pooledUSDV;
    
    address public VADER;
    address public USDV;
    address public ROUTER;
    address public FACTORY;

    mapping(address => bool) _isMember;
    mapping(address => bool) _isAsset;
    mapping(address => bool) _isAnchor;

    mapping(address => uint) public mapToken_Units;
    mapping(address => mapping(address => uint)) public mapTokenMember_Units;
    mapping(address => uint) public mapToken_baseAmount;
    mapping(address => uint) public mapToken_tokenAmount;

    // Events
    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);
    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);
    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);
    event Sync(address indexed token, address indexed pool, uint addedAmount);
    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}

    // Init
    function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {
        require(token != USDV && token != VADER); 
        uint _actualInputBase;
        if(base == VADER){
            if(!isAnchor(token)){               
                _isAnchor[token] = true;
            }
            _actualInputBase = getAddedAmount(VADER, token);
        } else if (base == USDV) {
            if(!isAsset(token)){              
                _isAsset[token] = true;
            }
            _actualInputBase = getAddedAmount(USDV, token);
        }
        uint _actualInputToken = getAddedAmount(token, token);
        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);
        mapTokenMember_Units[token][member] += liquidityUnits;  
        mapToken_Units[token] += liquidityUnits;                
        mapToken_baseAmount[token] += _actualInputBase;         
        mapToken_tokenAmount[token] += _actualInputToken;       
        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); 
    }
    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, msg.sender);
    }
    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {
        require(base == USDV || base == VADER);
        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);
        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);
        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);
        mapToken_Units[token] -=_units;
        mapTokenMember_Units[token][member] -= _units;
        mapToken_baseAmount[token] -= outputBase;
        mapToken_tokenAmount[token] -= outputToken;
        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);
        transferOut(base, outputBase, member);
        transferOut(token, outputToken, member);
        return (outputBase, outputToken);
    }
    
    //=======================================SWAP===========================================//
    
    // Designed to be called by a router, but can be called directly
    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {
        if(toBase){
            uint _actualInput = getAddedAmount(token, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            mapToken_tokenAmount[token] += _actualInput;
            mapToken_baseAmount[token] -= outputAmount;
            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);
            transferOut(base, outputAmount, member);
        } else {
            uint _actualInput = getAddedAmount(base, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            mapToken_baseAmount[token] += _actualInput;
            mapToken_tokenAmount[token] -= outputAmount;
            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);
            transferOut(token, outputAmount, member);
        }
    }

    // Add to balances directly (must send first)
    function sync(address token, address pool) external {
        uint _actualInput = getAddedAmount(token, pool);
        if (token == VADER || token == USDV){
            mapToken_baseAmount[pool] += _actualInput;
        } else {
            mapToken_tokenAmount[pool] += _actualInput;
        // } else if(isSynth()){
        //     //burnSynth && deleteUnits
        }
        emit Sync(token, pool, _actualInput);
    }

    //======================================SYNTH=========================================//

    // Should be done with intention, is gas-intensive
    function deploySynth(address token) external {
        require(token != VADER || token != USDV);
        iFACTORY(FACTORY).deploySynth(token);
    }

    // Mint a Synth against its own pool
    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {
        require(iFACTORY(FACTORY).isSynth(getSynth(token)), ""!synth"");
        uint _actualInputBase = getAddedAmount(base, token);                    
        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     
        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);  
        mapTokenMember_Units[token][address(this)] += _synthUnits;                 
        mapToken_Units[token] += _synthUnits;                                       
        mapToken_baseAmount[token] += _actualInputBase;                           
        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   
        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         
    }
    // Burn a Synth to get out BASE
    function burnSynth(address base, address token, address member) external returns (uint outputBase) {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               
        mapToken_Units[token] -= _unitsToDelete;                                   
        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);   
        mapToken_baseAmount[token] -= outputBase;                                  
        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        
        transferOut(base, outputBase, member);                                     
    }
    // Remove a synth, make other LPs richer
    function syncSynth(address token) external {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;              
        mapToken_Units[token] -= _unitsToDelete;                                 
        emit SynthSync(token, _actualInputSynth, _unitsToDelete);
    }

    //======================================LENDING=========================================//
    
    // Assign units to callee (ie, a LendingRouter)
    function lockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][member] -= units;
        mapTokenMember_Units[token][msg.sender] += units;      
    }
    // Assign units to callee (ie, a LendingRouter)
    function unlockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][msg.sender] -= units;      
        mapTokenMember_Units[token][member] += units;
    }

    //======================================HELPERS=========================================//

    // Safe adds
    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(_token == VADER && _pool != VADER){  
            addedAmount = _balance - pooledVADER;
            pooledVADER = pooledVADER + addedAmount;
        } else if(_token == USDV) {             
            addedAmount = _balance - pooledUSDV;
            pooledUSDV = pooledUSDV + addedAmount;
        } else {                                
            addedAmount = _balance - mapToken_tokenAmount[_pool];
        }
    }
    function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; 
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount; 
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }

    function isMember(address member) public view returns(bool) {
        return _isMember[member];
    }
    function isAsset(address token) public view returns(bool) {
        return _isAsset[token];
    }
    function isAnchor(address token) public view returns(bool) {
        return _isAnchor[token];
    }
    function getPoolAmounts(address token) external view returns(uint, uint) {
        return (getBaseAmount(token), getTokenAmount(token));
    }
    function getBaseAmount(address token) public view returns(uint) {
        return mapToken_baseAmount[token];
    }
    function getTokenAmount(address token) public view returns(uint) {
        return mapToken_tokenAmount[token];
    }
    function getUnits(address token) external view returns(uint) {
        return mapToken_Units[token];
    }
    function getMemberUnits(address token, address member) external view returns(uint) {
        return mapTokenMember_Units[token][member];
    }
    function getSynth(address token) public view returns (address) {
        return iFACTORY(FACTORY).getSynth(token);
    }
    function isSynth(address token) public view returns (bool) {
        return iFACTORY(FACTORY).isSynth(token);
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
}",2783,248,"H-01: Unhandled return value of transfer in transferOut() of Pools.sol H-11: Swap token can be traded as fake base token H-13: 4 Synths can be minted with fake base token",3
6_Beebots.sol,"pragma solidity 0.7.6;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface BetaToken {
    function tokenOwner(uint index) external view returns(address);
}

interface ERC721TokenReceiver
{
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);
}

library SafeMath {

    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}

contract Beebots is IERC721 {

    using SafeMath for uint256;

    /**
     * Event emitted when minting a new NFT. ""createdVia"" is the index of the alhpa/beta token that was used to mint, or 0 if not applicable.
     */
    event Mint(uint indexed index, address indexed minter, uint createdVia);

    /**
     * Event emitted when a trade is executed.
     */
    event Trade(bytes32 indexed hash, address indexed maker, address taker, uint makerWei, uint[] makerIds, uint takerWei, uint[] takerIds);

    /**
     * Event emitted when ETH is deposited into the contract.
     */
    event Deposit(address indexed account, uint amount);

    /**
     * Event emitted when ETH is withdrawn from the contract.
     */
    event Withdraw(address indexed account, uint amount);

    /**
     * Event emitted when a trade offer is cancelled.
     */
    event OfferCancelled(bytes32 hash);

    /**
     * Event emitted when the public sale begins.
     */
    event SaleBegins();

    /**
     * Event emitted when the community grant period ends.
     */
    event CommunityGrantEnds();

    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;

    // Hash to the NFT content
    string public contentHash = ""todo"";

    uint public constant TOKEN_LIMIT = 30; 
    uint public constant SALE_LIMIT = 20; 

    mapping (uint => address) private idToCreator;

    mapping(bytes4 => bool) internal supportedInterfaces;

    mapping (uint256 => address) internal idToOwner;

    mapping (uint256 => uint256) public idToCreatorNft;

    mapping (uint256 => uint256) public creatorNftMints;

    mapping (uint256 => address) internal idToApproval;

    mapping (address => mapping (address => bool)) internal ownerToOperators;

    mapping(address => uint256[]) internal ownerToIds;

    mapping(uint256 => uint256) internal idToOwnerIndex;

    string internal nftName = ""Beebots"";
    string internal nftSymbol = unicode""🐝"";

    uint internal numTokens = 0;
    uint internal numSales = 0;

    address internal beta;

    address internal alpha;

    address payable internal deployer;
    address payable internal beneficiary;
    bool public communityGrant = true;
    bool public publicSale = false;
    uint private price;
    uint public saleStartTime;
    uint public saleDuration;

    //// Random index assignment
    uint internal nonce = 0;
    uint[TOKEN_LIMIT] internal indices;

    //// Market
    bool public marketPaused;
    bool public contractSealed;
    mapping (address => uint256) public ethBalance;
    mapping (bytes32 => bool) public cancelledOffers;

    modifier onlyDeployer() {
        require(msg.sender == deployer, ""Only deployer."");
        _;
    }

    bool private reentrancyLock = false;

    /* Prevent a contract function from being reentrant-called. */
    modifier reentrancyGuard {
        if (reentrancyLock) {
            revert();
        }
        reentrancyLock = true;
        _;
        reentrancyLock = false;
    }

    modifier canOperate(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], ""Cannot operate."");
        _;
    }

    modifier canTransfer(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(
            tokenOwner == msg.sender
            || idToApproval[_tokenId] == msg.sender
            || ownerToOperators[tokenOwner][msg.sender], ""Cannot transfer.""
        );
        _;
    }

    modifier validNFToken(uint256 _tokenId) {
        require(idToOwner[_tokenId] != address(0), ""Invalid token."");
        _;
    }

    constructor(address _beta, address _alpha, address payable _beneficiary) {
        supportedInterfaces[0x01ffc9a7] = true; 
        supportedInterfaces[0x80ac58cd] = true; 
        supportedInterfaces[0x780e9d63] = true; 
        supportedInterfaces[0x5b5e139f] = true; 
        deployer = msg.sender;
        beta = _beta;
        alpha = _alpha;
        beneficiary = _beneficiary;
    }

    function startSale(uint _price, uint _saleDuration) external onlyDeployer {
        require(!publicSale, ""Sale already started."");
        price = _price;
        saleDuration = _saleDuration;
        saleStartTime = block.timestamp;
        publicSale = true;
        emit SaleBegins();
    }

    function endCommunityGrant() external onlyDeployer {
        require(communityGrant, ""Grant period already ended."");
        communityGrant = false;
        emit CommunityGrantEnds();
    }

    function pauseMarket(bool _paused) external onlyDeployer {
        require(!contractSealed, ""Contract sealed."");
        marketPaused = _paused;
    }

    function sealContract() external onlyDeployer {
        contractSealed = true;
    }

    //////////////////////////
    //// ERC 721 and 165  ////
    //////////////////////////

    function isContract(address _addr) internal view returns (bool addressCheck) {
        uint256 size;
        assembly { size := extcodesize(_addr) } 
        addressCheck = size > 0;
    }

    function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {
        return supportedInterfaces[_interfaceID];
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {
        _safeTransferFrom(_from, _to, _tokenId, _data);
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {
        _safeTransferFrom(_from, _to, _tokenId, """");
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) external override canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from, ""Wrong from address."");
        require(_to != address(0), ""Cannot send to 0x0."");
        _transfer(_to, _tokenId);
    }

    function approve(address _approved, uint256 _tokenId) external override canOperate(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(_approved != tokenOwner);
        idToApproval[_tokenId] = _approved;
        emit Approval(tokenOwner, _approved, _tokenId);
    }

    function setApprovalForAll(address _operator, bool _approved) external override {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    function balanceOf(address _owner) external view override returns (uint256) {
        require(_owner != address(0));
        return _getOwnerNFTCount(_owner);
    }

    function ownerOf(uint256 _tokenId) external view override returns (address _owner) {
        _owner = idToOwner[_tokenId];
    }

    function getApproved(uint256 _tokenId) external view override validNFToken(_tokenId) returns (address) {
        return idToApproval[_tokenId];
    }

    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {
        return ownerToOperators[_owner][_operator];
    }

    function _transfer(address _to, uint256 _tokenId) internal {
        address from = idToOwner[_tokenId];
        _clearApproval(_tokenId);

        _removeNFToken(from, _tokenId);
        _addNFToken(_to, _tokenId);

        emit Transfer(from, _to, _tokenId);
    }

    function randomIndex() internal returns (uint) {
        uint totalSize = TOKEN_LIMIT - numTokens;
        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;
        uint value = 0;
        if (indices[index] != 0) {
            value = indices[index];
        } else {
            value = index;
        }

        // Move last value to selected position
        if (indices[totalSize - 1] == 0) {
            // Array position not initialized, so use position
            indices[index] = totalSize - 1;
        } else {
            // Array position holds a value so use that
            indices[index] = indices[totalSize - 1];
        }
        nonce.add(1);
        // Don't allow a zero index, start counting at 1
        return value.add(1);
    }

    // Calculate the mint price
    function getPrice() public view returns (uint) {
        require(publicSale, ""Sale not started."");
        uint elapsed = block.timestamp.sub(saleStartTime);
        if (elapsed > saleDuration) {
            return 0;
        } else {
            return saleDuration.sub(elapsed).mul(price).div(saleDuration);
        }
    }

    // The deployer can mint in bulk without paying
    function devMint(uint quantity, address recipient) external onlyDeployer {
        for (uint i = 0; i < quantity; i++) {
            _mint(recipient, 0);
        }
    }

    function mintsRemaining() external view returns (uint) {
        return SALE_LIMIT.sub(numSales);
    }

    /**
     * Community grant minting.
     */
    function mintWithAlphaOrBeta(uint _createVia) external reentrancyGuard returns (uint) {
        require(communityGrant);
        require(_createVia > 0 && _createVia <= 600, ""Invalid alpha/beta index."");
        require(creatorNftMints[_createVia] == 0, ""Already minted with this alpha/beta"");
        if (_createVia > 400) {
            // It's an alpha
            // Compute the alpha ID
            uint alphaId = _createVia.sub(400);
            // Make sure the sender owns the alpha
            require(IERC721(alpha).ownerOf(alphaId) == msg.sender, ""Not the owner of this alpha."");
        } else {
            // It's a beta
            // Compute the beta ID, 0-based
            uint betaId = _createVia.sub(1);
            // Make sure the sender owns the beta
            require(BetaToken(beta).tokenOwner(betaId) == msg.sender, ""Not the owner of this beta."");
        }
        creatorNftMints[_createVia]++;
        return _mint(msg.sender, _createVia);
    }

    /**
     * Public sale minting.
     */
    function mint() external payable reentrancyGuard returns (uint) {
        require(publicSale, ""Sale not started."");
        require(numSales < SALE_LIMIT, ""Sale limit reached."");
        uint salePrice = getPrice();
        require(msg.value >= salePrice, ""Insufficient funds to purchase."");
        if (msg.value > salePrice) {
            msg.sender.transfer(msg.value.sub(salePrice));
        }
        beneficiary.transfer(salePrice);
        numSales++;
        return _mint(msg.sender, 0);
    }

    function _mint(address _to, uint createdVia) internal returns (uint) {
        require(_to != address(0), ""Cannot mint to 0x0."");
        require(numTokens < TOKEN_LIMIT, ""Token limit reached."");
        uint id = randomIndex();

        idToCreator[id] = _to;
        idToCreatorNft[id] = createdVia;

        numTokens = numTokens + 1;
        _addNFToken(_to, id);

        emit Mint(id, _to, createdVia);
        emit Transfer(address(0), _to, id);
        return id;
    }

    function _addNFToken(address _to, uint256 _tokenId) internal {
        require(idToOwner[_tokenId] == address(0), ""Cannot add, already owned."");
        idToOwner[_tokenId] = _to;

        ownerToIds[_to].push(_tokenId);
        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);
    }

    function _removeNFToken(address _from, uint256 _tokenId) internal {
        require(idToOwner[_tokenId] == _from, ""Incorrect owner."");
        delete idToOwner[_tokenId];

        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];
        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);

        if (lastTokenIndex != tokenToRemoveIndex) {
            uint256 lastToken = ownerToIds[_from][lastTokenIndex];
            ownerToIds[_from][tokenToRemoveIndex] = lastToken;
            idToOwnerIndex[lastToken] = tokenToRemoveIndex;
        }

        ownerToIds[_from].pop();
    }

    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {
        return ownerToIds[_owner].length;
    }

    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from, ""Incorrect owner."");
        require(_to != address(0));

        _transfer(_to, _tokenId);

        if (isContract(_to)) {
            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
            require(retval == MAGIC_ERC721_RECEIVED);
        }
    }

    function _clearApproval(uint256 _tokenId) private {
        if (idToApproval[_tokenId] != address(0)) {
            delete idToApproval[_tokenId];
        }
    }

    //// Enumerable

    function totalSupply() public view returns (uint256) {
        return numTokens;
    }

    function tokenByIndex(uint256 index) public pure returns (uint256) {
        require(index > 0 && index < TOKEN_LIMIT);
        return index;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        require(_index < ownerToIds[_owner].length);
        return ownerToIds[_owner][_index];
    }

    //// Metadata

    /**
      * @dev Converts a `uint256` to its ASCII `string` representation.
      */
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }

    /**
      * @dev Returns a descriptive name for a collection of NFTokens.
      * @return _name Representing name.
      */
    function name() external view returns (string memory _name) {
        _name = nftName;
    }

    /**
     * @dev Returns an abbreviated name for NFTokens.
     * @return _symbol Representing symbol.
     */
    function symbol() external view returns (string memory _symbol) {
        _symbol = nftSymbol;
    }

    /**
     * @dev A distinct URI (RFC 3986) for a given NFT.
     * @param _tokenId Id for which we want uri.
     * @return _tokenId URI of _tokenId.
     */
    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {
        return string(abi.encodePacked(""https://todo/"", toString(_tokenId)));
    }

    //// MARKET

    struct Offer {
        address maker;
        address taker;
        uint256 makerWei;
        uint256[] makerIds;
        uint256 takerWei;
        uint256[] takerIds;
        uint256 expiry;
        uint256 salt;
    }

    function hashOffer(Offer memory offer) private pure returns (bytes32){
        return keccak256(abi.encode(
                    offer.maker,
                    offer.taker,
                    offer.makerWei,
                    keccak256(abi.encodePacked(offer.makerIds)),
                    offer.takerWei,
                    keccak256(abi.encodePacked(offer.takerIds)),
                    offer.expiry,
                    offer.salt
                ));
    }

    function hashToSign(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) public pure returns (bytes32) {
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        return hashOffer(offer);
    }

    function hashToVerify(Offer memory offer) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hashOffer(offer)));
    }

    function verify(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {
        require(signature.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        require(v == 27 || v == 28);

        return signer == ecrecover(hash, v, r, s);
    }

    function tradeValid(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) view public returns (bool) {
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        // Check for cancellation
        bytes32 hash = hashOffer(offer);
        require(cancelledOffers[hash] == false, ""Trade offer was cancelled."");
        // Verify signature
        bytes32 verifyHash = hashToVerify(offer);
        require(verify(offer.maker, verifyHash, signature), ""Signature not valid."");
        // Check for expiry
        require(block.timestamp < offer.expiry, ""Trade offer expired."");
        // Only one side should ever have to pay, not both
        require(makerWei == 0 || takerWei == 0, ""Only one side of trade must pay."");
        // At least one side should offer tokens
        require(makerIds.length > 0 || takerIds.length > 0, ""One side must offer tokens."");
        // Make sure the maker has funded the trade
        require(ethBalance[offer.maker] >= offer.makerWei, ""Maker does not have sufficient balance."");
        // Ensure the maker owns the maker tokens
        for (uint i = 0; i < offer.makerIds.length; i++) {
            require(idToOwner[offer.makerIds[i]] == offer.maker, ""At least one maker token doesn't belong to maker."");
        }
        // If the taker can be anybody, then there can be no taker tokens
        if (offer.taker == address(0)) {
            // If taker not specified, then can't specify IDs
            require(offer.takerIds.length == 0, ""If trade is offered to anybody, cannot specify tokens from taker."");
        } else {
            // Ensure the taker owns the taker tokens
            for (uint i = 0; i < offer.takerIds.length; i++) {
                require(idToOwner[offer.takerIds[i]] == offer.taker, ""At least one taker token doesn't belong to taker."");
            }
        }
        return true;
    }

    function cancelOffer(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) external {
        require(maker == msg.sender, ""Only the maker can cancel this offer."");
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        bytes32 hash = hashOffer(offer);
        cancelledOffers[hash] = true;
        emit OfferCancelled(hash);
    }

    function acceptTrade(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) external payable reentrancyGuard {
        require(!marketPaused, ""Market is paused."");
        require(msg.sender != maker, ""Can't accept ones own trade."");
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        ethBalance[msg.sender] += msg.value;
        if (msg.value > 0) {
            emit Deposit(msg.sender, msg.value);
        }
        require(offer.taker == address(0) || offer.taker == msg.sender, ""Not the recipient of this offer."");
        require(tradeValid(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt, signature), ""Trade not valid."");
        require(ethBalance[msg.sender] >= offer.takerWei, ""Insufficient funds to execute trade."");
        // Transfer ETH
        ethBalance[offer.maker] = ethBalance[offer.maker].sub(offer.makerWei);
        ethBalance[msg.sender] = ethBalance[msg.sender].add(offer.makerWei);
        ethBalance[msg.sender] = ethBalance[msg.sender].sub(offer.takerWei);
        ethBalance[offer.maker] = ethBalance[offer.maker].add(offer.takerWei);
        // Transfer maker ids to taker (msg.sender)
        for (uint i = 0; i < makerIds.length; i++) {
            _transfer(msg.sender, makerIds[i]);
        }
        // Transfer taker ids to maker
        for (uint i = 0; i < takerIds.length; i++) {
            _transfer(maker, takerIds[i]);
        }
        // Prevent a replay attack on this offer
        bytes32 hash = hashOffer(offer);
        cancelledOffers[hash] = true;
        emit Trade(hash, offer.maker, msg.sender, offer.makerWei, offer.makerIds, offer.takerWei, offer.takerIds);
    }

    function withdraw(uint amount) external {
        require(amount <= ethBalance[msg.sender]);
        ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);
        msg.sender.transfer(amount);
        emit Withdraw(msg.sender, amount);
    }

    function deposit() external payable {
        ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }

}",5567,662,H-03: Beebots.TradeValid() Will Erroneously Return True When Maker Is Set To Address(0) and makerIds Are Set To The TokenIds of Unminted Beebot NFTs,1
12_AccessControl.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;


/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes4` identifier. These are expected to be the 
 * signatures for all the functions in the contract. Special roles should be exposed
 * in the external API and be unique:
 *
 * ```
 * bytes4 public constant ROOT = 0x00000000;
 * ```
 *
 * Roles represent restricted access to a function call. For that purpose, use {auth}:
 *
 * ```
 * function foo() public auth {
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `ROOT`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {setRoleAdmin}.
 *
 * WARNING: The `ROOT` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
contract AccessControl {
    struct RoleData {
        mapping (address => bool) members;
        bytes4 adminRole;
    }

    mapping (bytes4 => RoleData) private _roles;

    bytes4 public constant ROOT = 0x00000000;
    bytes4 public constant LOCK = 0xFFFFFFFF; 

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role
     *
     * `ROOT` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call.
     */
    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. 
     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.
     */
    constructor () {
        _grantRole(ROOT, msg.sender);   
        // Grant ROOT to msg.sender
        _setRoleAdmin(LOCK, LOCK);      
        // Create the LOCK role by setting itself as its own admin, creating an independent role tree
    }

    /**
     * @dev Each function in the contract has its own role, identified by their msg.sig signature.
     * ROOT can give and remove access to each function, lock any further access being granted to
     * a specific action, or even create other roles to delegate admin control over a function.
     */
    modifier auth() {
        require (_hasRole(msg.sig, msg.sender), ""Access denied"");
        _;
    }

    /**
     * @dev Allow only if the caller has been granted the admin role of `role`.
     */
    modifier admin(bytes4 role) {
        require (_hasRole(_getRoleAdmin(role), msg.sender), ""Only admin"");
        _;
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes4 role, address account) external view returns (bool) {
        return _hasRole(role, account);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes4 role) external view returns (bytes4) {
        return _getRoleAdmin(role);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.

     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {
        _setRoleAdmin(role, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes4 role, address account) external virtual admin(role) {
        _grantRole(role, account);
    }

    
    /**
     * @dev Grants all of `role` in `roles` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - For each `role` in `roles`, the caller must have ``role``'s admin role.
     */
    function grantRoles(bytes4[] memory roles, address account) external virtual {
        for (uint256 i = 0; i < roles.length; i++) {
            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), ""Only admin"");
            _grantRole(roles[i], account);
        }
    }

    /**
     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.

     * Emits a {RoleAdminChanged} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function lockRole(bytes4 role) external virtual admin(role) {
        _setRoleAdmin(role, LOCK);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes4 role, address account) external virtual admin(role) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes all of `role` in `roles` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - For each `role` in `roles`, the caller must have ``role``'s admin role.
     */
    function revokeRoles(bytes4[] memory roles, address account) external virtual {
        for (uint256 i = 0; i < roles.length; i++) {
            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), ""Only admin"");
            _revokeRole(roles[i], account);
        }
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes4 role, address account) external virtual {
        require(account == msg.sender, ""Renounce only for self"");

        _revokeRole(role, account);
    }

    function _hasRole(bytes4 role, address account) internal view returns (bool) {
        return _roles[role].members[account];
    }

    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {
        return _roles[role].adminRole;
    }

    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {
        if (_getRoleAdmin(role) != adminRole) {
            _roles[role].adminRole = adminRole;
            emit RoleAdminChanged(role, adminRole);
        }
    }

    function _grantRole(bytes4 role, address account) internal {
        if (!_hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes4 role, address account) internal {
        if (_hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}",2019,257,"H-02: auth collision possible The auth mechanism of AccessControl.sol uses function selectors (msg.sig) as a (unique) role definition. Also the _moduleCall allows the code to be extended.",1
29_HybridPool.sol,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IBentoBoxMinimal.sol"";
import ""../interfaces/IMasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""../libraries/MathUtils.sol"";
import ""./TridentERC20.sol"";

/// @notice Trident exchange pool template with hybrid like-kind formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares. However, the stableswap invariant is applied to the underlying amounts.
///      The API uses the underlying amounts.
contract HybridPool is IPool, TridentERC20 {
    using MathUtils for uint256;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;
    uint8 internal constant PRECISION = 112;

    /// @dev Constant value used as max loop limit.
    uint256 private constant MAX_LOOP_LIMIT = 256;
    uint256 internal constant MAX_FEE = 10000; 
    // @dev 100%.
    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;
    uint256 public immutable A;
    uint256 internal immutable N_A; 
    // @dev 2 * A.
    uint256 internal constant A_PRECISION = 100;

    /// @dev Multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS.
    /// For example, TBTC has 18 decimals, so the multiplier should be 1. WBTC
    /// has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10.
    uint256 public immutable token0PrecisionMultiplier;
    uint256 public immutable token1PrecisionMultiplier;
    
    uint256 public barFee;

    uint128 internal reserve0;
    uint128 internal reserve1;

    bytes32 public constant override poolIdentifier = ""Trident:HybridPool"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));
        
        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(a != 0, ""ZERO_A"");
        
        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));
        (, bytes memory _decimals0) = _token0.staticcall(abi.encodeWithSelector(0x313ce567)); 
        // @dev 'decimals()'.
        (, bytes memory _decimals1) = _token1.staticcall(abi.encodeWithSelector(0x313ce567)); 
        // @dev 'decimals()'.

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        A = a;
        N_A = 2 * a;
        token0PrecisionMultiplier = 10**(decimals - abi.decode(_decimals0, (uint8)));
        token1PrecisionMultiplier = 10**(decimals - abi.decode(_decimals1, (uint8)));
        unlocked = 1;
    }
    
    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        
        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        uint256 newLiq = _computeLiquidity(balance0 - fee0, balance1 - fee1);
        
        if (_totalSupply == 0) {
            liquidity = newLiq - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            uint256 oldLiq = _computeLiquidity(_reserve0, _reserve1);
            liquidity = ((newLiq - oldLiq) * _totalSupply) / oldLiq;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _updateReserves();
        emit Mint(msg.sender, amount0, amount1, recipient);
    }
    
    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];
        
        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);

        balance0 -= _toShare(token0, amount0);
        balance1 -= _toShare(token1, amount1);
        
        _updateReserves();

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});

        emit Burn(msg.sender, amount0, amount1, recipient);
    }
    
    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;
        
        _burn(address(this), liquidity);
        
        if (tokenOut == token1) {
            // @dev Swap `token0` for `token1`.
            // @dev Calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
            uint256 fee = _handleFee(token0, amount0);
            amount1 += _getAmountOut(amount0 - fee, _reserve0 - amount0, _reserve1 - amount1, true);
            _transfer(token1, amount1, recipient, unwrapBento);
            balance0 -= _toShare(token0, amount0);
            amountOut = amount1;
            amount0 = 0;
        } else {
            // @dev Swap `token1` for `token0`.
            require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
            uint256 fee = _handleFee(token1, amount1);
            amount0 += _getAmountOut(amount1 - fee, _reserve0 - amount0, _reserve1 - amount1, false);
            _transfer(token0, amount0, recipient, unwrapBento);
            balance1 -= _toShare(token1, amount1);
            amountOut = amount0;
            amount1 = 0;
        }
        _updateReserves();
        emit Burn(msg.sender, amount0, amount1, recipient);
    }
    
    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;
        
        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = balance0 - _reserve0;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = balance1 - _reserve1;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Swaps one token for another with payload. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        address tokenOut;
        uint256 fee;
        
        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = _toAmount(token0, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
            _processSwap(token1, recipient, amountOut, context, unwrapBento);
            uint256 balance0 = _toAmount(token0, __balance(token0));
            require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = _toAmount(token1, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
            _processSwap(token0, recipient, amountOut, context, unwrapBento);
            uint256 balance1 = _toAmount(token1, __balance(token1));
            require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        }
        _transfer(tokenIn, fee, barFeeTo, false);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }
    
    function _processSwap(
        address tokenOut,
        address to,
        uint256 amountOut,
        bytes memory data,
        bool unwrapBento
    ) internal {
        _transfer(tokenOut, amountOut, to, unwrapBento);
        if (data.length != 0) ITridentCallee(msg.sender).tridentSwapCallback(data);
    }
    
    function _getReserves() internal view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = (reserve0, reserve1);
        _reserve0 = _toAmount(token0, _reserve0);
        _reserve1 = _toAmount(token1, _reserve1);
    }
    
    function _updateReserves() internal {
        (uint256 _reserve0, uint256 _reserve1) = _balance();
        require(_reserve0 < type(uint128).max && _reserve1 < type(uint128).max, ""OVERFLOW"");
        reserve0 = uint128(_reserve0);
        reserve1 = uint128(_reserve1);
        emit Sync(_reserve0, _reserve1);
    }
    
    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        balance0 = _toAmount(token0, __balance(token0));
        balance1 = _toAmount(token1, __balance(token1));
    }
    
    function __balance(address token) internal view returns (uint256 balance) {
        // @dev balanceOf(address,address).
        (, bytes memory ___balance) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, 
            token, address(this)));
        balance = abi.decode(___balance, (uint256));
    }

    function _toAmount(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toAmount(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toAmount.selector,
            token, input, false));
        output = abi.decode(_output, (uint256));
    }
    
    function _toShare(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toShare(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toShare.selector,
            token, input, false));
        output = abi.decode(_output, (uint256));
    }
 
    function _getAmountOut(
        uint256 amountIn,
        uint256 _reserve0,
        uint256 _reserve1,
        bool token0In
    ) internal view returns (uint256 dy) {
        uint256 xpIn;
        uint256 xpOut;
        
        if (token0In) {
            xpIn = _reserve0 * token0PrecisionMultiplier;
            xpOut = _reserve1 * token1PrecisionMultiplier;
            amountIn *= token0PrecisionMultiplier;
        } else {
            xpIn = _reserve1 * token1PrecisionMultiplier;
            xpOut = _reserve0 * token0PrecisionMultiplier;
            amountIn *= token1PrecisionMultiplier;
        }
        uint256 d = _computeLiquidityFromAdjustedBalances(xpIn, xpOut);
        uint256 x = xpIn + amountIn;
        uint256 y = _getY(x, d);
        dy = xpOut - y - 1;
        dy /= (token0In ? token1PrecisionMultiplier : token0PrecisionMultiplier);
    }

    function _transfer(
        address token,
        uint256 amount,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            // @dev withdraw(address,address,address,uint256,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, 
            token, address(this), to, amount, 0));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            // @dev transfer(address,address,address,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, 
                token, address(this), to, _toShare(token, amount)));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    /// @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.
    /// See the StableSwap paper for details.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L319.
    /// @return liquidity The invariant, at the precision of the pool.
    function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {
        uint256 xp0 = _reserve0 * token0PrecisionMultiplier;
        uint256 xp1 = _reserve1 * token1PrecisionMultiplier;
        liquidity = _computeLiquidityFromAdjustedBalances(xp0, xp1);
    }

    function _computeLiquidityFromAdjustedBalances(uint256 xp0, uint256 xp1) internal view returns (uint256 computed) {
        uint256 s = xp0 + xp1;
        
        if (s == 0) {
            computed = 0;
        }
        uint256 prevD;
        uint256 D = s;
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            uint256 dP = (((D * D) / xp0) * D) / xp1 / 4;
            prevD = D;
            D = (((N_A * s) / A_PRECISION + 2 * dP) * D) / ((N_A / A_PRECISION - 1) * D + 3 * dP);
            if (D.within1(prevD)) {
                break;
            }
        }
        computed = D;
    }

    /// @notice Calculate the new balances of the tokens given the indexes of the token
    /// that is swapped from (FROM) and the token that is swapped to (TO).
    /// This function is used as a helper function to calculate how much TO token
    /// the user should receive on swap.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L432.
    /// @param x The new total amount of FROM token.
    /// @return y The amount of TO token that should remain in the pool.
    function _getY(uint256 x, uint256 D) internal view returns (uint256 y) {
        uint256 c = (D * D) / (x * 2);
        c = (c * D) / ((N_A * 2) / A_PRECISION);
        uint256 b = x + ((D * A_PRECISION) / N_A);
        uint256 yPrev;
        y = D;
        // @dev Iterative approximation.
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - D);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }

    /// @notice Calculate the price of a token in the pool given
    /// precision-adjusted balances and a particular D and precision-adjusted
    /// array of balances.
    /// @dev This is accomplished via solving the quadratic equation iteratively.
    /// See the StableSwap paper and Curve.fi implementation for further details.
    /// x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
    /// x_1**2 + b*x_1 = c
    /// x_1 = (x_1**2 + c) / (2*x_1 + b)
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L276.
    /// @return y The price of the token, in the same precision as in xp.
    function _getYD(
        uint256 s, // @dev xpOut.
        uint256 d
    ) internal view returns (uint256 y) {
        uint256 c = (d * d) / (s * 2);
        c = (c * d) / ((N_A * 2) / A_PRECISION);

        uint256 b = s + ((d * A_PRECISION) / N_A);
        uint256 yPrev;
        y = d;
        
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - d);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }
    
    function _handleFee(address tokenIn, uint256 amountIn) internal returns (uint256 fee) {
        fee = (amountIn * swapFee) / MAX_FEE;
        uint256 _barFee = (fee * barFee) / MAX_FEE;
        _transfer(tokenIn, _barFee, barFeeTo, false);
    }
    
    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }
    
    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }
    
    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        amountIn = _toAmount(tokenIn, amountIn);
        amountIn -= (amountIn * swapFee) / MAX_FEE;
        
        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);
        }
    }

    function getReserves()
        public
        view
        returns (
            uint256 _reserve0,
            uint256 _reserve1
        )
    {
        (_reserve0, _reserve1) = _getReserves();
    }
}",5385,477,"H-05: hybrid pool uses wrong non_optimal_mint_fee.  L425-L441 H-08: HybridPool's reserve is converted to ""amount"" twice H-16: Funds in the pool could be stolen by exploiting flashSwap in HybridPool M-07: HybridPool's flashSwap sends entire fee to barFeeTo M-09: Approximations may finish with inaccurate values",5
78_FlanBackstop.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./facades/FlanLike.sol"";
import ""./facades/PyroTokenLike.sol"";
import ""./DAO/Governable.sol"";
import ""./ERC677/ERC20Burnable.sol"";
import ""./facades/UniPairLike.sol"";
import ""hardhat/console.sol"";

///@title FlanBackstop (placeholder name)
///@author Justin Goro
/**
 * @notice Initially Flan's liquidity may be fairly low, limiting Limbo's ability to reward souls. Flan backstop accepts stablecoins in return for minting Pyroflan.
 *Under the hood a smaller quantity of Flan is minted and paired with the stablecoin in Uniswap in order to tilt the price of Flan higher while incresaing liquidity.
 * The same operation is performed with PyroFlan
 * The calling user then receives PyroFlan equal in value to the intial amount sent in but at the new price. A small premium is added.
 * The incentives facing the user: mint $X of PyroFlan with <$X of stablecoin, stake PyroFlan in Limbo for high APY, do not immediately dump because PyroFlan increases in value and because of 2% exit fee.
 * The incentives should be enough to encourage a gradual increase in pooled Flan and stablecoins, creating some minting runway for Limbo to accelerate.
 * In the future when Flan and Limbo are thriving and Flan is listed on Curve, we can create a version of this for Curve and Uniswap V3 in order to concentrate Flan liquidity and further cement stablecoin status.
 * Note: in this version, LP tokens generated are cast into the void. The argument of keeping them for fee revenue is negated by the impact on Flan. It would just be taking from Peter to give to Paul. 
 */
///@dev This contract uses Pyrotokens3. At the time of authoring, Pyrotokens3 implementation is incomplete and not fully tested but the interface (ABI) is locked.
contract FlanBackstop is Governable {
  /**
   *@param dao LimboDAO
   *@param flan Flan address
   *@param pyroFlan PyroFlan address
   */
  constructor(
    address dao,
    address flan,
    address pyroFlan
  ) Governable(dao) {
    config.pyroFlan = pyroFlan;
    config.flan = flan;
    IERC20(flan).approve(pyroFlan, 2**256 - 1);
  }

  struct ConfigVars {
    address flan;
    address pyroFlan;
    mapping(address => address) flanLPs;
    mapping(address => address) pyroFlanLPs;
    mapping(address => uint256) acceptableHighestPrice; 
    //Highest tolerated Flan per stable
    mapping(address => uint8) decimalPlaces; 
    //USDC and USDT have 6 decimal places because large stablecoin transfers are exactly where you'd like to find accidental bugs
  }

  ConfigVars public config;

  /**
   *@param stablecoin One of the popular stablecoins such as USDC, USDT, MIM, OUSD etc.
   *@param flanLP Uniswap V2 (or a fork such as Sushi) flan/Stablecoin LP
   *@param pyroFlanLP Uniswap V2 (or a fork such as Sushi) pyroFlan/Stablecoin LP
   *@param acceptableHighestPrice Since the prices are being read from balances, not oracles, the opportunity for price manipulation through flash loans exists. The community can put a circuit breaker in place to prevent such an exploit.
   *@param decimalPlaces USDT and USDC do not conform to common ERC20 practice. 
   */
  function setBacker(
    address stablecoin,
    address flanLP,
    address pyroFlanLP,
    uint256 acceptableHighestPrice,
    uint8 decimalPlaces
  ) external onlySuccessfulProposal {
    config.flanLPs[stablecoin] = flanLP;
    config.pyroFlanLPs[stablecoin] = pyroFlanLP;
    config.acceptableHighestPrice[stablecoin] = acceptableHighestPrice;
    config.decimalPlaces[stablecoin] = decimalPlaces;
  }

  /**
  *@notice takes in a stablecoin, mints flan and pyroFlan and pairs with stablecoin in a Uniswap Pair to generate liquidity
   *@param stablecoin Stablecoin with which to purchase
   *@param amount amount in stablecoin wei units.
   */
  function purchasePyroFlan(address stablecoin, uint256 amount) external {
    uint normalizedAmount = normalize(stablecoin, amount);
    address flanLP = config.flanLPs[stablecoin];
    address pyroFlanLP = config.pyroFlanLPs[stablecoin];
    require(flanLP != address(0) && pyroFlanLP != address(0), ""BACKSTOP: configure stablecoin"");

    uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);
    uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);
    uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;

    //Price tilt pairs and mint liquidity
    FlanLike(config.flan).mint(address(this), normalizedAmount / 2);
    IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);
    IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);

    UniPairLike(flanLP).mint(address(this));
    uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();
    PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);
    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();
    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();
    IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);
    UniPairLike(pyroFlanLP).mint(address(this));

    uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);
    uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);

    uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;
    require(tiltedPrice < config.acceptableHighestPrice[stablecoin], ""BACKSTOP: potential price manipulation"");
    uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;

    uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);

    //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return
    uint256 premium = (flanToMint * (growth / 2)) / 100;

    FlanLike(config.flan).mint(address(this), flanToMint + premium);
    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();
    PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);
    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();
  }

  function getMagnitude(address token) internal view returns (uint256) {
    uint256 places = config.decimalPlaces[token];
    return 10**places;
  }

  function normalize(address token, uint256 amount) internal view returns (uint256) {
    uint256 places = config.decimalPlaces[token];
    uint256 bump = 10**(18 - places);
    return amount * bump;
  }
}",1684,129,H-05: Flash loan price manipulation in purchasePyroFlan(). L54,1
123_ConvexMasterChef.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";

/**
 * @title   ConvexMasterChef
 * @author  ConvexFinance
 * @notice  Masterchef can distribute rewards to n pools over x time
 * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,
 *          and thus it can over complicate the distribution of these rewards.
 *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed
 *          pro-rata based on the allocation points in each pool vs the total alloc.
 */
contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; 
        // How many LP tokens the user has provided.
        uint256 rewardDebt; 
        // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of CVXs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; 
        // Address of LP token contract.
        uint256 allocPoint; 
        // How many allocation points assigned to this pool. CVX to distribute per block.
        uint256 lastRewardBlock; 
        // Last block number that CVXs distribution occurs.
        uint256 accCvxPerShare; 
        // Accumulated CVXs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    //cvx
    IERC20 public immutable cvx;
    // CVX tokens created per block.
    uint256 public immutable rewardPerBlock;
    // Bonus muliplier for early cvx makers.
    uint256 public constant BONUS_MULTIPLIER = 2;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when CVX mining starts.
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    // Events
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    // Update the given pool's CVX allocation point. Can only be called by the owner.
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    // View function to see pending CVXs on frontend.
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        //cvx.mint(address(this), cvxReward);
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for CVX allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2679,314,"M-13: ConvexMasterChef: When _lpToken is cvx, reward calculation is incorrect M-15: ConvexMasterChef: safeRewardTransfer can cause loss of funds M-17: ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control M-20: massUpdatePools() is susceptible to DoS with block gas limit. L178 M-21: ConvexMasterChef: When using add() and set(), it should always call massUpdatePools() to update all pools. L96 M-22: Duplicate LP token could lead to incorrect reward distribution. L96",6
62_Locke.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";

// ====== Governance =====
contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    /// Update pending governor
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    /// Accepts governorship
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    /// Remove governor
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    // ====== Modifiers =======
    /// Governed function
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    // ====== Modifiers =======
    /// Governed function
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}

// ====== Stream =====
contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    // ======= Structs ========
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    // ======= Storage ========
    // ==== Immutables =====
    // stream start time
    uint32 private immutable startTime;
    // length of stream
    uint32 private immutable streamDuration;
    // length of time depositTokens are locked after stream ends
    uint32 private immutable depositLockDuration;
    // length of time rewardTokens are locked after stream ends
    uint32 private immutable rewardLockDuration;

    // end of stream
    uint32 private immutable endStream;
    // end of deposit lock
    uint32 private immutable endDepositLock;
    // end of reward lock
    uint32 private immutable endRewardLock;

    // Token given to depositer
    address public immutable rewardToken;
    // Token deposited
    address public immutable depositToken;

    // This stream's id
    uint64 public immutable streamId;

    // fee percent on reward tokens
    uint16 private immutable feePercent;
    // are fees enabled
    bool private immutable feeEnabled;

    // deposits are basically a *sale* to the stream creator if true
    bool public immutable isSale;

    // stream creator
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    // ============

    //  == sloc a ==
    // internal reward token amount to be given to depositors
    uint112 private rewardTokenAmount;
    // internal deposit token amount locked/to be sold to stream creator
    uint112 private depositTokenAmount;
    // ============

    // == slot b ==
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    // ============

    // == slot c ==
    uint256 private cumulativeRewardPerToken;
    // ============

    // == slot d ==
    uint256 private totalVirtualBalance;
    // ============

    // == slot e ==
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    // ============

    // mapping of address to number of tokens not yet streamed over
    mapping (address => TokenStream) public tokensNotYetStreamed;

    // external incentives to stream creator
    mapping (address => uint112) public incentives;

    // ======= Events ========
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    // ======= Modifiers ========
    modifier updateStream(address who) {
        // save bytecode space by making it a jump instead of inlining at cost of gas
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            // set lastUpdates if need be
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            // accumulate reward per token info
            cumulativeRewardPerToken = rewardPerToken();

            // update user rewards
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            // update users last cumulative reward per token
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            // update users unstreamed balance
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                // some time has passed since this user last interacted
                // update ts not yet streamed
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            // handle global unstreamed
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            // stream tokens over
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            // already ensure that blocktimestamp is less than endStream so guaranteed ok here
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) 
        // inherit factory governance
        public 
    {
        // set fee info
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        // limit feePercent
        require(feePercent < 10000, ""fee"");
    
        // store streamParams
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        // set tokens
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        // set streamId
        streamId = _streamId;

        // set sale info
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    /**
     * @dev Returns relevant internal token amounts
    **/
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    /**
     * @dev Returns fee parameters
    **/
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    /**
     * @dev Returns stream parameters
    **/
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        // duration / timeRemaining * amount
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    /**
     * @dev Allows _anyone_ to fund this stream, if its before the stream start time
    **/
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        // transfer from sender
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        // if fee is enabled, take a fee
        if (feeEnabled) {
            // Safety:
            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying
            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112
            //  3. amount is guaranteed to be greater than feeAmt
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            // since this operation can be repeated, we cannot assume no overflow so use checked math
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

    /**
     *  @dev Deposits depositTokens into this stream
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // require(block.timestamp < endStream, ""stake:!stream"");

        // transfer tokens over
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            // not a straight sale, so give the user some receipt tokens
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

    /**
     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,
     *  up to their tokensNotYetStreamed amount
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        // do the transfer
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

    /**
     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed
     *  and burns receiptTokens if its not a sale.
     * 
     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw
    */ 
    function exit() public updateStream(msg.sender) {
        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

    /**
     *  @dev Allows anyone to incentivize this stream with extra tokens
     *  and requires the incentive to not be the reward or deposit token
    */ 
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

    /**
     *  @dev Allows the stream creator to claim an incentive once the stream is done
    */ 
    function claimIncentive(address token) public lock {
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

    /**
     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount
     *  is greater than the requested amount
    */ 
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable
        // we dont need to updateStream(msg.sender)
        require(amount > 0, ""amt"");

        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over
        require(block.timestamp > endDepositLock, ""lock"");

        // burn the receiptTokens
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        // send the receipt token holder back the funds
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

    /**
     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens
    */ 
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        // accumulate reward per token info
        cumulativeRewardPerToken = rewardPerToken();

        // update user rewards
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        // update users last cumulative reward per token
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        // transfer the tokens
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

    /**
     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale
    */ 
    function creatorClaimSoldTokens(address destination) public lock {
        // can only claim when its a sale
        require(isSale, ""!sale"");

        // only can claim once
        require(!claimedDepositTokens, ""claimed"");
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

    /**
     *  @dev Allows the governance contract of the factory to select a destination
     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount
    */ 
    function claimFees(address destination) public lock externallyGoverned {
        // Stream is done
        require(block.timestamp >= endStream, ""stream"");

        // reset fee amount
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            // transfer and emit event
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            // transfer and emit event
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    // ======== Non-protocol functions ========

    /**
     *  @dev Allows the stream creator to save tokens
     *  There are some limitations to this:
     *      1. if its deposit token:
     *          - DepositLock is fully done
     *          - There are excess deposit tokens (balance - depositTokenAmount)
     *      2. if its the reward token:
     *          - RewardLock is fully done
     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)
     *      3. if incentivized:
     *          - excesss defined as bal - incentives[token]
    */ 
    function recoverTokens(address token, address recipient) public lock {
        // NOTE: it is the stream creators responsibility to save
        // tokens on behalf of their users.
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            // get the balance of this contract
            // check what isnt claimable by either party
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            // allow saving of the token
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            // check current balance vs internal balance
            //
            // NOTE: if a token rebases, i.e. changes balance out from under us,
            // most of this contract breaks and rugs depositors. this isn't exclusive
            // to this function but this function would in theory allow someone to rug
            // and recover the excess (if it is worth anything)

            // check what isnt claimable by depositors and governance
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        // not reward token nor deposit nor incentivized token, free to transfer
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    /**
     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee
    */
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        // the `to` contract should have a public function with the signature:
        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; 
        // 10bps fee

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    /**
     *  @dev Allows inherited governance contract to call functions on behalf of this contract
     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances
     *  that may matter are guaranteed to not change.
     * 
     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract
    */
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        // cannot have an active incentive for the callee
        require(incentives[who] == 0, ""inc"");
        // cannot be to deposit token nor reward token
        require(who != depositToken && who != rewardToken, ""erc"");

        // get token balances
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        // require no change in balances
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    // ======= Structs ========
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    // ======= Storage ========
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; 
    // 500/10000 == 5%

    // =======  Events  =======
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    /**
     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract
     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After
     * lockDuration is completed, the depositTokens can be claimed by the original depositors
     * 
    **/
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        // perform checks

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        // DATA VALIDATION:
        //  there is no real concept of ""sane"" limits here, and if misconfigured its ultimated
        //  not a massive deal so no data validation is done
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",6661,860,"H-01: Wrong calculation of excess depositToken allows stream creator to retrieve depositTokenFlashloanFeeAmount, which may cause fund loss to users. L654 H-04: Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets H-05: Possible incentive theft through the arbitraryCall() function H-06: Creating rewardTokens without streaming depositTokens.  L222 H-07: Business logic bug in __abdicate() function - 2 Bugs. L46 H-09: DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max H-10: recoverTokens doesn't work when isSale is true M-02: Any arbitraryCall gathered airdrop can be stolen with recoverTokens M-04: arbitraryCall() can get blocked by an attacker M-05: Storage variable unstreamed can be artificially inflated",10
71_Vault.sol,"pragma solidity 0.8.7;

/**
 * @author InsureDAO
 * @title InsureDAO vault contract
 * @notice
 * SPDX-License-Identifier: GPL-3.0
 */
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/IOwnership.sol"";
import ""./interfaces/IVault.sol"";

import ""./interfaces/IController.sol"";
import ""./interfaces/IRegistry.sol"";

contract Vault is IVault {
    using SafeERC20 for IERC20;

    /**
     * Storage
     */

    address public override token;
    IController public controller;
    IRegistry public registry;
    IOwnership public ownership;

    mapping(address => uint256) public override debts;
    mapping(address => uint256) public attributions;
    uint256 public totalAttributions;

    address public keeper; 
    //keeper can operate utilize(), if address zero, anyone can operate.
    uint256 public balance; 
    //balance of underlying token
    uint256 public totalDebt; 
    //total debt balance. 1debt:1token

    uint256 public constant MAGIC_SCALE_1E6 = 1e6; 
    //internal multiplication scale 1e6 to reduce decimal truncation



    event ControllerSet(address controller);

    modifier onlyOwner() {
        require(
            ownership.owner() == msg.sender,
            ""Restricted: caller is not allowed to operate""
        );
        _;
    }

    modifier onlyMarket() {
        require(
            IRegistry(registry).isListed(msg.sender),
            ""ERROR_ONLY_MARKET""
        );
        _;
    }

    constructor(
        address _token,
        address _registry,
        address _controller,
        address _ownership
    ) {
        require(_token != address(0));
        require(_registry != address(0));
        require(_ownership != address(0));
        //controller can be zero

        token = _token;
        registry = IRegistry(_registry);
        controller = IController(_controller);
        ownership = IOwnership(_ownership);
    }

    /**
     * Vault Functions
     */

    /**
     * @notice A market contract can deposit collateral and get attribution point in return
     * @param  _amount amount of tokens to deposit
     * @param _from sender's address
     * @param _beneficiaries beneficiary's address array
     * @param _shares funds share within beneficiaries (100% = 1e6)
     * @return _allocations attribution amount generated from the transaction
     */
    function addValueBatch(
        uint256 _amount,
        address _from,
        address[2] memory _beneficiaries,
        uint256[2] memory _shares
    ) external override onlyMarket returns (uint256[2] memory _allocations) {
        
        require(_shares[0] + _shares[1] == 1000000, ""ERROR_INCORRECT_SHARE"");

        uint256 _attributions;
        if (totalAttributions == 0) {
            _attributions = _amount;
        } else {
            uint256 _pool = valueAll();
            _attributions = (_amount * totalAttributions) / _pool;
        }
        IERC20(token).safeTransferFrom(_from, address(this), _amount);

        balance += _amount;
        totalAttributions += _attributions;
        for (uint128 i = 0; i < 2; i++) {
            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;
            attributions[_beneficiaries[i]] += _allocation;
            _allocations[i] = _allocation;
        }
    }

    /**
     * @notice A market contract can deposit collateral and get attribution point in return
     * @param  _amount amount of tokens to deposit
     * @param _from sender's address
     * @param _beneficiary beneficiary's address
     * @return _attributions attribution amount generated from the transaction
     */

    function addValue(
        uint256 _amount,
        address _from,
        address _beneficiary
    ) external override onlyMarket returns (uint256 _attributions) {

        if (totalAttributions == 0) {
            _attributions = _amount;
        } else {
            uint256 _pool = valueAll();
            _attributions = (_amount * totalAttributions) / _pool;
        }
        IERC20(token).safeTransferFrom(_from, address(this), _amount);
        balance += _amount;
        totalAttributions += _attributions;
        attributions[_beneficiary] += _attributions;
    }

    /**
     * @notice an address that has balance in the vault can withdraw underlying value
     * @param _amount amount of tokens to withdraw
     * @param _to address to get underlying tokens
     * @return _attributions amount of attributions burnet
     */
    function withdrawValue(uint256 _amount, address _to)
        external
        override
        returns (uint256 _attributions)
    {
        require(
            attributions[msg.sender] > 0 &&
                underlyingValue(msg.sender) >= _amount,
            ""ERROR_WITHDRAW-VALUE_BADCONDITOONS""
        );
        _attributions = (totalAttributions * _amount) / valueAll();

        attributions[msg.sender] -= _attributions;
        totalAttributions -= _attributions;

        if (available() < _amount) {
            //when USDC in this contract isn't enough
            uint256 _shortage = _amount - available();
            _unutilize(_shortage);

            assert(available() >= _amount);
        }

        balance -= _amount;
        IERC20(token).safeTransfer(_to, _amount);
    }

    /**
     * @notice an address that has balance in the vault can transfer underlying value
     * @param _amount sender of value
     * @param _destination reciepient of value
     */

    function transferValue(uint256 _amount, address _destination)
        external
        override
        returns (uint256 _attributions)
    {
        require(
            attributions[msg.sender] > 0 &&
                underlyingValue(msg.sender) >= _amount,
            ""ERROR_TRANSFER-VALUE_BADCONDITOONS""
        );
        _attributions = (_amount * totalAttributions) / valueAll();
        attributions[msg.sender] -= _attributions;
        attributions[_destination] += _attributions;
    }

    /**
     * @notice a registered contract can borrow balance from the vault
     * @param _amount borrow amount
     * @param _to borrower's address
     */
    function borrowValue(uint256 _amount, address _to) external onlyMarket override {
        debts[msg.sender] += _amount;
        totalDebt += _amount;

        IERC20(token).safeTransfer(_to, _amount);
    }

    /**
     * @notice an address that has balance in the vault can offset an address's debt
     * @param _amount debt amount to offset
     * @param _target borrower's address
     */

    function offsetDebt(uint256 _amount, address _target)
        external
        override
        returns (uint256 _attributions)
    {
        require(
            attributions[msg.sender] > 0 &&
                underlyingValue(msg.sender) >= _amount,
            ""ERROR_REPAY_DEBT_BADCONDITOONS""
        );
        _attributions = (_amount * totalAttributions) / valueAll();
        attributions[msg.sender] -= _attributions;
        totalAttributions -= _attributions;
        balance -= _amount;
        debts[_target] -= _amount;
        totalDebt -= _amount;
    }

    /**
     * @notice a registerd market can transfer their debt to system debt
     * @param _amount debt amount to transfer
     * @dev will be called when CDS could not afford when resume the market.
     */
    function transferDebt(uint256 _amount) external onlyMarket override {

        if(_amount != 0){
            debts[msg.sender] -= _amount;
            debts[address(0)] += _amount;
        }
    }

    /**
     * @notice anyone can repay the system debt by sending tokens to this contract
     * @param _amount debt amount to repay
     * @param _target borrower's address
     */
    function repayDebt(uint256 _amount, address _target) external override {
        uint256 _debt = debts[_target];
        if (_debt >= _amount) {
            debts[_target] -= _amount;
            totalDebt -= _amount;
            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);
        } else {
            debts[_target] = 0;
            totalDebt -= _debt;
            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);
        }
    }

    /**
     * @notice an address that has balance in the vault can withdraw value denominated in attribution
     * @param _attribution amount of attribution to burn
     * @param _to beneficiary's address
     * @return _retVal number of tokens withdrawn from the transaction
     */
    function withdrawAttribution(uint256 _attribution, address _to)
        external
        override
        returns (uint256 _retVal)
    {
        _retVal = _withdrawAttribution(_attribution, _to);
    }

    /**
     * @notice an address that has balance in the vault can withdraw all value
     * @param _to beneficiary's address
     * @return _retVal number of tokens withdrawn from the transaction
     */
    function withdrawAllAttribution(address _to)
        external
        override
        returns (uint256 _retVal)
    {
        _retVal = _withdrawAttribution(attributions[msg.sender], _to);
    }

    /**
     * @notice an address that has balance in the vault can withdraw all value
     * @param _attribution amount of attribution to burn
     * @param _to beneficiary's address
     * @return _retVal number of tokens withdrawn from the transaction
     */
    function _withdrawAttribution(uint256 _attribution, address _to)
        internal
        returns (uint256 _retVal)
    {
        require(
            attributions[msg.sender] >= _attribution,
            ""ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS""
        );
        _retVal = (_attribution * valueAll()) / totalAttributions;

        attributions[msg.sender] -= _attribution;
        totalAttributions -= _attribution;

        if (available() < _retVal) {
            uint256 _shortage = _retVal - available();
            _unutilize(_shortage);
        }

        balance -= _retVal;
        IERC20(token).safeTransfer(_to, _retVal);
    }

    /**
     * @notice an address that has balance in the vault can transfer value denominated in attribution
     * @param _amount amount of attribution to transfer
     * @param _destination reciepient of attribution
     */
    function transferAttribution(uint256 _amount, address _destination)
        external
        override
    {
        require(_destination != address(0), ""ERROR_ZERO_ADDRESS"");

        require(
            _amount != 0 && attributions[msg.sender] >= _amount,
            ""ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS""
        );

        attributions[msg.sender] -= _amount;
        attributions[_destination] += _amount;
    }

    /**
     * @notice the controller can utilize all available stored funds
     * @return _amount amount of tokens utilized
     */
    function utilize() external override returns (uint256 _amount) {
        if (keeper != address(0)) {
            require(msg.sender == keeper, ""ERROR_NOT_KEEPER"");
        }
        _amount = available(); 
        //balance
        if (_amount > 0) {
            IERC20(token).safeTransfer(address(controller), _amount);
            balance -= _amount;
            controller.earn(address(token), _amount);
        }
    }

    /**
     * @notice get attribution number for the specified address
     * @param _target target address
     * @return amount of attritbution
     */

    function attributionOf(address _target)
        external
        view
        override
        returns (uint256)
    {
        return attributions[_target];
    }

    /**
     * @notice get all attribution number for this contract
     * @return amount of all attribution
     */
    function attributionAll() external view returns (uint256) {
        return totalAttributions;
    }

    /**
     * @notice Convert attribution number into underlying assset value
     * @param _attribution amount of attribution
     * @return token value of input attribution
     */
    function attributionValue(uint256 _attribution)
        external
        view
        override
        returns (uint256)
    {
        if (totalAttributions > 0 && _attribution > 0) {
            return (_attribution * valueAll()) / totalAttributions;
        } else {
            return 0;
        }
    }

    /**
     * @notice return underlying value of the specified address
     * @param _target target address
     * @return token value of target address
     */
    function underlyingValue(address _target)
        public
        view
        override
        returns (uint256)
    {
        if (attributions[_target] > 0) {
            return (valueAll() * attributions[_target]) / totalAttributions;
        } else {
            return 0;
        }
    }

    /**
     * @notice return underlying value of this contract
     * @return all token value of the vault
     */
    function valueAll() public view returns (uint256) {
        if (address(controller) != address(0)) {
            return balance + controller.valueAll();
        } else {
            return balance;
        }
    }

    /**
     * @notice internal function to unutilize the funds and keep utilization rate
     * @param _amount amount to withdraw from controller
     */
    function _unutilize(uint256 _amount) internal {
        require(address(controller) != address(0), ""ERROR_CONTROLLER_NOT_SET"");

        controller.withdraw(address(this), _amount);
        balance += _amount;
    }

    /**
     * @notice return how much funds in this contract is available to be utilized
     * @return available balance to utilize
     */
    function available() public view returns (uint256) {
        return balance - totalDebt;
    }

    /**
     * @notice return how much price for each attribution
     * @return value of one share of attribution
     */
    function getPricePerFullShare() public view returns (uint256) {
        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;
    }

    /**
     * onlyOwner
     */

    /**
     * @notice withdraw redundant token stored in this contract
     * @param _token token address
     * @param _to beneficiary's address
     */
    function withdrawRedundant(address _token, address _to)
        external
        override
        onlyOwner
    {
        if (
            _token == address(token) &&
            balance < IERC20(token).balanceOf(address(this))
        ) {
            uint256 _redundant = IERC20(token).balanceOf(address(this)) -
                balance;
            IERC20(token).safeTransfer(_to, _redundant);
        } else if (IERC20(_token).balanceOf(address(this)) > 0) {
            IERC20(_token).safeTransfer(
                _to,
                IERC20(_token).balanceOf(address(this))
            );
        }
    }

    /**
     * @notice admin function to set controller address
     * @param _controller address of the controller
     */
    function setController(address _controller) public override onlyOwner {
        require(_controller != address(0), ""ERROR_ZERO_ADDRESS"");

        if (address(controller) != address(0)) {
            controller.migrate(address(_controller));
            controller = IController(_controller);
        } else {
            controller = IController(_controller);
        }

        emit ControllerSet(_controller);
    }

    /**
     * @notice the controller can utilize all available stored funds
     * @param _keeper keeper address
     */
    function setKeeper(address _keeper) external override onlyOwner {
        if (keeper != _keeper) {
            keeper = _keeper;
        }
    }
}",3531,513,"H-01: Tokens can be burned with no access control  L382 H-03: Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts H-05: backdoor in withdrawRedundant H-07: Wrong design/implementation of permission control allows malicious/compromised Registry or Factory admin to steal funds from users' wallet balances. L52 H-09: Vault#setController() owner of the Vault contracts can drain funds from the Vault H-10: A malicious/compromised Registry or Factory admin can drain all the funds from the Vault contracts M-01: repayDebt in Vault.sol could DOS functionality for markets M-05: Vault.sol Tokens with fee on transfer are not supported",8
31_veCVXStrategy.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;
pragma experimental ABIEncoderV2;

import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";

import ""../interfaces/uniswap/IUniswapRouterV2.sol"";
import ""../interfaces/badger/ISettV3.sol"";
import ""../interfaces/badger/IController.sol"";
import ""../interfaces/cvx/ICvxLocker.sol"";
import ""../interfaces/snapshot/IDelegateRegistry.sol"";

import {BaseStrategy} from ""../deps/BaseStrategy.sol"";

contract MyStrategy is BaseStrategy {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    uint256 MAX_BPS = 10_000;

    // address public want // Inherited from BaseStrategy, the token the strategy wants, swaps into and tries to grow
    address public lpComponent; 
    // Token we provide liquidity with
    address public reward;
     // Token we farm and swap to want / lpComponent
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;

    address public constant SUSHI_ROUTER =
        0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;

    IDelegateRegistry public constant SNAPSHOT =
        IDelegateRegistry(0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446);

    // The address this strategies delegates voting to
    address public constant DELEGATE =
        0xB65cef03b9B89f99517643226d76e286ee999e77;

    bytes32 public constant DELEGATED_SPACE =
        0x6376782e65746800000000000000000000000000000000000000000000000000;

    ICvxLocker public LOCKER;

    ISettV3 public CVX_VAULT =
        ISettV3(0x53C8E199eb2Cb7c01543C137078a038937a68E40);

    bool public withdrawalSafetyCheck = true;
    bool public harvestOnRebalance = true;
    // If nothing is unlocked, processExpiredLocks will revert
    bool public processLocksOnReinvest = true;
    bool public processLocksOnRebalance = true;

    event Debug(string name, uint256 value);

    // Used to signal to the Badger Tree that rewards where sent to it
    event TreeDistribution(
        address indexed token,
        uint256 amount,
        uint256 indexed blockNumber,
        uint256 timestamp
    );

    function initialize(
        address _governance,
        address _strategist,
        address _controller,
        address _keeper,
        address _guardian,
        address[3] memory _wantConfig,
        uint256[3] memory _feeConfig,
        address _locker 
        ///@dev TODO: Add this to deploy
    ) public initializer {
        __BaseStrategy_init(
            _governance,
            _strategist,
            _controller,
            _keeper,
            _guardian
        );

        /// @dev Add config here
        want = _wantConfig[0];
        lpComponent = _wantConfig[1];
        reward = _wantConfig[2];

        performanceFeeGovernance = _feeConfig[0];
        performanceFeeStrategist = _feeConfig[1];
        withdrawalFee = _feeConfig[2];

        LOCKER = ICvxLocker(_locker); 
        //TODO: Make locker hardcoded at top of file

        /// @dev do one off approvals here
        // IERC20Upgradeable(want).safeApprove(gauge, type(uint256).max);
        // Permissions for Locker
        IERC20Upgradeable(CVX).safeApprove(_locker, type(uint256).max);
        IERC20Upgradeable(CVX).safeApprove(
            address(CVX_VAULT),
            type(uint256).max
        );

        // Permissions for Sushiswap
        IERC20Upgradeable(reward).safeApprove(SUSHI_ROUTER, type(uint256).max);

        // Delegate voting to DELEGATE
        SNAPSHOT.setDelegate(DELEGATED_SPACE, DELEGATE);
    }

    /// ===== Extra Functions =====
    ///@dev Should we check if the amount requested is more than what we can return on withdrawal?
    function setWithdrawalSafetyCheck(bool newWithdrawalSafetyCheck) public {
        _onlyGovernance();
        withdrawalSafetyCheck = newWithdrawalSafetyCheck;
    }

    ///@dev Should we harvest before doing manual rebalancing
    ///@notice you most likely want to skip harvest if everything is unlocked, or there's something wrong and you just want out
    function setHarvestOnRebalance(bool newHarvestOnRebalance) public {
        _onlyGovernance();
        harvestOnRebalance = newHarvestOnRebalance;
    }

    ///@dev Should we processExpiredLocks during reinvest?
    function setProcessLocksOnReinvest(bool newProcessLocksOnReinvest) public {
        _onlyGovernance();
        processLocksOnReinvest = newProcessLocksOnReinvest;
    }

    ///@dev Should we processExpiredLocks during manualRebalance?
    function setProcessLocksOnRebalance(bool newProcessLocksOnRebalance)
        public
    {
        _onlyGovernance();
        processLocksOnRebalance = newProcessLocksOnRebalance;
    }

    /// ===== View Functions =====

    /// @dev Specify the name of the strategy
    function getName() external pure override returns (string memory) {
        return ""veCVX Voting Strategy"";
    }

    /// @dev Specify the version of the Strategy, for upgrades
    function version() external pure returns (string memory) {
        return ""1.0"";
    }

    /// @dev From CVX Token to Helper Vault Token
    function CVXToWant(uint256 cvx) public view returns (uint256) {
        uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();
        return cvx.mul(10**18).div(bCVXToCVX);
    }

    /// @dev From Helper Vault Token to CVX Token
    function wantToCVX(uint256 want) public view returns (uint256) {
        uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();
        return want.mul(bCVXToCVX).div(10**18);
    }

    /// @dev Balance of want currently held in strategy positions
    function balanceOfPool() public view override returns (uint256) {
        if (withdrawalSafetyCheck) {
            uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); 
            // 18 decimals
            require(bCVXToCVX > 10**18, ""Loss Of Peg""); 
            // Avoid trying to redeem for less / loss of peg
        }

        // Return the balance in locker + unlocked but not withdrawn, better estimate to allow some withdrawals
        // then multiply it by the price per share as we need to convert CVX to bCVX
        uint256 valueInLocker =
            CVXToWant(LOCKER.lockedBalanceOf(address(this))).add(
                CVXToWant(IERC20Upgradeable(CVX).balanceOf(address(this)))
            );

        return (valueInLocker);
    }

    /// @dev Returns true if this strategy requires tending
    function isTendable() public view override returns (bool) {
        return false;
    }

    // @dev These are the tokens that cannot be moved except by the vault
    function getProtectedTokens()
        public
        view
        override
        returns (address[] memory)
    {
        address[] memory protectedTokens = new address[](4);
        protectedTokens[0] = want;
        protectedTokens[1] = lpComponent;
        protectedTokens[2] = reward;
        protectedTokens[3] = CVX;
        return protectedTokens;
    }

    /// ===== Permissioned Actions: Governance =====
    /// @notice Delete if you don't need!
    function setKeepReward(uint256 _setKeepReward) external {
        _onlyGovernance();
    }

    /// ===== Internal Core Implementations =====

    /// @dev security check to avoid moving tokens that would cause a rugpull, edit based on strat
    function _onlyNotProtectedTokens(address _asset) internal override {
        address[] memory protectedTokens = getProtectedTokens();

        for (uint256 x = 0; x < protectedTokens.length; x++) {
            require(
                address(protectedTokens[x]) != _asset,
                ""Asset is protected""
            );
        }
    }

    /// @dev invest the amount of want
    /// @notice When this function is called, the controller has already sent want to this
    /// @notice Just get the current balance and then invest accordingly
    function _deposit(uint256 _amount) internal override {
        // We receive bCVX -> Convert to bCVX
        CVX_VAULT.withdraw(_amount);

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));

        // Lock tokens for 17 weeks, send credit to strat, always use max boost cause why not?
        LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());
    }

    /// @dev utility function to convert all we can to bCVX
    /// @notice You may want to harvest before calling this to maximize the amount of bCVX you'll have
    function prepareWithdrawAll() external {
        _onlyGovernance();

        LOCKER.processExpiredLocks(false);

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }

    /// @dev utility function to withdraw everything for migration
    /// @dev NOTE: You cannot call this unless you have rebalanced to have only bCVX left in the vault
    function _withdrawAll() internal override {
        //NOTE: This probably will always fail unless we have all tokens expired
        require(
            LOCKER.lockedBalanceOf(address(this)) == 0 &&
                LOCKER.balanceOf(address(this)) == 0,
            ""You have to wait for unlock and have to manually rebalance out of it""
        );

        // NO-OP because you can't deposit AND transfer with bCVX
        // See prepareWithdrawAll above
    }

    /// @dev withdraw the specified amount of want, liquidate from lpComponent to want, paying off any necessary debt for the conversion
    function _withdrawSome(uint256 _amount)
        internal
        override
        returns (uint256)
    {
        uint256 max = IERC20Upgradeable(want).balanceOf(address(this));

        if (withdrawalSafetyCheck) {
            uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); 
            // 18 decimals
            require(bCVXToCVX > 10**18, ""Loss Of Peg""); 
            // Avoid trying to redeem for less / loss of peg
            require(
                max >= _amount.mul(9_980).div(MAX_BPS),
                ""Withdrawal Safety Check""
            ); 
            // 20 BP of slippage
        }

        if (max < _amount) {
            return max;
        }

        return _amount;
    }

    /// @dev Harvest from strategy mechanics, realizing increase in underlying position
    function harvest() public whenNotPaused returns (uint256 harvested) {
        _onlyAuthorizedActors();

        uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));

        uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));

        // Get cvxCRV
        LOCKER.getReward(address(this), false);

        // Rewards Math
        uint256 earnedReward =
            IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);

        // Because we are using bCVX we take fees in reward
        //NOTE: This will probably revert because we deposit and transfer on same block
        (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =
            _processRewardsFees(earnedReward, reward);

        // Swap cvxCRV for want (bCVX)
        _swapcvxCRVToWant();

        uint256 earned =
            IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);

        /// @dev Harvest event that every strategy MUST have, see BaseStrategy
        emit Harvest(earned, block.number);

        /// @dev Harvest must return the amount of want increased
        return earned;
    }

    /// @dev Rebalance, Compound or Pay off debt here
    function tend() external whenNotPaused {
        _onlyAuthorizedActors();
        revert(); 
        // NOTE: For now tend is replaced by manualRebalance
    }

    /// @dev Swap from reward to CVX, then deposit into bCVX vault
    function _swapcvxCRVToWant() internal {
        uint256 toSwap = IERC20Upgradeable(reward).balanceOf(address(this));

        if (toSwap == 0) {
            return;
        }

        // Sushi reward to WETH to want
        address[] memory path = new address[](3);
        path[0] = reward;
        path[1] = WETH;
        path[2] = CVX;
        IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(
            toSwap,
            0,
            path,
            address(this),
            now
        );

        // Deposit into vault
        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }

    /// ===== Internal Helper Functions =====

    /// @dev used to manage the governance and strategist fee, make sure to use it to get paid!
    function _processPerformanceFees(uint256 _amount)
        internal
        returns (
            uint256 governancePerformanceFee,
            uint256 strategistPerformanceFee
        )
    {
        governancePerformanceFee = _processFee(
            want,
            _amount,
            performanceFeeGovernance,
            IController(controller).rewards()
        );

        strategistPerformanceFee = _processFee(
            want,
            _amount,
            performanceFeeStrategist,
            strategist
        );
    }

    /// @dev used to manage the governance and strategist fee on earned rewards, make sure to use it to get paid!
    function _processRewardsFees(uint256 _amount, address _token)
        internal
        returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)
    {
        governanceRewardsFee = _processFee(
            _token,
            _amount,
            performanceFeeGovernance,
            IController(controller).rewards()
        );

        strategistRewardsFee = _processFee(
            _token,
            _amount,
            performanceFeeStrategist,
            strategist
        );
    }

    /// MANUAL FUNCTIONS ///

    /// @dev manual function to reinvest all CVX that was locked
    function reinvest() external whenNotPaused returns (uint256 reinvested) {
        _onlyGovernance();

        if (processLocksOnReinvest) {
            // Withdraw all we can
            LOCKER.processExpiredLocks(false);
        }

        // Redeposit all into veCVX
        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));

        // Redeposit into veCVX
        LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());
    }

    /// @dev process all locks, to redeem
    function manualProcessExpiredLocks() external whenNotPaused {
        _onlyGovernance();
        LOCKER.processExpiredLocks(false);
        // Unlock veCVX that is expired and redeem CVX back to this strat
        // Processed in the next harvest or during prepareMigrateAll
    }

    /// @dev Take all CVX and deposits in the CVX_VAULT
    function manualDepositCVXIntoVault() external whenNotPaused {
        _onlyGovernance();

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }

    /// @dev Send all available bCVX to the Vault
    /// @notice you can do this so you can earn again (re-lock), or just to add to the redemption pool
    function manualSendbCVXToVault() external whenNotPaused {
        _onlyGovernance();
        uint256 bCvxAmount = IERC20Upgradeable(want).balanceOf(address(this));
        _transferToVault(bCvxAmount);
    }

    /// @dev use the currently available CVX to either lock or add to bCVX
    /// @notice toLock = 0, lock nothing, deposit in bCVX as much as you can
    /// @notice toLock = 100, lock everything (CVX) you have
    function manualRebalance(uint256 toLock) external whenNotPaused {
        _onlyGovernance();
        require(toLock <= MAX_BPS, ""Max is 100%"");

        if (processLocksOnRebalance) {
            // manualRebalance will revert if you have no expired locks
            LOCKER.processExpiredLocks(false);
        }

        if (harvestOnRebalance) {
            harvest();
        }

        // Token that is highly liquid
        uint256 balanceOfWant =
            IERC20Upgradeable(want).balanceOf(address(this));
        // CVX uninvested we got from harvest and unlocks
        uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));
        // Locked CVX in the locker
        uint256 balanceInLock = LOCKER.balanceOf(address(this));
        uint256 totalCVXBalance =
            balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));

        //Ratios
        uint256 currentLockRatio =
            balanceInLock.mul(10**18).div(totalCVXBalance);
        // Amount we want to have in lock
        uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);
        // Amount we want to have in bCVX
        uint256 toWantRatio =
            totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);

        // We can't unlock enough, just deposit rest into bCVX
        if (newLockRatio <= currentLockRatio) {
            // Deposit into vault
            uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
            if (toDeposit > 0) {
                CVX_VAULT.deposit(toDeposit);
            }

            return;
        }

        // If we're continuing, then we are going to lock something (unless it's zero)
        uint256 cvxToLock = newLockRatio.sub(currentLockRatio);

        // NOTE: We only lock the CVX we have and not the bCVX
        // bCVX should be sent back to vault and then go through earn
        // We do this because bCVX has ""blockLock"" and we can't both deposit and withdraw on the same block
        uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (cvxToLock > maxCVX) {
            // Just lock what we can
            LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());
        } else {
            // Lock proper
            LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());
        }

        // If anything else is left, deposit into vault
        uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (cvxLeft > 0) {
            CVX_VAULT.deposit(cvxLeft);
        }
        // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat
    }
}",4510,520,H-01: veCVXStrategy.manualRebalance has wrong logic,1
14_IdleYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./access/AssetManager.sol"";

/// @title An pooltogether yield source for Idle token
/// @author Sunny Radadiya
contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public constant ONE_IDLE_TOKEN = 10**18;

    /// @notice Emitted when the yield source is initialized
    event IdleYieldSourceInitialized(address indexed idleToken);

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    /// @notice Initializes the yield source with Idle Token
    /// @param _idleToken Idle Token address
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() external view override returns (address) {
        return underlyingAsset;
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Calculates the balance of Total idle Tokens Contract hasv
    /// @return balance of Idle Tokens
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw
    /// @param tokens Amount of tokens
    /// return Number of shares
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        shares = (tokens * ONE_IDLE_TOKEN) / _price();
    }

    /// @notice Calculates the number of tokens a user has in the yield source
    /// @param shares Amount of shares
    /// return Number of tokens
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        tokens = (shares * _price()) / ONE_IDLE_TOKEN;
    }

    /// @notice Calculates the current price per share
    /// @return avg idleToken price for this contract
    function _price() internal view returns (uint256) {
      return IIdleToken(idleToken).tokenPriceWithFee(address(this));
    }

    /// @notice Deposit asset tokens to Idle
    /// @param mintAmount The amount of asset tokens to be deposited
    /// @return number of minted tokens
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        return IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param mintAmount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 mintAmount, address to) external nonReentrant override {
        uint256 mintedTokenShares = _tokenToShares(mintAmount);
        _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.
    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return redeemedUnderlyingAsset The actual amount of tokens that were redeemed.
    function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {
        uint256 redeemedShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, redeemedShare);
        redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);        
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);
    }

    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address
    /// @dev This function is only callable by the owner or asset manager
    /// @param erc20Token The ERC20 token to transfer
    /// @param to The recipient of the tokens
    /// @param amount The amount of tokens to transfer
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(erc20Token != idleToken, ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1516,154,"H-01: User could lose underlying tokens when redeeming from the IdleYieldSource H-05: IdleYieldSource doesn't use mantissa calculations M-03: SafeMath not completely used in yield source contracts L91",3
69_NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
      // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",5810,615,"H-01: buyAndSwap1155WETH() function may cause loss of user assets H-03: A vault can be locked from MarketplaceZap and StakingZap M-03: NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to M-04: NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address M-05: buyAndSwap1155WETH Does Not Work As Intended. L284",5
26_RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;

    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public override orderbook;
    /// @dev leaderboard instance
    IRCLeaderboard public override leaderboard;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev the Factory so only the Factory can add new markets
    IRCFactory public override factory;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public override marketBalance;
    /// @dev a quick check if a user is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 public override marketBalanceTopup;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;


    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    /// @dev intended for beta use only, will be disabled after launch
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    /// @dev allow markets to be restricted to a certain role
    mapping(address => bytes32) public marketWhitelist;

 
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent, claim or upgrade any cards for specific market
    mapping(address => bool) public override marketPaused;
    /// @dev if true, owner has locked the market pause (Governors are locked out)
    mapping(address => bool) public override lockMarketPaused;

    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");


    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);



    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        // initialise adjustable parameters
        setMinRental(24 * 6); 
        // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1_000_000 ether); 
        // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }


    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks() {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }


    /// @dev all functions should be onlyRole(OWNER)
    // min rental event emitted by market. Nothing else need be emitted.


    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @dev this is only a soft check, it is possible to exceed this limit
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }


    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }


    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add/Remove multiple users to the whitelist
    /// @param _users an array of users to add or remove
    /// @param add true to add the users
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    /// @notice Some markets may be restricted to certain roles,
    /// @notice This function checks if the user has the role requried for a given market
    /// @dev Used for the markets to check themselves
    /// @param _user The user to check
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        // factory is also an OWNER and GOVERNOR to use the proxy functions
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised
        erc20.safeTransfer(msg.sender, _balance);
    }

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        assessForeclosure(_user);
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // step 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        // do some cleaning up first, it might help avoid their foreclosure
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            // foreclose user, this is requred to remove them from the orderbook
            isForeclosed[_msgSender] = true;
            // remove them from the orderbook
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }


    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        /// @dev return the amount just incase it was adjusted
        return _amount;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        // update the last rental time
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        // check if this is their first rental (no previous rental calculation)
        if (user[_user].lastRentCalc == 0) {
            // we need to start their clock ticking, update their last rental calculation time
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }


    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice provides the sum total of a users bids across all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }


    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                // they have enough funds, just collect the extra
                // we can be sure of this because it was checked they can cover the minimum rental
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    // send an event for the UI to have a timestamp
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }


    /// @notice returns the rent due between the users last rent calculation and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calculates the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                // calculate how long they can own the new card for
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    // new bid is after user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    // new bid is before user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    // The user couldn't afford to own the new card up to their last
                    // .. rent calculation, we can't rewind their rent calculation because
                    // .. of gas limits (there could be many markets having taken rent).
                    // Therefore unfortunately we can't give any ownership to this user as
                    // .. this could mean getting caught in a loop we may not be able to
                    // .. exit because of gas limits (there could be many users in this
                    // .. situation and we can't leave any unaccounted for).
                    // This means we return 0 to signify that the user can't afford this
                    // .. new ownership.
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                // if no rentals they'll foreclose after the heat death of the universe
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepositLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets available balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    /// @notice checks if the user should still be foreclosed
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }
}",7484,853,"M-01: Uninitialized Variable marketWhitelist in RCTreasury.sol M-03: Deposits don't work with fee-on transfer tokens ",2
36_Basket.sol,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { ERC20Upgradeable } from ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import './interfaces/IAuction.sol';
import ""./interfaces/IBasket.sol"";
import ""./interfaces/IFactory.sol"";
import ""hardhat/console.sol"";

contract Basket is IBasket, ERC20Upgradeable {
    using SafeERC20 for IERC20;

    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; 
    // 1 day
    uint256 public constant ONE_YEAR = 365.25 days;
    uint256 private constant BASE = 1e18;

    address public publisher;
    uint256 public licenseFee;

    IFactory public override factory;
    IAuction public override auction;

    uint256 public override ibRatio;

    PendingPublisher public pendingPublisher;
    PendingLicenseFee public pendingLicenseFee;
    PendingWeights public pendingWeights;

    address[] public tokens;
    uint256[] public weights;

    uint256 public override lastFee;

    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {
        publisher = proposal.proposer;
        licenseFee = proposal.licenseFee;
        factory = IFactory(msg.sender);
        auction = auction_;
        ibRatio = BASE;
        tokens = proposal.tokens;
        weights = proposal.weights;
        approveUnderlying(address(auction));

        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);
    }

    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {
        return (pendingWeights.tokens, pendingWeights.weights);
    }

    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {
        require(_tokens.length == _weights.length);
        uint256 length = _tokens.length;
        address[] memory tokenList = new address[](length);

        // check uniqueness of tokens and not token(0)

        for (uint i = 0; i < length; i++) {
            require(_tokens[i] != address(0));
            require(_weights[i] > 0);

            for (uint256 x = 0; x < tokenList.length; x++) {
                require(_tokens[i] != tokenList[x]);
            }

            tokenList[i] = _tokens[i];
        }
    }

    function mint(uint256 amount) public override {
        mintTo(amount, msg.sender);
    }

    function mintTo(uint256 amount, address to) public override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);

        handleFees();

        pullUnderlying(amount, msg.sender);

        _mint(to, amount);

        emit Minted(to, amount);
    }

    function burn(uint256 amount) public override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);
        require(balanceOf(msg.sender) >= amount);

        handleFees();

        pushUnderlying(amount, msg.sender);
        _burn(msg.sender, amount);
        
        emit Burned(msg.sender, amount);
    }

    function auctionBurn(uint256 amount) onlyAuction external override {
        handleFees();

        _burn(msg.sender, amount);

        emit Burned(msg.sender, amount);
    }

    function handleFees() private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else {
            uint256 startSupply = totalSupply();

            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);

            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }

    // changes publisher
    // timelocked
    function changePublisher(address newPublisher) onlyPublisher public override {
        require(newPublisher != address(0));

        if (pendingPublisher.publisher != address(0)) {
            require(pendingPublisher.publisher == newPublisher);
            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);
            publisher = pendingPublisher.publisher;

            pendingPublisher.publisher = address(0);

            emit ChangedPublisher(publisher);
        } else {
            pendingPublisher.publisher = newPublisher;
            pendingPublisher.block = block.number;
        }
    }

    //changes licenseFee
    // timelocked
    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {
        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);
        if (pendingLicenseFee.licenseFee != 0) {
            require(pendingLicenseFee.licenseFee == newLicenseFee);
            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);
            licenseFee = pendingLicenseFee.licenseFee;

            pendingLicenseFee.licenseFee = 0;

            emit ChangedLicenseFee(licenseFee);
        } else {
            pendingLicenseFee.licenseFee = newLicenseFee;
            pendingLicenseFee.block = block.number;
        }
    }

    // publish new index
    // timelocked
    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {
        validateWeights(_tokens, _weights);

        if (pendingWeights.pending) {
            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);
            if (auction.auctionOngoing() == false) {
                auction.startAuction();

                emit PublishedNewIndex(publisher);
            } else if (auction.hasBonded()) {

            } else {
                auction.killAuction();

                pendingWeights.tokens = _tokens;
                pendingWeights.weights = _weights;
                pendingWeights.block = block.number;
            }
        } else {
            pendingWeights.pending = true;
            pendingWeights.tokens = _tokens;
            pendingWeights.weights = _weights;
            pendingWeights.block = block.number;
        }
    }

    function setNewWeights() onlyAuction external override {
        tokens = pendingWeights.tokens;
        weights = pendingWeights.weights;
        pendingWeights.pending = false;

        approveUnderlying(address(auction));

        emit WeightsSet();
    }

    // delete pending index
    function deleteNewIndex() public override {
        require(msg.sender == publisher || msg.sender == address(auction));
        require(auction.auctionOngoing() == false);

        pendingWeights.pending = false;

        emit DeletedNewIndex(publisher);
    }

    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {
        ibRatio = newRatio;

        emit NewIBRatio(ibRatio);

        return ibRatio;
    }

    function approveUnderlying(address spender) private {
        for (uint256 i = 0; i < weights.length; i++) {
            IERC20(tokens[i]).approve(spender, type(uint256).max);
        }
    }

    function pushUnderlying(uint256 amount, address to) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransfer(to, tokenAmount);
        }
    }

    function pullUnderlying(uint256 amount, address from) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);
        }
    }

    modifier onlyAuction() {
        require(msg.sender == address(auction));
        _;
    }

    modifier onlyPublisher() {
        require(msg.sender == address(publisher));
        _;
    }
}",1741,254,"H-01: Re-entrancy in settleAuction allow stealing all funds H-02: Basket.sol#auctionBurn() A failed auction will freeze part of the funds M-03: onlyOwner Role Can Unintentionally Influence settleAuction()  L39 M-05: Bonding mechanism allows malicious user to DOS auctions. L170 M-09: Fee calculation is potentially incorrect. L118 M-14: Basket.sol#handleFees() could potentially cause disruption of minting and burning. L110 M-17: Unsafe approve would halt the auction and burn the bond. L224 M-18: licenseFee can be greater than BASE  L118",8
193_Pair.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""solmate/tokens/ERC20.sol"";
import ""solmate/tokens/ERC721.sol"";
import ""solmate/utils/MerkleProofLib.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""openzeppelin/utils/math/Math.sol"";

import ""./LpToken.sol"";
import ""./Caviar.sol"";

/// @title Pair
/// @author out.eth (@outdoteth)
/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.
contract Pair is ERC20, ERC721TokenReceiver {
    using SafeTransferLib for address;
    using SafeTransferLib for ERC20;

    uint256 public constant ONE = 1e18;
    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;

    address public immutable nft;
    address public immutable baseToken; 
    // address(0) for ETH
    bytes32 public immutable merkleRoot;
    LpToken public immutable lpToken;
    Caviar public immutable caviar;
    uint256 public closeTimestamp;

    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);
    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);
    event Buy(uint256 inputAmount, uint256 outputAmount);
    event Sell(uint256 inputAmount, uint256 outputAmount);
    event Wrap(uint256[] tokenIds);
    event Unwrap(uint256[] tokenIds);
    event Close(uint256 closeTimestamp);
    event Withdraw(uint256 tokenId);

    constructor(
        address _nft,
        address _baseToken,
        bytes32 _merkleRoot,
        string memory pairSymbol,
        string memory nftName,
        string memory nftSymbol
    ) ERC20(string.concat(nftName, "" fractional token""), string.concat(""f"", nftSymbol), 18) {
        nft = _nft;
        baseToken = _baseToken; 
        // use address(0) for native ETH
        merkleRoot = _merkleRoot;
        lpToken = new LpToken(pairSymbol);
        caviar = Caviar(msg.sender);
    }

    // ************************ //
    //      Core AMM logic      //
    // ***********************  //

    /// @notice Adds liquidity to the pair.
    /// @param baseTokenAmount The amount of base tokens to add.
    /// @param fractionalTokenAmount The amount of fractional tokens to add.
    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.
    /// @return lpTokenAmount The amount of LP tokens minted.
    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)
        public
        payable
        returns (uint256 lpTokenAmount)
    {
        // *** Checks *** //

        // check the token amount inputs are not zero
        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, ""Input token amount is zero"");

        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, ""Invalid ether input"");

        // calculate the lp token shares to mint
        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);

        // check that the amount of lp tokens outputted is greater than the min amount
        require(lpTokenAmount >= minLpTokenAmount, ""Slippage: lp token amount out"");

        // *** Effects *** //

        // transfer fractional tokens in
        _transferFrom(msg.sender, address(this), fractionalTokenAmount);

        // *** Interactions *** //

        // mint lp tokens to sender
        lpToken.mint(msg.sender, lpTokenAmount);

        // transfer base tokens in if the base token is not ETH
        if (baseToken != address(0)) {
            // transfer base tokens in
            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);
        }

        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);
    }

    /// @notice Removes liquidity from the pair.
    /// @param lpTokenAmount The amount of LP tokens to burn.
    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.
    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.
    /// @return baseTokenOutputAmount The amount of base tokens received.
    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.
    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)
        public
        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)
    {
        // *** Checks *** //

        // calculate the output amounts
        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);

        // check that the base token output amount is greater than the min amount
        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, ""Slippage: base token amount out"");

        // check that the fractional token output amount is greater than the min amount
        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, ""Slippage: fractional token out"");

        // *** Effects *** //

        // transfer fractional tokens to sender
        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);

        // *** Interactions *** //

        // burn lp tokens from sender
        lpToken.burn(msg.sender, lpTokenAmount);

        if (baseToken == address(0)) {
            // if base token is native ETH then send ether to sender
            msg.sender.safeTransferETH(baseTokenOutputAmount);
        } else {
            // transfer base tokens to sender
            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);
        }

        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);
    }

    /// @notice Buys fractional tokens from the pair.
    /// @param outputAmount The amount of fractional tokens to buy.
    /// @param maxInputAmount The maximum amount of base tokens to spend.
    /// @return inputAmount The amount of base tokens spent.
    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {
        // *** Checks *** //

        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, ""Invalid ether input"");

        // calculate required input amount using xyk invariant
        inputAmount = buyQuote(outputAmount);

        // check that the required amount of base tokens is less than the max amount
        require(inputAmount <= maxInputAmount, ""Slippage: amount in"");

        // *** Effects *** //

        // transfer fractional tokens to sender
        _transferFrom(address(this), msg.sender, outputAmount);

        // *** Interactions *** //

        if (baseToken == address(0)) {
            // refund surplus eth
            uint256 refundAmount = maxInputAmount - inputAmount;
            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);
        } else {
            // transfer base tokens in
            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);
        }

        emit Buy(inputAmount, outputAmount);
    }

    /// @notice Sells fractional tokens to the pair.
    /// @param inputAmount The amount of fractional tokens to sell.
    /// @param minOutputAmount The minimum amount of base tokens to receive.
    /// @return outputAmount The amount of base tokens received.
    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {
        // *** Checks *** //

        // calculate output amount using xyk invariant
        outputAmount = sellQuote(inputAmount);

        // check that the outputted amount of fractional tokens is greater than the min amount
        require(outputAmount >= minOutputAmount, ""Slippage: amount out"");

        // *** Effects *** //

        // transfer fractional tokens from sender
        _transferFrom(msg.sender, address(this), inputAmount);

        // *** Interactions *** //

        if (baseToken == address(0)) {
            // transfer ether out
            msg.sender.safeTransferETH(outputAmount);
        } else {
            // transfer base tokens out
            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);
        }

        emit Sell(inputAmount, outputAmount);
    }

    // ******************** //
    //      Wrap logic      //
    // ******************** //

    /// @notice Wraps NFTs into fractional tokens.
    /// @param tokenIds The ids of the NFTs to wrap.
    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.
    /// @return fractionalTokenAmount The amount of fractional tokens minted.
    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)
        public
        returns (uint256 fractionalTokenAmount)
    {
        // *** Checks *** //

        // check that wrapping is not closed
        require(closeTimestamp == 0, ""Wrap: closed"");

        // check the tokens exist in the merkle root
        _validateTokenIds(tokenIds, proofs);

        // *** Effects *** //

        // mint fractional tokens to sender
        fractionalTokenAmount = tokenIds.length * ONE;
        _mint(msg.sender, fractionalTokenAmount);

        // *** Interactions *** //

        // transfer nfts from sender
        for (uint256 i = 0; i < tokenIds.length; i++) {
            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);
        }

        emit Wrap(tokenIds);
    }

    /// @notice Unwraps fractional tokens into NFTs.
    /// @param tokenIds The ids of the NFTs to unwrap.
    /// @return fractionalTokenAmount The amount of fractional tokens burned.
    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {
        // *** Effects *** //

        // burn fractional tokens from sender
        fractionalTokenAmount = tokenIds.length * ONE;
        _burn(msg.sender, fractionalTokenAmount);

        // *** Interactions *** //

        // transfer nfts to sender
        for (uint256 i = 0; i < tokenIds.length; i++) {
            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);
        }

        emit Unwrap(tokenIds);
    }

    // *********************** //
    //      NFT AMM logic      //
    // *********************** //

    /// @notice nftAdd Adds liquidity to the pair using NFTs.
    /// @param baseTokenAmount The amount of base tokens to add.
    /// @param tokenIds The ids of the NFTs to add.
    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.
    /// @param proofs The merkle proofs for the NFTs.
    /// @return lpTokenAmount The amount of lp tokens minted.
    function nftAdd(
        uint256 baseTokenAmount,
        uint256[] calldata tokenIds,
        uint256 minLpTokenAmount,
        bytes32[][] calldata proofs
    ) public payable returns (uint256 lpTokenAmount) {
        // wrap the incoming NFTs into fractional tokens
        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);

        // add liquidity using the fractional tokens and base tokens
        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    /// @notice Removes liquidity from the pair using NFTs.
    /// @param lpTokenAmount The amount of lp tokens to remove.
    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.
    /// @param tokenIds The ids of the NFTs to remove.
    /// @return baseTokenOutputAmount The amount of base tokens received.
    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.
    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)
        public
        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)
    {
        // remove liquidity and send fractional tokens and base tokens to sender
        (baseTokenOutputAmount, fractionalTokenOutputAmount) =
            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);

        // unwrap the fractional tokens into NFTs and send to sender
        unwrap(tokenIds);
    }

    /// @notice Buys NFTs from the pair using base tokens.
    /// @param tokenIds The ids of the NFTs to buy.
    /// @param maxInputAmount The maximum amount of base tokens to spend.
    /// @return inputAmount The amount of base tokens spent.
    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {
        // buy fractional tokens using base tokens
        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);

        // unwrap the fractional tokens into NFTs and send to sender
        unwrap(tokenIds);
    }

    /// @notice Sells NFTs to the pair for base tokens.
    /// @param tokenIds The ids of the NFTs to sell.
    /// @param minOutputAmount The minimum amount of base tokens to receive.
    /// @param proofs The merkle proofs for the NFTs.
    /// @return outputAmount The amount of base tokens received.
    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)
        public
        returns (uint256 outputAmount)
    {
        // wrap the incoming NFTs into fractional tokens
        uint256 inputAmount = wrap(tokenIds, proofs);

        // sell fractional tokens for base tokens
        outputAmount = sell(inputAmount, minOutputAmount);
    }

    // ****************************** //
    //      Emergency exit logic      //
    // ****************************** //

    /// @notice Closes the pair to new wraps.
    /// @dev Can only be called by the caviar owner. This is used as an emergency exit in case
    ///      the caviar owner suspects that the pair has been compromised.
    function close() public {
        // check that the sender is the caviar owner
        require(caviar.owner() == msg.sender, ""Close: not owner"");

        // set the close timestamp with a grace period
        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;

        // remove the pair from the Caviar contract
        caviar.destroy(nft, baseToken, merkleRoot);

        emit Close(closeTimestamp);
    }

    /// @notice Withdraws a particular NFT from the pair.
    /// @dev Can only be called by the caviar owner after the close grace period has passed. This
    ///      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity
    ///      imbalances. Proceeds from the auction should be distributed pro rata to fractional
    ///      token holders. See documentation for more details.
    function withdraw(uint256 tokenId) public {
        // check that the sender is the caviar owner
        require(caviar.owner() == msg.sender, ""Withdraw: not owner"");

        // check that the close period has been set
        require(closeTimestamp != 0, ""Withdraw not initiated"");

        // check that the close grace period has passed
        require(block.timestamp >= closeTimestamp, ""Not withdrawable yet"");

        // transfer the nft to the caviar owner
        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);

        emit Withdraw(tokenId);
    }

    // ***************** //
    //      Getters      //
    // ***************** //

    function baseTokenReserves() public view returns (uint256) {
        return _baseTokenReserves();
    }

    function fractionalTokenReserves() public view returns (uint256) {
        return balanceOf[address(this)];
    }

    /// @notice The current price of one fractional token in base tokens with 18 decimals of precision.
    /// @dev Calculated by dividing the base token reserves by the fractional token reserves.
    /// @return price The price of one fractional token in base tokens * 1e18.
    function price() public view returns (uint256) {
        return (_baseTokenReserves() * ONE) / fractionalTokenReserves();
    }

    /// @notice The amount of base tokens required to buy a given amount of fractional tokens.
    /// @dev Calculated using the xyk invariant and a 30bps fee.
    /// @param outputAmount The amount of fractional tokens to buy.
    /// @return inputAmount The amount of base tokens required.
    function buyQuote(uint256 outputAmount) public view returns (uint256) {
        return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);
    }

    /// @notice The amount of base tokens received for selling a given amount of fractional tokens.
    /// @dev Calculated using the xyk invariant and a 30bps fee.
    /// @param inputAmount The amount of fractional tokens to sell.
    /// @return outputAmount The amount of base tokens received.
    function sellQuote(uint256 inputAmount) public view returns (uint256) {
        uint256 inputAmountWithFee = inputAmount * 997;
        return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);
    }

    /// @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.
    /// @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to
    ///      sqrt(baseTokenAmount * fractionalTokenAmount).
    /// @param baseTokenAmount The amount of base tokens to add.
    /// @param fractionalTokenAmount The amount of fractional tokens to add.
    /// @return lpTokenAmount The amount of lp tokens received.
    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {
        uint256 lpTokenSupply = lpToken.totalSupply();
        if (lpTokenSupply > 0) {
            // calculate amount of lp tokens as a fraction of existing reserves
            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();
            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();
            return Math.min(baseTokenShare, fractionalTokenShare);
        } else {
            // if there is no liquidity then init
            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        }
    }

    /// @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.
    /// @dev Calculated as a share of existing deposits.
    /// @param lpTokenAmount The amount of lp tokens to burn.
    /// @return baseTokenAmount The amount of base tokens received.
    /// @return fractionalTokenAmount The amount of fractional tokens received.
    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {
        uint256 lpTokenSupply = lpToken.totalSupply();
        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;
        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;

        return (baseTokenOutputAmount, fractionalTokenOutputAmount);
    }

    // ************************ //
    //      Internal utils      //
    // ************************ //

    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {
        balanceOf[from] -= amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(from, to, amount);

        return true;
    }

    /// @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts
    ///      if any of the tokenId proofs are invalid.
    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {
        // if merkle root is not set then all tokens are valid
        if (merkleRoot == bytes23(0)) return;

        // validate merkle proofs against merkle root
        for (uint256 i = 0; i < tokenIds.length; i++) {
            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));
            require(isValid, ""Invalid merkle proof"");
        }
    }

    /// @dev Returns the current base token reserves. If the base token is ETH then it ignores
    ///      the msg.value that is being sent in the current call context - this is to ensure the
    ///      xyk math is correct in the buy() and add() functions.
    function _baseTokenReserves() internal view returns (uint256) {
        return baseToken == address(0)
            ? address(this).balance - msg.value 
            // subtract the msg.value if the base token is ETH
            : ERC20(baseToken).balanceOf(address(this));
    }
}",4588,486,"H-01: Reentrancy in buy function for ERC777 tokens allows buying funds with considerable discount. L95, L137, L172, L203 H-02: Liquidity providers may lose funds when adding liquidity H-03: First depositor can break minting of shares M-01: Missing deadline checks allow pending transactions to be maliciously executed. L63 M-04: It's possible to swap NFT token ids without fee and also attacker can wrap unwrap all the NFT token balance of the Pair contract and steal their air drops for those token ids.  L217 M-05: Pair price may be manipulated by direct transfers ",6
106_NFTLoanFacilitator.sol,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    // ==== constants ====

    /** 
     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     
     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%
     */
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    /// See {INFTLoanFacilitator-SCALAR}.
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    // ==== state variables ====

    /// See {INFTLoanFacilitator-originationFeeRate}.
    /// @dev starts at 1%
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    /// See {INFTLoanFacilitator-requiredImprovementRate}.
    /// @dev starts at 10%
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    /// See {INFTLoanFacilitator-lendTicketContract}.
    address public override lendTicketContract;

    /// See {INFTLoanFacilitator-borrowTicketContract}.
    address public override borrowTicketContract;

    /// See {INFTLoanFacilitator-loanInfo}.
    mapping(uint256 => Loan) public loanInfo;

    /// @dev tracks loan count
    uint256 private _nonce = 1;

    
    // ==== modifiers ====

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    // ==== constructor ====

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    // ==== state changing external functions ====

    /// See {INFTLoanFacilitator-createLoan}.
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    /// See {INFTLoanFacilitator-closeLoan}.
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-lend}.
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    /// See {INFTLoanFacilitator-repayAndCloseLoan}.
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-seizeCollateral}.
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    // === owner state changing ===

    /**
     * @notice Sets lendTicketContract to _contract
     * @dev cannot be set if lendTicketContract is already set
     */
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    /**
     * @notice Sets borrowTicketContract to _contract
     * @dev cannot be set if borrowTicketContract is already set
     */
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    /**
     * @notice Updates originationFeeRate the faciliator keeps of each loan amount
     * @dev Cannot be set higher than 5%
     */
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    /**
     * @notice updates the percent improvement required of at least one loan term when buying out lender 
     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount
     * must be 10% higher or interest rate must be 10% lower. 
     * @dev Cannot be 0.
     */
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    // ==== external view ====

    /// See {INFTLoanFacilitator-loanInfoStruct}.
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    /// See {INFTLoanFacilitator-totalOwed}.
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-interestOwed}.
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-loanEndSeconds}.
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    // === private ===

    /// @dev Returns the total interest owed on loan
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 
            + accumulatedInterest;
    }
}",3338,389,"H-01: Can force borrower to pay huge interest.  L148 H-02: currentLoanOwner can manipulate loanInfo when any lenders try to buyout. L205 H-03: Borrower can be their own lender and steal funds from buyout due to reentrancy. L214 M-01: When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it. L205 M-02: Protocol doesn't handle fee on transfer tokens. L155 M-03: sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen. L116 M-04: requiredImprovementRate can not work as expected when previousInterestRate less than 10 due to precision loss M-05: Borrowers lose funds if they call repayAndCloseLoan instead of closeLoan. L241 M-06: Might not get desired min loan amount if _originationFeeRate changes M-07: mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk ",10
36_Auction.sol,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import './interfaces/IFactory.sol';
import './interfaces/IBasket.sol';
import ""./interfaces/IAuction.sol"";
import ""hardhat/console.sol"";

contract Auction is IAuction {
    using SafeERC20 for IERC20;

    uint256 private constant BASE = 1e18;
    uint256 private constant ONE_DAY = 4 * 60 * 24;
    uint256 private constant BLOCK_DECREMENT = 10000;
    
    bool public override auctionOngoing;
    uint256 public override auctionStart;
    bool public override hasBonded;
    uint256 public override bondAmount;
    uint256 public override bondTimestamp;
    bool public override initialized;

    IBasket public override basket;
    IFactory public override factory;
    address public override auctionBonder;

    Bounty[] private _bounties;

    modifier onlyBasket() {
        require(msg.sender == address(basket), 'not basket');
        _;
    }

    function startAuction() onlyBasket public override {
        require(auctionOngoing == false, 'ongoing auction');

        auctionOngoing = true;
        auctionStart = block.number;

        emit AuctionStarted();
    }

    function killAuction() onlyBasket public override {
        auctionOngoing = false;
    }

    function initialize(address basket_, address factory_) public override {
        require(!initialized);
        basket = IBasket(basket_);
        factory = IFactory(factory_);
        initialized = true;
    }

    function bondForRebalance() public override {
        require(auctionOngoing);
        require(!hasBonded);

        bondTimestamp = block.number;

        IERC20 basketToken = IERC20(address(basket));
        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();
        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);
        hasBonded = true;
        auctionBonder = msg.sender;

        emit Bonded(msg.sender, bondAmount);
    }

    function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY > block.number);
        require(msg.sender == auctionBonder);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basketAsERC20.transfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);
        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        emit AuctionSettled(msg.sender);
    }

    function bondBurn() external override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY <= block.number);

        basket.auctionBurn(bondAmount);
        hasBonded = false;
        auctionOngoing = false;
        basket.deleteNewIndex();

        emit BondBurned(msg.sender, auctionBonder, bondAmount);

        auctionBonder = address(0);
    }

    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {
        // add bounty to basket
        token.safeTransferFrom(msg.sender, address(this), amount);
        _bounties.push(Bounty({
            token: address(token),
            amount: amount,
            active: true
        }));

        uint256 id = _bounties.length - 1;
        emit BountyAdded(token, amount, id);
        return id;
    }

    function withdrawBounty(uint256[] memory bountyIds) internal {
        // withdraw bounties
        for (uint256 i = 0; i < bountyIds.length; i++) {
            Bounty memory bounty = _bounties[bountyIds[i]];
            require(bounty.active);

            IERC20(bounty.token).transfer(msg.sender, bounty.amount);
            bounty.active = false;

            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);
        }
    }
 }",1101,152,"M-01: Use safeTransfer instead of transfer. L146 M-03: onlyOwner Role Can Unintentionally Influence settleAuction().  L39 M-07: No minimum rate in the auction may break the protocol under network failure M-08: settleAuction may be impossible if locked at a wrong time.  L89 M-11: Owner can steal all Basket funds during auction  L89 M-15: Auction.sol#settleAuction() late auction bond could potentially not being able to be settled, cause funds loss to bonder M-16: Auction.sol#settleAuction() Mishandling bounty state could potentially disrupt settleAuction() M-17: Scoop ERC20 tokens from basket contract  L69 M-22: Incorrect data location specifier can be abused to cause DoS and fund loss. L143",9
17_PnL.sol,"// SPDX-License-Identifier: AGPLv3
pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../interfaces/IPnL.sol"";
import ""../common/Controllable.sol"";
import ""../interfaces/IPnL.sol"";
import ""../common/Constants.sol"";
import {FixedGTokens} from ""../common/FixedContracts.sol"";

/// @notice Contract for calculating protocol profit and loss. The PnL contract stores snapshots
///     of total assets in pwrd and gvt, which are used to calculate utilisation ratio and establish
///     changes in underling pwrd and gvt factors. The protocol will allow these values to drift as long
///     as they stay within a certain threshold of protocol actuals, or large amounts of assets are being
///     deposited or withdrawn from the protocol. The PnL contract ensures that any profits are distributed
///     between pwrd and gvt based on the utilisation ratio - as this ratio movese towards 1, a larger
///     amount of the pwrd profit is shifted to gvt. Protocol losses are on the other hand soaked up
///     by gvt, ensuring that pwrd never lose value.
///
///     ###############################################
///     PnL variables and calculations
///     ###############################################
///
///     yield - system gains and losses from assets invested into strategies are realised once
///         a harvest is run. Yield is ditributed to pwrd and gvt based on the utilisation ratio of the
///         two tokens (see _calcProfit).
///
///     PerformanceFee - The performance fee is deducted from any yield profits, and is used to
///         buy back and distribute governance tokens to users.
///
///     hodler Fee - Withdrawals experience a hodler fee that is socialized to all other holders.
///         Like other gains, this isn't realised on withdrawal, but rather when a critical amount
///         has amassed in the system (totalAssetsPercentThreshold).
///
///     ###############################################
///     PnL Actions
///     ###############################################
///
///     Pnl has two trigger mechanisms:
///         - Harvest:
///             - It will realize any loss/profit from the strategy
///             - It will atempt to update lastest cached curve stable coin dy
///                 - if successfull, it will try to realize any price changes (pre tvl vs current)
///         - Withdrawals
///             - Any user withdrawals are distributing the holder fee to the other users
contract PnL is Controllable, Constants, FixedGTokens, IPnL {
    using SafeMath for uint256;

    uint256 public override lastGvtAssets;
    uint256 public override lastPwrdAssets;
    bool public rebase = true;

    uint256 public performanceFee; 
    // Amount of gains to use to buy back and distribute gov tokens

    event LogRebaseSwitch(bool status);
    event LogNewPerfromanceFee(uint256 fee);
    event LogNewGtokenChange(bool pwrd, int256 change);
    event LogPnLExecution(
        uint256 deductedAssets,
        int256 totalPnL,
        int256 investPnL,
        int256 pricePnL,
        uint256 withdrawalBonus,
        uint256 performanceBonus,
        uint256 beforeGvtAssets,
        uint256 beforePwrdAssets,
        uint256 afterGvtAssets,
        uint256 afterPwrdAssets
    );

    constructor(
        address pwrd,
        address gvt,
        uint256 pwrdAssets,
        uint256 gvtAssets
    ) public FixedGTokens(pwrd, gvt) {
        lastPwrdAssets = pwrdAssets;
        lastGvtAssets = gvtAssets;
    }

    /// @notice Turn pwrd rebasing on/off - This stops yield/ hodler bonuses to be distributed to the pwrd
    ///     token, which effectively stops it from rebasing any further.
    function setRebase(bool _rebase) external onlyOwner {
        rebase = _rebase;
        emit LogRebaseSwitch(_rebase);
    }

    /// @notice Fee taken from gains to be redistributed to users who stake their tokens
    /// @param _performanceFee Amount to remove from gains (%BP)
    function setPerformanceFee(uint256 _performanceFee) external onlyOwner {
        performanceFee = _performanceFee;
        emit LogNewPerfromanceFee(_performanceFee);
    }

    /// @notice Increase previously recorded GToken assets by specific amount
    /// @param pwrd pwrd/gvt
    /// @param dollarAmount Amount to increase by
    function increaseGTokenLastAmount(bool pwrd, uint256 dollarAmount) external override {
        require(msg.sender == controller, ""increaseGTokenLastAmount: !controller"");
        if (!pwrd) {
            lastGvtAssets = lastGvtAssets.add(dollarAmount);
        } else {
            lastPwrdAssets = lastPwrdAssets.add(dollarAmount);
        }
        emit LogNewGtokenChange(pwrd, int256(dollarAmount));
    }

    /// @notice Decrease previously recorded GToken assets by specific amount
    /// @param pwrd pwrd/gvt
    /// @param dollarAmount Amount to decrease by
    /// @param bonus hodler bonus
    function decreaseGTokenLastAmount(
        bool pwrd,
        uint256 dollarAmount,
        uint256 bonus
    ) external override {
        require(msg.sender == controller, ""decreaseGTokenLastAmount: !controller"");
        uint256 lastGA = lastGvtAssets;
        uint256 lastPA = lastPwrdAssets;
        if (!pwrd) {
            lastGA = dollarAmount > lastGA ? 0 : lastGA.sub(dollarAmount);
        } else {
            lastPA = dollarAmount > lastPA ? 0 : lastPA.sub(dollarAmount);
        }
        if (bonus > 0) {
            uint256 preGABeforeBonus = lastGA;
            uint256 prePABeforeBonus = lastPA;
            uint256 preTABeforeBonus = preGABeforeBonus.add(prePABeforeBonus);
            if (rebase) {
                lastGA = preGABeforeBonus.add(bonus.mul(preGABeforeBonus).div(preTABeforeBonus));
                lastPA = prePABeforeBonus.add(bonus.mul(prePABeforeBonus).div(preTABeforeBonus));
            } else {
                lastGA = preGABeforeBonus.add(bonus);
            }
            emit LogPnLExecution(0, int256(bonus), 0, 0, bonus, 0, preGABeforeBonus, prePABeforeBonus, lastGA, lastPA);
        }

        lastGvtAssets = lastGA;
        lastPwrdAssets = lastPA;
        emit LogNewGtokenChange(pwrd, int256(-dollarAmount));
    }

    /// @notice Return latest system asset states
    function calcPnL() external view override returns (uint256, uint256) {
        return (lastGvtAssets, lastPwrdAssets);
    }

    /// @notice Calculate utilisation ratio between gvt and pwrd
    function utilisationRatio() external view override returns (uint256) {
        return lastGvtAssets != 0 ? lastPwrdAssets.mul(PERCENTAGE_DECIMAL_FACTOR).div(lastGvtAssets) : 0;
    }

    /// @notice Update assets after entering emergency state
    function emergencyPnL() external override {
        require(msg.sender == controller, ""emergencyPnL: !controller"");
        forceDistribute();
    }

    /// @notice Recover system from emergency state
    function recover() external override {
        require(msg.sender == controller, ""recover: !controller"");
        forceDistribute();
    }

    /// @notice Distribute yield based on utilisation ratio
    /// @param gvtAssets Total gvt assets
    /// @param pwrdAssets Total pwrd assets
    /// @param profit Amount of profit to distribute
    /// @param reward Rewards contract
    function handleInvestGain(
        uint256 gvtAssets,
        uint256 pwrdAssets,
        uint256 profit,
        address reward
    )
        private
        view
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        uint256 performanceBonus;
        if (performanceFee > 0 && reward != address(0)) {
            performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);
            profit = profit.sub(performanceBonus);
        }
        if (rebase) {
            uint256 totalAssets = gvtAssets.add(pwrdAssets);
            uint256 gvtProfit = profit.mul(gvtAssets).div(totalAssets);
            uint256 pwrdProfit = profit.mul(pwrdAssets).div(totalAssets);

            uint256 factor = pwrdAssets.mul(10000).div(gvtAssets);
            if (factor > 10000) factor = 10000;
            if (factor < 8000) {
                factor = factor.mul(3).div(8).add(3000);
            } else {
                factor = factor.sub(8000).mul(2).add(6000);
            }

            uint256 portionFromPwrdProfit = pwrdProfit.mul(factor).div(10000);
            gvtAssets = gvtAssets.add(gvtProfit.add(portionFromPwrdProfit));
            pwrdAssets = pwrdAssets.add(pwrdProfit.sub(portionFromPwrdProfit));
        } else {
            gvtAssets = gvtAssets.add(profit);
        }
        return (gvtAssets, pwrdAssets, performanceBonus);
    }

    /// @notice Distribute losses
    /// @param gvtAssets Total gvt assets
    /// @param pwrdAssets Total pwrd assets
    /// @param loss Amount of loss to distribute
    function handleLoss(
        uint256 gvtAssets,
        uint256 pwrdAssets,
        uint256 loss
    ) private pure returns (uint256, uint256) {
        uint256 maxGvtLoss = gvtAssets.sub(DEFAULT_DECIMALS_FACTOR);
        if (loss > maxGvtLoss) {
            gvtAssets = DEFAULT_DECIMALS_FACTOR;
            pwrdAssets = pwrdAssets.sub(loss.sub(maxGvtLoss));
        } else {
            gvtAssets = gvtAssets - loss;
        }
        return (gvtAssets, pwrdAssets);
    }

    function forceDistribute() private {
        uint256 total = _controller().totalAssets();

        if (total > lastPwrdAssets.add(DEFAULT_DECIMALS_FACTOR)) {
            lastGvtAssets = total - lastPwrdAssets;
        } else {
            lastGvtAssets = DEFAULT_DECIMALS_FACTOR;
            lastPwrdAssets = total.sub(DEFAULT_DECIMALS_FACTOR);
        }
    }

    function distributeStrategyGainLoss(
        uint256 gain,
        uint256 loss,
        address reward
    ) external override {
        require(msg.sender == controller, ""!Controller"");
        uint256 lastGA = lastGvtAssets;
        uint256 lastPA = lastPwrdAssets;
        uint256 performanceBonus;
        uint256 gvtAssets;
        uint256 pwrdAssets;
        int256 investPnL;
        if (gain > 0) {
            (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);
            if (performanceBonus > 0) {
                gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);
                gvtAssets = gvtAssets.add(performanceBonus);
            }

            lastGvtAssets = gvtAssets;
            lastPwrdAssets = pwrdAssets;
            investPnL = int256(gain);
        } else if (loss > 0) {
            (lastGvtAssets, lastPwrdAssets) = handleLoss(lastGA, lastPA, loss);
            investPnL = -int256(loss);
        }

        emit LogPnLExecution(
            0,
            investPnL,
            investPnL,
            0,
            0,
            performanceBonus,
            lastGA,
            lastPA,
            lastGvtAssets,
            lastPwrdAssets
        );
    }

    function distributePriceChange(uint256 currentTotalAssets) external override {
        require(msg.sender == controller, ""!Controller"");
        uint256 gvtAssets = lastGvtAssets;
        uint256 pwrdAssets = lastPwrdAssets;
        uint256 totalAssets = gvtAssets.add(pwrdAssets);

        if (currentTotalAssets > totalAssets) {
            lastGvtAssets = gvtAssets.add(currentTotalAssets.sub(totalAssets));
        } else if (currentTotalAssets < totalAssets) {
            (lastGvtAssets, lastPwrdAssets) = handleLoss(gvtAssets, pwrdAssets, totalAssets.sub(currentTotalAssets));
        }
        int256 priceChange = int256(currentTotalAssets) - int256(totalAssets);

        emit LogPnLExecution(
            0,
            priceChange,
            0,
            priceChange,
            0,
            0,
            gvtAssets,
            pwrdAssets,
            lastGvtAssets,
            lastPwrdAssets
        );
    }
}",2827,310,"H-01: implicit underflows. L112 H-03: Incorrect use of operator leads to arbitrary minting of GVT tokens. L254, L186, L256",2
74_TimeswapPair.sol,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from './interfaces/IPair.sol';
import {IFactory} from './interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {MintMath} from './libraries/MintMath.sol';
import {BurnMath} from './libraries/BurnMath.sol';
import {LendMath} from './libraries/LendMath.sol';
import {WithdrawMath} from './libraries/WithdrawMath.sol';
import {BorrowMath} from './libraries/BorrowMath.sol';
import {PayMath} from './libraries/PayMath.sol';
import {SafeTransfer} from './libraries/SafeTransfer.sol';
import {Array} from './libraries/Array.sol';
import {Callback} from './libraries/Callback.sol';
import {BlockNumber} from './libraries/BlockNumber.sol';

/// @title Timeswap Pair
/// @author Timeswap Labs
/// @notice It is recommnded to use Timeswap Convenience to interact with this contract.
/// @notice All error messages are coded and can be found in the documentation.
contract TimeswapPair is IPair {
    using SafeTransfer for IERC20;
    using Array for Due[];

    /* ===== MODEL ===== */

    /// @inheritdoc IPair
    IFactory public immutable override factory;
    /// @inheritdoc IPair
    IERC20 public immutable override asset;
    /// @inheritdoc IPair
    IERC20 public immutable override collateral;
    /// @inheritdoc IPair
    uint16 public immutable override fee;
    /// @inheritdoc IPair
    uint16 public immutable override protocolFee;

    /// @dev Stores the individual states of each Pool.
    mapping(uint256 => Pool) private pools;

    /// @dev Stores the access state for reentrancy guard.
    uint256 private locked;

    /* ===== VIEW =====*/

    /// @inheritdoc IPair
    function constantProduct(uint256 maturity)
        external
        view
        override
        returns (
            uint112 x,
            uint112 y,
            uint112 z
        )
    {
        State memory state = pools[maturity].state;
        return (state.x, state.y, state.z);
    }

    /// @inheritdoc IPair
    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {
        return pools[maturity].state.reserves;
    }

    /// @inheritdoc IPair
    function totalLiquidity(uint256 maturity) external view override returns (uint256) {
        return pools[maturity].state.totalLiquidity;
    }

    /// @inheritdoc IPair
    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {
        return pools[maturity].liquidities[owner];
    }

    /// @inheritdoc IPair
    function totalClaims(uint256 maturity) external view override returns (Claims memory) {
        return pools[maturity].state.totalClaims;
    }

    /// @inheritdoc IPair
    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {
        return pools[maturity].claims[owner];
    }

    /// @inheritdoc IPair
    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {
        return pools[maturity].state.totalDebtCreated;
    }

    /// @inheritdoc IPair
    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {
        return pools[maturity].dues[owner][id];
    }

    /* ===== INIT ===== */

    /// @dev Initializes the Pair contract.
    /// @dev Called by the Timeswap factory contract.
    /// @param _asset The address of the ERC20 being lent and borrowed.
    /// @param _collateral The address of the ERC20 as the collateral.
    /// @param _fee The chosen fee rate.
    /// @param _protocolFee The chosen protocol fee rate.
    constructor(
        IERC20 _asset,
        IERC20 _collateral,
        uint16 _fee,
        uint16 _protocolFee
    ) {
        factory = IFactory(msg.sender);
        asset = _asset;
        collateral = _collateral;
        fee = _fee;
        protocolFee = _protocolFee;
    }

    /* ===== MODIFIER ===== */

    /// @dev The modifier for reentrancy guard.
    modifier lock() {
        require(locked == 0, 'E211');
        locked = 1;
        _;
        locked = 0;
    }

    /* ===== UPDATE ===== */

    /// @inheritdoc IPair
    function mint(
        uint256 maturity,
        address liquidityTo,
        address dueTo,
        uint112 xIncrease,
        uint112 yIncrease,
        uint112 zIncrease,
        bytes calldata data
    )
        external
        override
        lock
        returns (
            uint256 liquidityOut,
            uint256 id,
            Due memory dueOut
        )
    {
        require(block.timestamp < maturity, 'E202');
        require(maturity - block.timestamp < 0x100000000, 'E208');
        require(liquidityTo != address(0) && dueTo != address(0), 'E201');
        require(liquidityTo != address(this) && dueTo != address(this), 'E204');
        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205');
        
        Pool storage pool = pools[maturity];

        if (pool.state.totalLiquidity == 0) {
            uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);
            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);

            pool.state.totalLiquidity += liquidityTotal;
            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;
        } else {
            uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);
            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);

            pool.state.totalLiquidity += liquidityTotal;
            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;
        }
        require(liquidityOut > 0, 'E212');
        pool.liquidities[liquidityTo] += liquidityOut;

        dueOut.debt = MintMath.getDebt(maturity, xIncrease, yIncrease);
        dueOut.collateral = MintMath.getCollateral(maturity, zIncrease);
        dueOut.startBlock = BlockNumber.get();

        Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data);

        id = pool.dues[dueTo].insert(dueOut);

        pool.state.reserves.asset += xIncrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x += xIncrease;
        pool.state.y += yIncrease;
        pool.state.z += zIncrease;

        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Mint(maturity, msg.sender, liquidityTo, dueTo, xIncrease, liquidityOut, id, dueOut);
    }

    /// @inheritdoc IPair
    function burn(
        uint256 maturity,
        address assetTo,
        address collateralTo,
        uint256 liquidityIn
    ) external override lock returns (Tokens memory tokensOut) {
        require(block.timestamp >= maturity, 'E203');
        require(assetTo != address(0) && collateralTo != address(0), 'E201');
        require(assetTo != address(this) && collateralTo != address(this), 'E204');
        require(liquidityIn > 0, 'E205');

        Pool storage pool = pools[maturity];

        tokensOut.asset = BurnMath.getAsset(pool.state, liquidityIn);
        tokensOut.collateral = BurnMath.getCollateral(pool.state, liquidityIn);

        pool.state.totalLiquidity -= liquidityIn;

        pool.liquidities[msg.sender] -= liquidityIn;

        pool.state.reserves.asset -= tokensOut.asset;
        pool.state.reserves.collateral -= tokensOut.collateral;

        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);
        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);

        emit Burn(maturity, msg.sender, assetTo, collateralTo, liquidityIn, tokensOut);
    }

    /// @inheritdoc IPair
    function lend(
        uint256 maturity,
        address bondTo,
        address insuranceTo,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease,
        bytes calldata data
    ) external override lock returns (Claims memory claimsOut) {
        require(block.timestamp < maturity, 'E202');
        require(bondTo != address(0) && insuranceTo != address(0), 'E201');
        require(bondTo != address(this) && insuranceTo != address(this), 'E204');
        require(xIncrease > 0, 'E205');

        Pool storage pool = pools[maturity];
        require(pool.state.totalLiquidity > 0, 'E206');

        LendMath.check(pool.state, xIncrease, yDecrease, zDecrease, fee);

        claimsOut.bond = LendMath.getBond(maturity, xIncrease, yDecrease);
        claimsOut.insurance = LendMath.getInsurance(maturity, pool.state, xIncrease, zDecrease);

        Callback.lend(asset, xIncrease, data);

        pool.state.totalClaims.bond += claimsOut.bond;
        pool.state.totalClaims.insurance += claimsOut.insurance;

        pool.claims[bondTo].bond += claimsOut.bond;
        pool.claims[insuranceTo].insurance += claimsOut.insurance;

        pool.state.reserves.asset += xIncrease;

        pool.state.x += xIncrease;
        pool.state.y -= yDecrease;
        pool.state.z -= zDecrease;

        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Lend(maturity, msg.sender, bondTo, insuranceTo, xIncrease, claimsOut);
    }

    /// @inheritdoc IPair
    function withdraw(
        uint256 maturity,
        address assetTo,
        address collateralTo,
        Claims memory claimsIn
    ) external override lock returns (Tokens memory tokensOut) {
        require(block.timestamp >= maturity, 'E203');
        require(assetTo != address(0) && collateralTo != address(0), 'E201');
        require(assetTo != address(this) && collateralTo != address(this), 'E204');
        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205');

        Pool storage pool = pools[maturity];

        tokensOut.asset = WithdrawMath.getAsset(pool.state, claimsIn.bond);
        tokensOut.collateral = WithdrawMath.getCollateral(pool.state, claimsIn.insurance);

        pool.state.totalClaims.bond -= claimsIn.bond;
        pool.state.totalClaims.insurance -= claimsIn.insurance;

        Claims storage sender = pool.claims[msg.sender];

        sender.bond -= claimsIn.bond;
        sender.insurance -= claimsIn.insurance;

        pool.state.reserves.asset -= tokensOut.asset;
        pool.state.reserves.collateral -= tokensOut.collateral;

        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);
        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);

        emit Withdraw(maturity, msg.sender, assetTo, collateralTo, claimsIn, tokensOut);
    }

    /// @inheritdoc IPair
    function borrow(
        uint256 maturity,
        address assetTo,
        address dueTo,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease,
        bytes calldata data
    ) external override lock returns (uint256 id, Due memory dueOut) {
        require(block.timestamp < maturity, 'E202');
        require(assetTo != address(0) && dueTo != address(0), 'E201');
        require(assetTo != address(this) && dueTo != address(this), 'E204');
        require(xDecrease > 0, 'E205');

        Pool storage pool = pools[maturity];
        require(pool.state.totalLiquidity > 0, 'E206');

        BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);

        dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);
        dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);
        dueOut.startBlock = BlockNumber.get();

        Callback.borrow(collateral, dueOut.collateral, data);

        id = pool.dues[dueTo].insert(dueOut);

        pool.state.reserves.asset -= xDecrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x -= xDecrease;
        pool.state.y += yIncrease;
        pool.state.z += zIncrease;

        asset.safeTransfer(assetTo, xDecrease);

        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut);
    }

    /// @inheritdoc IPair
    function pay(
        uint256 maturity,
        address to,
        address owner,
        uint256[] memory ids,
        uint112[] memory assetsIn,
        uint112[] memory collateralsOut,
        bytes calldata data
    ) external override lock returns (uint128 assetIn, uint128 collateralOut) {
        require(block.timestamp < maturity, 'E202');
        require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');
        require(to != address(0), 'E201');
        require(to != address(this), 'E204');

        Pool storage pool = pools[maturity];

        Due[] storage dues = pool.dues[owner];

        for (uint256 i; i < ids.length; i++) {
            Due storage due = dues[ids[i]];
            require(due.startBlock != BlockNumber.get(), 'E207');
            if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');
            PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);
            due.debt -= assetsIn[i];
            due.collateral -= collateralsOut[i];
            assetIn += assetsIn[i];
            collateralOut += collateralsOut[i];
        }
        if (assetIn > 0) Callback.pay(asset, assetIn, data);

        pool.state.reserves.asset += assetIn;
        pool.state.reserves.collateral -= collateralOut;

        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut);

        emit Pay(maturity, msg.sender, to, owner, ids, assetsIn, collateralsOut, assetIn, collateralOut);
    }
}",3200,379,"H-01: TimeswapPair.sol#borrow() Improper implementation allows attacker to increase pool.state.z to a large value H-03: Manipulation of the Y State Results in Interest Rate Manipulation H-04: Important state updates are made after the callback in the mint() function H-05: In the lend() function state updates are made after the callback H-06: borrow() function has state updates after a callback to msg.sender H-07: pay() function has callback to msg.sender before important state updates M-06: TimeswapPair.sol#mint() Malicious user/attacker can mint new liquidity with an extremely small amount of yIncrease and malfunction the pair with the maturity M-09: DOS pay function. L364",8
14_YieldSourcePrizePool.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""../PrizePool.sol"";

contract YieldSourcePrizePool is PrizePool {

  using SafeERC20Upgradeable for IERC20Upgradeable;

  IYieldSource public yieldSource;

  event YieldSourcePrizePoolInitialized(address indexed yieldSource);

  /// @notice Initializes the Prize Pool and Yield Service with the required contract connections
  /// @param _controlledTokens Array of addresses for the Ticket and Sponsorship Tokens controlled by the Prize Pool
  /// @param _maxExitFeeMantissa The maximum exit fee size, relative to the withdrawal amount
  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock could be
  /// @param _yieldSource Address of the yield source
  function initializeYieldSourcePrizePool (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration,
    IYieldSource _yieldSource
  )
    public
    initializer
  {
    require(address(_yieldSource) != address(0), ""YieldSourcePrizePool/yield-source-zero"");
    PrizePool.initialize(
      _reserveRegistry,
      _controlledTokens,
      _maxExitFeeMantissa,
      _maxTimelockDuration
    );
    yieldSource = _yieldSource;

    // A hack to determine whether it's an actual yield source
    (bool succeeded,) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));
    require(succeeded, ""YieldSourcePrizePool/invalid-yield-source"");

    emit YieldSourcePrizePoolInitialized(address(_yieldSource));
  }

  /// @notice Determines whether the passed token can be transferred out as an external award.
  /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
  /// prize strategy should not be allowed to move those tokens.
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function _canAwardExternal(address _externalToken) internal override view returns (bool) {
    return _externalToken != address(yieldSource);
  }

  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
  /// @return The underlying balance of asset tokens
  function _balance() internal override returns (uint256) {
    return yieldSource.balanceOfToken(address(this));
  }

  function _token() internal override view returns (IERC20Upgradeable) {
    return IERC20Upgradeable(yieldSource.depositToken());
  }

  /// @notice Supplies asset tokens to the yield source.
  /// @param mintAmount The amount of asset tokens to be supplied
  function _supply(uint256 mintAmount) internal override {
    _token().safeApprove(address(yieldSource), mintAmount);
    yieldSource.supplyTokenTo(mintAmount, address(this));
  }

  /// @notice Redeems asset tokens from the yield source.
  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed
  /// @return The actual amount of tokens that were redeemed.
  function _redeem(uint256 redeemAmount) internal override returns (uint256) {
    return yieldSource.redeemToken(redeemAmount);
  }
}",799,82,L-01: no check for _stakeToken!=0.  L24,1
5_Router.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Router {

    // Parameters
    bool private inited;
    uint one = 10**18;
    uint public rewardReductionFactor;
    uint public timeForFullProtection;

    uint public curatedPoolLimit;
    uint public curatedPoolCount;
    mapping(address => bool) private _isCurated;
    
    address public VADER;
    address public USDV;
    address public POOLS;

    uint public anchorLimit;
    uint public insidePriceLimit;
    uint public outsidePriceLimit;
    address[] public arrayAnchors;
    uint[] public arrayPrices;

    uint public repayDelay = 3600;

    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;
    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;
    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;

    mapping(address => CollateralDetails) private mapMember_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; 
    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;

    struct CollateralDetails {
        uint ID;
        mapping(address => DebtDetails) mapCollateral_Debt;
    }
    struct DebtDetails{
        uint ID;
        mapping(address =>uint) debt; 
        mapping(address =>uint) collateral; 
        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol
        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time
        // mapping(address =>uint) currentDay; // assetC > AssetD > time
    }

    event PoolReward(address indexed base, address indexed token, uint amount);
    event Protection(address indexed member, uint amount);
    event Curated(address indexed curator, address indexed token);

    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);
    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}
    // Init
    function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {
        rewardReductionFactor = newFactor;
        timeForFullProtection = newTime;
        curatedPoolLimit = newLimit;
    }
    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {
        anchorLimit = newLimit;
        insidePriceLimit = newInside;
        outsidePriceLimit = newOutside;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){
        uint _actualInputBase = moveTokenToPools(base, inputBase);
        uint _actualInputToken = moveTokenToPools(token, inputToken);
        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); 
        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {
        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);
        uint _protection = getILProtection(msg.sender, base, token, basisPoints);
        removeDepositData(msg.sender, token, basisPoints, _protection); 
        iERC20(base).transfer(msg.sender, _protection);
    }

      //=======================================SWAP===========================================//
    
    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);
    }
    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);
    }

    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);
    }

    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {
        address _member = msg.sender;
        if(!inSynth){
            moveTokenToPools(inputToken, inputAmount);
        } else {
            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);
        }
        address _base;
        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {
            _base = VADER;
        } else {
            _base = USDV;
        }
        if (isBase(outputToken)) {
            // Token||Synth -> BASE
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);
            } else {
                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);
            }
        } else if (isBase(inputToken)) {
            // BASE -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        } else if (!isBase(inputToken) && !isBase(outputToken)) {
            // Token||Synth -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);
            } else {
                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);
            }
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        }
        _handlePoolReward(_base, inputToken);
        _handlePoolReward(_base, outputToken);
        _handleAnchorPriceUpdate(inputToken);
        _handleAnchorPriceUpdate(outputToken); 
    }

    //====================================INCENTIVES========================================//

    function _handlePoolReward(address _base, address _token) internal{
        if(!isBase(_token)){                        
            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);
            iERC20(_base).transfer(POOLS, _reward);
            iPOOLS(POOLS).sync(_base, _token);
            emit PoolReward(_base, _token, _reward);
        }
    }

    //=================================IMPERMANENT LOSS=====================================//
    
    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {
        mapMemberToken_depositBase[member][token] += amountBase;
        mapMemberToken_depositToken[member][token] += amountToken;
        mapMemberToken_lastDeposited[member][token] = block.timestamp;
    }
    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {
        mapMemberToken_depositBase[member][token] += protection;
        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);
        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);
        mapMemberToken_depositBase[member][token] -= _baseToRemove;
        mapMemberToken_depositToken[member][token] -= _tokenToRemove;
    }

    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {
        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);
        if(base == VADER){
            if(protection >= reserveVADER()){
                protection = reserveVADER(); 
            }
        } else {
            if(protection >= reserveUSDV()){
                protection = reserveUSDV(); 
            }
        }
    }
    
    //=====================================CURATION==========================================//

    function curatePool(address token) external {
        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));
        if(!isCurated(token)){
            if(curatedPoolCount < curatedPoolLimit){ 
                _isCurated[token] = true;
                curatedPoolCount += 1;
            }
        }
        emit Curated(msg.sender, token);
    }
    function replacePool(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAsset(newToken));
        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ 
            _isCurated[oldToken] = false;
            _isCurated[newToken] = true;
            emit Curated(msg.sender, newToken);
        }
    }

    //=====================================ANCHORS==========================================//

    function listAnchor(address token) external {
        require(arrayAnchors.length < anchorLimit); 
        require(iPOOLS(POOLS).isAnchor(token));     
        arrayAnchors.push(token);                  
        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));
        _isCurated[token] = true; 
        updateAnchorPrice(token);
    }

    function replaceAnchor(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAnchor(newToken), ""Not anchor"");
        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), ""Not deeper"");
        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             
        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               
        _isCurated[oldToken] = false; 
        _isCurated[newToken] = true; 
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == oldToken){
                arrayAnchors[i] = newToken;
            }
        }
        updateAnchorPrice(newToken);
    }

    // Anyone to update prices
    function updateAnchorPrice(address token) public {
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == token){
                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);
            }
        }
    }

    function _handleAnchorPriceUpdate(address _token) internal{
        if(iPOOLS(POOLS).isAnchor(_token)){
            updateAnchorPrice(_token);
        }
    }

    // Price of 1 VADER in USD
    function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  
            anchorPrice = _sortedAnchorFeed[2];                      
        } else {
            anchorPrice = one;          
        }
    }

    // The correct amount of Vader for an input of USDV
    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){
        uint _price = getAnchorPrice();
        return (_price * USDVAmount) / one;
    }

    // The correct amount of USDV for an input of VADER
    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){
        uint _price = getAnchorPrice();
        return (vaderAmount * one) / _price;
    }
    
    
    //======================================LENDING=========================================//

    // Draw debt for self
    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {
        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);
    }

    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {
        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);
        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  
        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;                
        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            
        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                 
            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  
            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                        
        }
        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               
        payInterest(collateralAsset, debtAsset);
        return _debtIssued;
    }

    // Repay for self
    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){
        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);
    }
     // Repay for member
    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){
        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));
        uint _debt = moveTokenToPools(debtAsset, _amount);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);          
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);          
        }
        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); 
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               
        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   
        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;
        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  
        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);
        _handleTransferOut(member, collateralAsset, _collateralUnlocked);
        payInterest(collateralAsset, debtAsset);
        return _collateralUnlocked;
    }

    // Called once a day to pay interest
    function payInterest(address collateralAsset, address debtAsset) internal {
        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                             
            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];
            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);
            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;
            _removeCollateral(_interestOwed, collateralAsset, debtAsset);
            if(isBase(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).sync(collateralAsset, debtAsset);
            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());
            }
        }
    }

    function checkLiquidate() public {
        // get member remaining Collateral: originalDeposit - shareOfInterestPayments
        // if remainingCollateral <= 101% * debtValueInCollateral
        // purge, send remaining collateral to liquidator
    }

    // function purgeMember() public {

    // }

    // Get Collateral
    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _inputAmount = _getFunds(_collateralAsset, _amount); 
        }else if(isPool(_collateralAsset)){
             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); 
             _inputAmount = _amount;
        }
    }
    // Send Collateral
    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _sendFunds(_collateralAsset, _member, _amount); 
        }else if(isPool(_collateralAsset)){
            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); 
        }
    }

    function _getFunds(address _token, uint _amount) internal returns(uint) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(tx.origin==msg.sender){
            require(iERC20(_token).transferTo(address(this), _amount));
        }else{
            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));
        }
        return iERC20(_token).balanceOf(address(this)) - _balance;
    }

    function _sendFunds(address _token, address _member, uint _amount) internal {
        require(iERC20(_token).transfer(_member, _amount));
    }

    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;
    }
    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;
    }
    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {
        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;              
    }



    //======================================HELPERS=========================================//

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }

    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this));
    }
    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this));
    }

    // Optionality
    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {
        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){
            safeAmount = _amount;
            if(tx.origin==msg.sender){
                iERC20(_token).transferTo(POOLS, _amount);
            }else{
                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            }
        } else {
            uint _startBal = iERC20(_token).balanceOf(POOLS);
            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;
        }
    }

    

    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function isCurated(address token) public view returns(bool curated) {
        if(_isCurated[token]){
            curated = true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    function getMemberBaseDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositBase[member][token];
    }
    function getMemberTokenDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositToken[member][token];
    }
    function getMemberLastDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_lastDeposited[member][token];
    }
    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];
    }
    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];
    }
    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];
    }
    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Debt[collateralAsset][debtAsset];
    }
    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];
    }
    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];
    }
}",5626,511,"H-09: Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol. L84 H-10: Anyone can list anchors / curate tokens H-15: Wrong slippage protection on Token -> Token trades H-23: Anyone can curate pools and steal rewards M-03: Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol M-11: Allowing duplicated anchors could cause bias on anchor price.",6
35_ConcentratedLiquidityPool.sol,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/IPositionManager.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""../../interfaces/ITridentRouter.sol"";
import ""../../libraries/concentratedPool/FullMath.sol"";
import ""../../libraries/concentratedPool/TickMath.sol"";
import ""../../libraries/concentratedPool/UnsafeMath.sol"";
import ""../../libraries/concentratedPool/DyDxMath.sol"";
import ""../../libraries/concentratedPool/SwapLib.sol"";
import ""../../libraries/concentratedPool/Ticks.sol"";
import ""hardhat/console.sol"";

/// @notice Trident exchange pool template with concentrated liquidity and constant product formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares.
//      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract ConcentratedLiquidityPool is IPool {
    using Ticks for mapping(int24 => Ticks.Tick);

    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Collect(address indexed sender, uint256 amount0, uint256 amount1);
    event Sync(uint256 reserveShares0, uint256 reserveShares1);

    /// @dev References for tickSpacing:
    // 100 tickSpacing -> 2% between ticks.
    bytes32 public constant override poolIdentifier = ""Trident:ConcentratedLiquidity"";

    uint24 internal constant MAX_FEE = 100000; 
    /// @dev Maximum `swapFee` is 10%.

    uint128 internal immutable MAX_TICK_LIQUIDITY;
    uint24 internal immutable tickSpacing;
    uint24 internal immutable swapFee; 
    /// @dev 1000 corresponds to 0.1% fee. Fee is measured in pips.

    address internal immutable barFeeTo;
    IBentoBoxMinimal internal immutable bento;
    IMasterDeployer internal immutable masterDeployer;

    address internal immutable token0;
    address internal immutable token1;

    uint128 public liquidity;

    uint160 internal secondsPerLiquidity; 
    /// @dev Multiplied by 2^128.
    uint32 internal lastObservation;

    uint256 public feeGrowthGlobal0; 
    /// @dev All fee growth counters are multiplied by 2^128.
    uint256 public feeGrowthGlobal1;

    uint256 public barFee;

    uint128 internal token0ProtocolFee;
    uint128 internal token1ProtocolFee;

    uint128 internal reserve0; 
    /// @dev `bento` share balance tracker.
    uint128 internal reserve1;

    uint160 internal price; 
    /// @dev Sqrt of price aka. √(y/x), multiplied by 2^96.
    int24 internal nearestTick; 
    /// @dev Tick that is just below the current price.

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    mapping(int24 => Ticks.Tick) public ticks;
    mapping(address => mapping(int24 => mapping(int24 => Position))) public positions;

    struct Position {
        uint128 liquidity;
        uint256 feeGrowthInside0Last;
        uint256 feeGrowthInside1Last;
    }

    struct SwapCache {
        uint256 feeAmount;
        uint256 totalFeeAmount;
        uint256 protocolFee;
        uint256 feeGrowthGlobal;
        uint256 currentPrice;
        uint256 currentLiquidity;
        uint256 input;
        int24 nextTickToCross;
    }

    struct MintParams {
        int24 lowerOld;
        int24 lower;
        int24 upperOld;
        int24 upper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        bool token0native;
        bool token1native;
        /// @dev To mint an NFT the positionOwner should be set to the positionManager contract.
        address positionOwner;
        /// @dev When minting through the positionManager contract positionRecipient should be the NFT recipient.
        //    It can be set to address(0) if we are not minting through the positionManager contract.
        address positionRecipient;
    }

    /// @dev Only set immutable variables here - state changes made here will not be used.
    constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) {
        (address _token0, address _token1, uint24 _swapFee, uint160 _price, uint24 _tickSpacing) = abi.decode(
            _deployData,
            (address, address, uint24, uint160, uint24)
        );

        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != address(this), ""INVALID_TOKEN0"");
        require(_token1 != address(this), ""INVALID_TOKEN1"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        
        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        price = _price;
        tickSpacing = _tickSpacing;
        /// @dev Prevents global liquidity overflow in the case all ticks are initialised.
        MAX_TICK_LIQUIDITY = Ticks.getMaxLiquidity(_tickSpacing);
        ticks[TickMath.MIN_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);
        ticks[TickMath.MAX_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);
        nearestTick = TickMath.MIN_TICK;
        bento = IBentoBoxMinimal(_masterDeployer.bento());
        barFeeTo = _masterDeployer.barFeeTo();
        barFee = _masterDeployer.barFee();
        masterDeployer = _masterDeployer;
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    // The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 _liquidity) {
        MintParams memory mintParams = abi.decode(data, (MintParams));

        uint256 priceLower = uint256(TickMath.getSqrtRatioAtTick(mintParams.lower));
        uint256 priceUpper = uint256(TickMath.getSqrtRatioAtTick(mintParams.upper));
        uint256 currentPrice = uint256(price);

        _liquidity = DyDxMath.getLiquidityForAmounts(
            priceLower,
            priceUpper,
            currentPrice,
            mintParams.amount1Desired,
            mintParams.amount0Desired
        );

        {
            require(_liquidity <= MAX_TICK_LIQUIDITY, ""LIQUIDITY_OVERFLOW"");

            (uint256 amount0fees, uint256 amount1fees) = _updatePosition(
                mintParams.positionOwner,
                mintParams.lower,
                mintParams.upper,
                int128(uint128(_liquidity))
            );
            if (amount0fees > 0) {
                _transfer(token0, amount0fees, mintParams.positionOwner, false);
                reserve0 -= uint128(amount0fees);
            }
            if (amount1fees > 0) {
                _transfer(token1, amount1fees, mintParams.positionOwner, false);
                reserve1 -= uint128(amount1fees);
            }
        }

        unchecked {
            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);
        }

        _ensureTickSpacing(mintParams.lower, mintParams.upper);
        nearestTick = Ticks.insert(
            ticks,
            feeGrowthGlobal0,
            feeGrowthGlobal1,
            secondsPerLiquidity,
            mintParams.lowerOld,
            mintParams.lower,
            mintParams.upperOld,
            mintParams.upper,
            uint128(_liquidity),
            nearestTick,
            uint160(currentPrice)
        );

        (uint128 amount0Actual, uint128 amount1Actual) = _getAmountsForLiquidity(priceLower, priceUpper, currentPrice, _liquidity);

        ITridentRouter.TokenInput[] memory callbackData = new ITridentRouter.TokenInput[](2);
        callbackData[0] = ITridentRouter.TokenInput(token0, mintParams.token0native, amount0Actual);
        callbackData[1] = ITridentRouter.TokenInput(token1, mintParams.token1native, amount1Actual);

        ITridentCallee(msg.sender).tridentMintCallback(abi.encode(callbackData));

        unchecked {
            if (amount0Actual != 0) {
                require(amount0Actual + reserve0 <= _balance(token0), ""TOKEN0_MISSING"");
                reserve0 += amount0Actual;
            }

            if (amount1Actual != 0) {
                require(amount1Actual + reserve1 <= _balance(token1), ""TOKEN1_MISSING"");
                reserve1 += amount1Actual;
            }
        }

        (uint256 feeGrowth0, uint256 feeGrowth1) = rangeFeeGrowth(mintParams.lower, mintParams.upper);

        if (mintParams.positionRecipient != address(0)) {
            IPositionManager(mintParams.positionOwner).positionMintCallback(
                mintParams.positionRecipient,
                mintParams.lower,
                mintParams.upper,
                uint128(_liquidity),
                feeGrowth0,
                feeGrowth1
            );
        }

        emit Mint(mintParams.positionOwner, amount0Actual, amount1Actual, mintParams.positionRecipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(
            data,
            (int24, int24, uint128, address, bool)
        );

        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);
        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);
        uint160 currentPrice = price;

        unchecked {
            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;
        }

        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(
            uint256(priceLower),
            uint256(priceUpper),
            uint256(currentPrice),
            uint256(amount)
        );

        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));

        unchecked {
            amount0 += amount0fees;
            amount1 += amount1fees;
        }

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});

        unchecked {
            reserve0 -= uint128(amount0fees);
            reserve1 -= uint128(amount1fees);
        }

        _transferBothTokens(recipient, amount0, amount1, unwrapBento);

        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    function burnSingle(bytes calldata) public override returns (uint256) {
        revert();
    }

    function collect(
        int24 lower,
        int24 upper,
        address recipient,
        bool unwrapBento
    ) public lock returns (uint256 amount0fees, uint256 amount1fees) {
        (amount0fees, amount1fees) = _updatePosition(msg.sender, lower, upper, 0);

        _transferBothTokens(recipient, amount0fees, amount1fees, unwrapBento);

        reserve0 -= uint128(amount0fees);
        reserve1 -= uint128(amount1fees);

        emit Collect(msg.sender, amount0fees, amount1fees);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage
    // - price is √(y/x)
    // - x is token0
    // - zero for one -> price will move down.
    function swap(bytes memory data) public override lock returns (uint256 amountOut) {
        (bool zeroForOne, uint256 inAmount, address recipient, bool unwrapBento) = abi.decode(data, (bool, uint256, address, bool));

        SwapCache memory cache = SwapCache({
            feeAmount: 0,
            totalFeeAmount: 0,
            protocolFee: 0,
            feeGrowthGlobal: zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0,
            currentPrice: uint256(price),
            currentLiquidity: uint256(liquidity),
            input: inAmount,
            nextTickToCross: zeroForOne ? nearestTick : ticks[nearestTick].nextTick
        });

        {
            uint256 timestamp = block.timestamp;
            uint256 diff = timestamp - uint256(lastObservation); 
            /// @dev Underflow in 2106.
            if (diff > 0 && liquidity > 0) {
                lastObservation = uint32(timestamp);
                secondsPerLiquidity += uint160((diff << 128) / liquidity);
            }
        }

        while (cache.input != 0) {
            uint256 nextTickPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));
            uint256 output = 0;
            bool cross = false;

            if (zeroForOne) {
                // Trading token 0 (x) for token 1 (y).
                // Price is decreasing.
                // Maximum input amount within current tick range: Δx = Δ(1/√𝑃) · L.
                uint256 maxDx = DyDxMath.getDx(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);

                if (cache.input <= maxDx) {
                    // We can swap within the current range.
                    uint256 liquidityPadded = cache.currentLiquidity << 96;
                    // Calculate new price after swap: √𝑃[new] =  L · √𝑃 / (L + Δx · √𝑃)
                    // This is derrived from Δ(1/√𝑃) = Δx/L
                    // where Δ(1/√𝑃) is 1/√𝑃[old] - 1/√𝑃[new] and we solve for √𝑃[new].
                    // In case of an owerflow we can use: √𝑃[new] = L / (L / √𝑃 + Δx).
                    // This is derrived by dividing the original fraction by √𝑃 on both sides.
                    uint256 newPrice = uint256(
                        FullMath.mulDivRoundingUp(liquidityPadded, cache.currentPrice, liquidityPadded + cache.currentPrice * cache.input)
                    );

                    if (!(nextTickPrice <= newPrice && newPrice < cache.currentPrice)) {
                        // Overflow. We use a modified version of the formula.
                        newPrice = uint160(UnsafeMath.divRoundingUp(liquidityPadded, liquidityPadded / cache.currentPrice + cache.input));
                    }
                    // Based on the price difference calculate the output of th swap: Δy = Δ√P · L.
                    output = DyDxMath.getDy(cache.currentLiquidity, newPrice, cache.currentPrice, false);
                    cache.currentPrice = newPrice;
                    cache.input = 0;
                } else {
                    // Execute swap step and cross the tick.
                    output = DyDxMath.getDy(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);
                    cache.currentPrice = nextTickPrice;
                    cross = true;
                    cache.input -= maxDx;
                }
            } else {
                // Price is increasing.
                // Maximum swap amount within the current tick range: Δy = Δ√P · L.
                uint256 maxDy = DyDxMath.getDy(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);

                if (cache.input <= maxDy) {
                    // We can swap within the current range.
                    // Calculate new price after swap: ΔP = Δy/L.
                    uint256 newPrice = cache.currentPrice +
                        FullMath.mulDiv(cache.input, 0x1000000000000000000000000, cache.currentLiquidity);
                    /// @dev Calculate output of swap
                    // - Δx = Δ(1/√P) · L.
                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, newPrice, false);
                    cache.currentPrice = newPrice;
                    cache.input = 0;
                } else {
                    /// @dev Swap & cross the tick.
                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);
                    cache.currentPrice = nextTickPrice;
                    cross = true;
                    cache.input -= maxDy;
                }
            }
            (cache.totalFeeAmount, amountOut, cache.protocolFee, cache.feeGrowthGlobal) = SwapLib.handleFees(
                output,
                swapFee,
                barFee,
                cache.currentLiquidity,
                cache.totalFeeAmount,
                amountOut,
                cache.protocolFee,
                cache.feeGrowthGlobal
            );
            if (cross) {
                (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(
                    ticks,
                    cache.nextTickToCross,
                    secondsPerLiquidity,
                    cache.currentLiquidity,
                    cache.feeGrowthGlobal,
                    zeroForOne
                );
                if (cache.currentLiquidity == 0) {
                    // We step into a zone that has liquidity - or we reach the end of the linked list.
                    cache.currentPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));
                    (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(
                        ticks,
                        cache.nextTickToCross,
                        secondsPerLiquidity,
                        cache.currentLiquidity,
                        cache.feeGrowthGlobal,
                        zeroForOne
                    );
                }
            }
        }

        price = uint160(cache.currentPrice);

        int24 newNearestTick = zeroForOne ? cache.nextTickToCross : ticks[cache.nextTickToCross].previousTick;

        if (nearestTick != newNearestTick) {
            nearestTick = newNearestTick;
            liquidity = uint128(cache.currentLiquidity);
        }

        _updateReserves(zeroForOne, uint128(inAmount), amountOut);

        _updateFees(zeroForOne, cache.feeGrowthGlobal, uint128(cache.protocolFee));

        if (zeroForOne) {
            _transfer(token1, amountOut, recipient, unwrapBento);
            emit Swap(recipient, token0, token1, inAmount, amountOut);
        } else {
            _transfer(token0, amountOut, recipient, unwrapBento);
            emit Swap(recipient, token1, token0, inAmount, amountOut);
        }
    }

    /// @dev Reserved for IPool.
    function flashSwap(bytes calldata) public override returns (uint256) {
        revert();
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        barFee = IMasterDeployer(masterDeployer).barFee();
    }

    /// @dev Collects fees for Trident protocol.
    function collectProtocolFee() public lock returns (uint128 amount0, uint128 amount1) {
        if (token0ProtocolFee > 1) {
            amount0 = token0ProtocolFee - 1;
            token0ProtocolFee = 1;
            reserve0 -= amount0;
            _transfer(token0, amount0, barFeeTo, false);
        }
        if (token1ProtocolFee > 1) {
            amount1 = token1ProtocolFee - 1;
            token1ProtocolFee = 1;
            reserve1 -= amount1;
            _transfer(token1, amount1, barFeeTo, false);
        }
    }

    function _ensureTickSpacing(int24 lower, int24 upper) internal view {
        require(lower % int24(tickSpacing) == 0, ""INVALID_TICK"");
        require((lower / int24(tickSpacing)) % 2 == 0, ""LOWER_EVEN"");

        require(upper % int24(tickSpacing) == 0, ""INVALID_TICK"");
        require((upper / int24(tickSpacing)) % 2 != 0, ""UPPER_ODD""); 
        /// @dev Can be either -1 or 1.
    }

    function _getAmountsForLiquidity(
        uint256 priceLower,
        uint256 priceUpper,
        uint256 currentPrice,
        uint256 liquidityAmount
    ) internal pure returns (uint128 token0amount, uint128 token1amount) {
        if (priceUpper <= currentPrice) {
            /// @dev Only supply `token1` (`token1` is Y).
            token1amount = uint128(DyDxMath.getDy(liquidityAmount, priceLower, priceUpper, true));
        } else if (currentPrice <= priceLower) {
            /// @dev Only supply `token0` (`token0` is X).
            token0amount = uint128(DyDxMath.getDx(liquidityAmount, priceLower, priceUpper, true));
        } else {
            /// @dev Supply both tokens.
            token0amount = uint128(DyDxMath.getDx(liquidityAmount, currentPrice, priceUpper, true));
            token1amount = uint128(DyDxMath.getDy(liquidityAmount, priceLower, currentPrice, true));
        }
    }

    function _updateReserves(
        bool zeroForOne,
        uint128 inAmount,
        uint256 amountOut
    ) internal {
        if (zeroForOne) {
            uint256 balance0 = _balance(token0);
            uint128 newBalance = reserve0 + inAmount;
            require(uint256(newBalance) <= balance0, ""TOKEN0_MISSING"");
            reserve0 = newBalance;
            reserve1 -= uint128(amountOut);
        } else {
            uint256 balance1 = _balance(token1);
            uint128 newBalance = reserve1 + inAmount;
            require(uint256(newBalance) <= balance1, ""TOKEN1_MISSING"");
            reserve1 = newBalance;
            reserve0 -= uint128(amountOut);
        }
    }

    function _updateFees(
        bool zeroForOne,
        uint256 feeGrowthGlobal,
        uint128 protocolFee
    ) internal {
        if (zeroForOne) {
            feeGrowthGlobal1 = feeGrowthGlobal;
            token1ProtocolFee += protocolFee;
        } else {
            feeGrowthGlobal0 = feeGrowthGlobal;
            token0ProtocolFee += protocolFee;
        }
    }

    function _updatePosition(
        address owner,
        int24 lower,
        int24 upper,
        int128 amount
    ) internal returns (uint256 amount0fees, uint256 amount1fees) {
        Position storage position = positions[owner][lower][upper];

        (uint256 growth0current, uint256 growth1current) = rangeFeeGrowth(lower, upper);
        amount0fees = FullMath.mulDiv(
            growth0current - position.feeGrowthInside0Last,
            position.liquidity,
            0x100000000000000000000000000000000
        );

        amount1fees = FullMath.mulDiv(
            growth1current - position.feeGrowthInside1Last,
            position.liquidity,
            0x100000000000000000000000000000000
        );

        if (amount < 0) position.liquidity -= uint128(-amount);
        if (amount > 0) position.liquidity += uint128(amount);

        require(position.liquidity < MAX_TICK_LIQUIDITY, ""MAX_TICK_LIQUIDITY"");

        position.feeGrowthInside0Last = growth0current;
        position.feeGrowthInside1Last = growth1current;
    }

    function _balance(address token) internal view returns (uint256 balance) {
        balance = bento.balanceOf(token, address(this));
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token, address(this), to, 0, shares);
        } else {
            bento.transfer(token, address(this), to, shares);
        }
    }

    function _transferBothTokens(
        address to,
        uint256 shares0,
        uint256 shares1,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token0, address(this), to, 0, shares0);
            bento.withdraw(token1, address(this), to, 0, shares1);
        } else {
            bento.transfer(token0, address(this), to, shares0);
            bento.transfer(token1, address(this), to, shares1);
        }
    }

    /// @dev Generic formula for fee growth inside a range: (globalGrowth - growthBelow - growthAbove)
    // - available counters: global, outside u, outside v.

    //                  u         ▼         v
    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - feeGrowthOutside(v))

    //             ▼    u                   v
    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - (global - feeGrowthOutside(u)) - feeGrowthOutside(v))

    //                  u                   v    ▼
    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - (global - feeGrowthOutside(v)))

    /// @notice Calculates the fee growth inside a range (per unit of liquidity).
    /// @dev Multiply `rangeFeeGrowth` delta by the provided liquidity to get accrued fees for some period.
    function rangeFeeGrowth(int24 lowerTick, int24 upperTick) public view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {
        int24 currentTick = nearestTick;

        Ticks.Tick storage lower = ticks[lowerTick];
        Ticks.Tick storage upper = ticks[upperTick];

        /// @dev Calculate fee growth below & above.
        uint256 _feeGrowthGlobal0 = feeGrowthGlobal0;
        uint256 _feeGrowthGlobal1 = feeGrowthGlobal1;
        uint256 feeGrowthBelow0;
        uint256 feeGrowthBelow1;
        uint256 feeGrowthAbove0;
        uint256 feeGrowthAbove1;

        if (lowerTick <= currentTick) {
            feeGrowthBelow0 = lower.feeGrowthOutside0;
            feeGrowthBelow1 = lower.feeGrowthOutside1;
        } else {
            feeGrowthBelow0 = _feeGrowthGlobal0 - lower.feeGrowthOutside0;
            feeGrowthBelow1 = _feeGrowthGlobal1 - lower.feeGrowthOutside1;
        }

        if (currentTick < upperTick) {
            feeGrowthAbove0 = upper.feeGrowthOutside0;
            feeGrowthAbove1 = upper.feeGrowthOutside1;
        } else {
            feeGrowthAbove0 = _feeGrowthGlobal0 - upper.feeGrowthOutside0;
            feeGrowthAbove1 = _feeGrowthGlobal1 - upper.feeGrowthOutside1;
        }

        feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;
        feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;
    }

    function rangeSecondsInside(int24 lowerTick, int24 upperTick) public view returns (uint256 secondsInside) {
        int24 currentTick = nearestTick;

        Ticks.Tick storage lower = ticks[lowerTick];
        Ticks.Tick storage upper = ticks[upperTick];

        uint256 secondsGlobal = secondsPerLiquidity;
        uint256 secondsBelow;
        uint256 secondsAbove;

        if (lowerTick <= currentTick) {
            secondsBelow = lower.secondsPerLiquidityOutside;
        } else {
            secondsBelow = secondsGlobal - lower.secondsPerLiquidityOutside;
        }

        if (currentTick < upperTick) {
            secondsAbove = upper.secondsPerLiquidityOutside;
        } else {
            secondsAbove = secondsGlobal - upper.secondsPerLiquidityOutside;
        }

        secondsInside = secondsGlobal - secondsBelow - secondsAbove;
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    /// @dev Reserved for IPool.
    function getAmountOut(bytes calldata) public pure override returns (uint256) {
        revert();
    }

    function getImmutables()
        public
        view
        returns (
            uint128 _MAX_TICK_LIQUIDITY,
            uint24 _tickSpacing,
            uint24 _swapFee,
            address _barFeeTo,
            IBentoBoxMinimal _bento,
            IMasterDeployer _masterDeployer,
            address _token0,
            address _token1
        )
    {
        _MAX_TICK_LIQUIDITY = MAX_TICK_LIQUIDITY;
        _tickSpacing = tickSpacing;
        _swapFee = swapFee; 
        /// @dev 1000 corresponds to 0.1% fee.
        _barFeeTo = barFeeTo;
        _bento = bento;
        _masterDeployer = masterDeployer;
        _token0 = token0;
        _token1 = token1;
    }

    function getPriceAndNearestTicks() public view returns (uint160 _price, int24 _nearestTick) {
        _price = price;
        _nearestTick = nearestTick;
    }

    function getTokenProtocolFees() public view returns (uint128 _token0ProtocolFee, uint128 _token1ProtocolFee) {
        _token0ProtocolFee = token0ProtocolFee;
        _token1ProtocolFee = token1ProtocolFee;
    }

    function getReserves() public view returns (uint128 _reserve0, uint128 _reserve1) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
    }

    function getLiquidityAndLastObservation() public view returns (uint160 _secondsPerLiquidity, uint32 _lastObservation) {
        _secondsPerLiquidity = secondsPerLiquidity;
        _lastObservation = lastObservation;
    }
}",6742,725,"H-01: Unsafe cast in ConcentratedLiquidityPool.burn leads to attack H-04: Overflow in the mint function of ConcentratedLiquidityPool causes LPs' funds to be stolen L204 L209 H-05: Incorrect usage of typecasting in _getAmountsForLiquidity lets an attacker steal funds from the pool. L480 H-07: ConcentratedLiquidityPosition.sol#burn() Wrong implementation allows attackers to steal yield. L553 H-09: range fee growth underflow. L601 H-10: ConcentratedLiquidityPool.burn() Wrong implementation  L267 H-11: ConcentratedLiquidityPool: incorrect feeGrowthGlobal accounting when crossing ticks H-12: ConcentratedLiquidityPool: secondsPerLiquidity should be modified whenever pool liquidity changes H-13: Burning does not update reserves H-14: ConcentratedLiquidityPool: rangeFeeGrowth and secondsPerLiquidity math needs to be unchecked H-15: ConcentratedLiquidityPool: initialPrice should be checked to be within allowable range",11
22_LongShort.sol,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/ITokenFactory.sol"";
import ""./interfaces/ISyntheticToken.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IYieldManager.sol"";
import ""./interfaces/IOracleManager.sol"";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, ""only admin"");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], ""market doesn't exist"");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Up "", syntheticName)),
      string(abi.encodePacked(""fu"", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Down "", syntheticName)),
      string(abi.encodePacked(""fd"", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      ""Insufficient market seed""
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], ""already initialized"");
    require(marketIndex <= latestMarket, ""index too high"");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - ""Pending"" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - ""Confirmed"" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - ""Settled"" - there is no more computation left for the user.
        - ""Non-existant"" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}",13680,1242,"H-01: copy paste error in _batchConfirmOutstandingPendingActions  L1126 M-01: latestMarket used where marketIndex should have been used. L304 M-02: Incorrect balance computed in getUsersConfirmedButNotSettledSynthBalance().  L532",3
16_TracerPerpetualsFactory.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./Interfaces/ITracerPerpetualSwaps.sol"";
import ""./Interfaces/IPricing.sol"";
import ""./Interfaces/ILiquidation.sol"";
import ""./Interfaces/IInsurance.sol"";
import ""./Interfaces/ITracerPerpetualsFactory.sol"";
import ""./Interfaces/deployers/IPerpsDeployer.sol"";
import ""./Interfaces/deployers/ILiquidationDeployer.sol"";
import ""./Interfaces/deployers/IInsuranceDeployer.sol"";
import ""./Interfaces/deployers/IPricingDeployer.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TracerPerpetualsFactory is Ownable, ITracerPerpetualsFactory {
    uint256 public tracerCounter;
    address public perpsDeployer;
    address public liquidationDeployer;
    address public insuranceDeployer;
    address public pricingDeployer;

    // Index of Tracer (where 0 is index of first Tracer market), corresponds to tracerCounter => market address
    mapping(uint256 => address) public override tracersByIndex;
    // Tracer market => whether that address is a valid Tracer or not
    mapping(address => bool) public override validTracers;
    // Tracer market => whether this address is a DAO approved market.
    // note markets deployed by the DAO are by default approved
    mapping(address => bool) public override daoApproved;

    event TracerDeployed(bytes32 indexed marketId, address indexed market);

    constructor(
        address _perpsDeployer,
        address _liquidationDeployer,
        address _insuranceDeployer,
        address _pricingDeployer,
        address _governance
    ) {
        setPerpsDeployerContract(_perpsDeployer);
        setLiquidationDeployerContract(_liquidationDeployer);
        setInsuranceDeployerContract(_insuranceDeployer);
        setPricingDeployerContract(_pricingDeployer);
        transferOwnership(_governance);
    }

    /**
     * @notice Allows any user to deploy a tracer market
     * @param _data The data that will be used as constructor parameters for the new Tracer market.
     */
    function deployTracer(
        bytes calldata _data,
        address oracle,
        address fastGasOracle,
        uint256 maxLiquidationSlippage
    ) external {
        _deployTracer(_data, msg.sender, oracle, fastGasOracle, maxLiquidationSlippage);
    }

    /**
     * @notice Allows the Tracer DAO to deploy a DAO approved Tracer market
     * @param _data The data that will be used as constructor parameters for the new Tracer market.
     */
    function deployTracerAndApprove(
        bytes calldata _data,
        address oracle,
        address fastGasOracle,
        uint256 maxLiquidationSlippage
    ) external onlyOwner() {
        address tracer = _deployTracer(_data, owner(), oracle, fastGasOracle, maxLiquidationSlippage);
        // DAO deployed markets are automatically approved
        setApproved(address(tracer), true);
    }

    /**
     * @notice internal function for the actual deployment of a Tracer market.
     */
    function _deployTracer(
        bytes calldata _data,
        address tracerOwner,
        address oracle,
        address fastGasOracle,
        uint256 maxLiquidationSlippage
    ) internal returns (address) {
        // Create and link tracer to factory
        address market = IPerpsDeployer(perpsDeployer).deploy(_data);
        ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);

        validTracers[market] = true;
        tracersByIndex[tracerCounter] = market;
        tracerCounter++;

        // Instantiate Insurance contract for tracer
        address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);
        address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);
        address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(
            pricing,
            market,
            insurance,
            fastGasOracle,
            maxLiquidationSlippage
        );

        // Perform admin operations on the tracer to finalise linking
        tracer.setInsuranceContract(insurance);
        tracer.setPricingContract(pricing);
        tracer.setLiquidationContract(liquidation);

        // Ownership either to the deployer or the DAO
        tracer.transferOwnership(tracerOwner);
        ILiquidation(liquidation).transferOwnership(tracerOwner);
        emit TracerDeployed(tracer.marketId(), address(tracer));
        return market;
    }

    /**
     * @notice Sets the perpsDeployer contract for tracers markets.
     * @param newDeployer the new perpsDeployer contract address
     */
    function setPerpsDeployerContract(address newDeployer) public override onlyOwner() {
        require(newDeployer != address(0), ""address(0) given"");
        perpsDeployer = newDeployer;
    }

    function setInsuranceDeployerContract(address newInsuranceDeployer) public override onlyOwner() {
        require(newInsuranceDeployer != address(0), ""address(0) given"");
        insuranceDeployer = newInsuranceDeployer;
    }

    function setPricingDeployerContract(address newPricingDeployer) public override onlyOwner() {
        require(newPricingDeployer != address(0), ""address(0) given"");
        pricingDeployer = newPricingDeployer;
    }

    function setLiquidationDeployerContract(address newLiquidationDeployer) public override onlyOwner() {
        require(newLiquidationDeployer != address(0), ""address(0) given"");
        liquidationDeployer = newLiquidationDeployer;
    }

    /**
     * @notice Sets a contracts approval by the DAO. This allows the factory to
     *         identify contracts that the DAO has ""absorbed"" into its control
     * @dev requires the contract to be owned by the DAO if being set to true.
     */
    function setApproved(address market, bool value) public override onlyOwner() {
        if (value) {
            require(Ownable(market).owner() == owner(), ""TFC: Owner not DAO"");
        }
        daoApproved[market] = value;
    }
}",1338,151,H-04: Logic error in fee subtraction,1
68_SingleTokenJoinV2.sol,"//SPDX-License-Identifier: Unlicense
pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {IPangolinRouter} from ""@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol"";

import ""../interfaces/IBasketFacet.sol"";

contract SingleTokenJoinV2 {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    // Can be any IPangolinRouter or IUniRouter ...
    IPangolinRouter public immutable uniSwapLikeRouter;
    // WETH or WAVAX ...
    IERC20 public immutable INTERMEDIATE_TOKEN;

    struct UnderlyingTrade {
        UniswapV2SwapStruct[] swaps;
        uint256 quantity; 
        //Quantity to buy
    }

    struct UniswapV2SwapStruct {
        address exchange;
        address[] path;
    }
    struct JoinTokenStructV2 {
        address inputToken;
        address outputBasket;
        uint256 inputAmount;
        uint256 outputAmount;
        UnderlyingTrade[] trades;
        uint256 deadline;
        uint16 referral;
    }

    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {
        require(_INTERMEDIATE_TOKEN != address(0), ""INTERMEDIATE_ZERO"");
        require(_uniSwapLikeRouter != address(0), ""UNI_ROUTER_ZERO"");

        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);
        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);
    }

    function _maxApprove(IERC20 token, address spender) internal {
        if (
            token.allowance(address(this), spender) <
            token.balanceOf(address(this))
        ) {
            token.approve(spender, uint256(-1));
        }
    }

    function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)
        external
    {
        // ######## INIT TOKEN #########
        IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);

        inputToken.safeTransferFrom(
            msg.sender,
            address(this),
            _joinTokenStruct.inputAmount
        );

        _joinTokenSingle(_joinTokenStruct);

        // ######## SEND TOKEN #########
        uint256 remainingIntermediateBalance = inputToken.balanceOf(
            address(this)
        );
        if (remainingIntermediateBalance > 0) {
            inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);
        }
    }

    function _joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)
        internal
    {
        // ######## INIT TOKEN #########
        IERC20 outputToken = IERC20(_joinTokenStruct.outputBasket);

        for (uint256 i; i < _joinTokenStruct.trades.length; i++) {
            UnderlyingTrade calldata trade = _joinTokenStruct.trades[i];
            uint256[] memory inputs = new uint256[](trade.swaps.length + 1);
            inputs[0] = trade.quantity;
            //Get inputs to
            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[
                    trade.swaps.length - j - 1
                ];
                uint256[] memory amounts = IPangolinRouter(swap.exchange)
                    .getAmountsIn(inputs[j], swap.path);
                inputs[j + 1] = amounts[0];
            }

            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[j];
                uint256 amountIn = inputs[trade.swaps.length - j];
                _maxApprove(IERC20(swap.path[0]), address(swap.exchange));
                IPangolinRouter(swap.exchange).swapExactTokensForTokens(
                    amountIn,
                    0,
                    swap.path,
                    address(this),
                    block.timestamp
                );
            }
        }

        address[] memory tokens = IBasketFacet(_joinTokenStruct.outputBasket)
            .getTokens();

        for (uint256 i; i < tokens.length; i++) {
            _maxApprove(IERC20(tokens[i]), _joinTokenStruct.outputBasket);
        }

        IBasketFacet(_joinTokenStruct.outputBasket).joinPool(
            _joinTokenStruct.outputAmount,
            _joinTokenStruct.referral
        );

        // ######## SEND TOKEN #########

        uint256 outputAmount = outputToken.balanceOf(address(this));
        require(
            outputAmount == _joinTokenStruct.outputAmount,
            ""FAILED_OUTPUT_AMOUNT""
        );
        outputToken.safeTransfer(msg.sender, outputAmount);
    }
}",1021,137,"H-01: Unused ERC20 tokens are not refunded, and can be stolen by attacker. L57-L78 M-02: Unchecked return value from low-level call(). L26 M-06: block.timestamp or deadline.  L158-L203",3
83_MasterChef.sol,"// SPDX-License-Identifier: MIT


pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

contract MasterChef is Ownable, ReentrancyGuard {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    event Deposit(address indexed _user, uint indexed _pid, uint _amount);
    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);
    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);

    struct UserInfo {
        uint128 amount; 
        // How many tokens the user has provided.
        uint128 rewardDebt; 
        // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of RADSs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 depositToken; 
        // Address of LP token contract.
        uint allocPoint; 
        // How many allocation points assigned to this pool. to distribute per block.
        uint lastRewardBlock; 
        // Last block number that distribution occurs.
        uint accConcurPerShare; 
        // Accumulated per share, times multiplier. See below.
        uint16 depositFeeBP; 
        // Deposit fee in basis points
    }

    PoolInfo[] public poolInfo;
    mapping(uint => mapping(address => UserInfo)) public userInfo; 
    // Info of each user that stakes LP tokens.
    mapping(address => bool) public isDepositor;
    mapping(address => uint256) public pid; 
    // pid mapped to token
    uint public concurPerBlock = 100000 gwei; 
    // concur tokens transferred per block
    uint public totalAllocPoint = 0; 
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint public startBlock;
    uint public endBlock; 
    // The block number when mining starts.
    IERC20 public concur;

    uint private _concurShareMultiplier = 1e18;
    uint private _perMille = 1000; 
    // 100%

    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {
        startBlock = _startBlock;
        endBlock = _endBlock;
        concur = _concur;
        poolInfo.push(
            PoolInfo({
            depositToken: IERC20(address(0)),
            allocPoint : 0,
            lastRewardBlock : _startBlock,
            accConcurPerShare : 0,
            depositFeeBP : 0
        }));
    }

    modifier onlyDepositor() {
        require(isDepositor[msg.sender], ""!depositor"");
        _;
    }

    function addDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = true;
    }

    function removeDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = false;
    }

    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {
        require(_token != address(0), ""zero address"");
        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocationPoints);
        require(pid[_token] == 0, ""already registered""); 
        // pid starts from 0
        poolInfo.push(
            PoolInfo({
                depositToken: IERC20(_token),
                allocPoint: _allocationPoints,
                lastRewardBlock: lastRewardBlock,
                accConcurPerShare: 0,
                depositFeeBP: _depositFee
            })
        );
        pid[_token] = poolInfo.length - 1;
    }

    function poolLength() external view returns (uint) {
        return poolInfo.length;
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint _from, uint _to) public pure returns (uint) {
        return _to.sub(_from);
    }

    // View function to see pending [concur] on frontend.
    function pendingConcur(uint _pid, address _user) external view returns (uint) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint accConcurPerShare = pool.accConcurPerShare;
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        }
        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
    }

    // Update reward variables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint length = poolInfo.length;
        for (uint _pid = 0; _pid < length; ++_pid) {
            updatePool(_pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (lpSupply == 0 || pool.allocPoint == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        if(block.number >= endBlock) {
            pool.lastRewardBlock = block.number;
            return;
        }        

        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // Deposit tokens for [concur] allocation.  
    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        updatePool(_pid);
       
        if(user.amount > 0) {  
            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
            if (pending > 0) {
                safeConcurTransfer(_recipient, pending);
            }
        }

        if (_amount > 0) {
            if (pool.depositFeeBP > 0) {
                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);
                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);
            } else {
                user.amount = SafeCast.toUint128(user.amount + _amount);
            }
        }     

        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Deposit(_recipient, _pid, _amount);
    }

    // Withdraw tokens
    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        require(user.amount > 0, ""MasterChef: nothing to withdraw"");
        require(user.amount >= _amount, ""MasterChef: withdraw not allowed"");
        updatePool(_pid);

        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
        if(pending > 0) {
            safeConcurTransfer(_recipient, pending);
        }
        if (_amount > 0) {
            user.amount = SafeCast.toUint128(user.amount - _amount);
        }
        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Withdraw(_recipient, _pid, _amount);
    }

    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough
    function safeConcurTransfer(address _to, uint _amount) private {
        uint concurBalance = concur.balanceOf(address(this));
        bool transferSuccess = false;
        if (_amount > concurBalance) {
            transferSuccess = concur.transfer(_to, concurBalance);
        } else {
            transferSuccess = concur.transfer(_to, _amount);
        }
        require(transferSuccess, ""safeConcurTransfer: transfer failed"");
    }
}",2120,227,"H-01: Wrong reward token calculation in MasterChef contract.  L86 H-02: Masterchef: Improper handling of deposit fee.  L170-172 H-04: ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver  L159-167 H-08: MasterChef.sol Users won't be able to receive the concur rewards M-02: Unconstrained fee. L86 M-14: Owner can steal Concur rewards. L78 L157 M-15: Owner can lock tokens in MasterChef. L82 M-16: Rewards get diluted because totalAllocPoint can only increase.   M-18: Users Will Lose Concur Rewards If The Shelter Mechanism Is Enacted On A Pool M-20: MasterChef.updatePool() Fails To Update Reward Variables If block.number >= endBlock  L135 M-27: MasterChef.sol A depositor can deposit an arbitrary amount without no cost  L78 M-28: During stake or deposit, users would not be rewarded the correct Concur token, when MasterChef has under-supply of it",12
71_IndexTemplate.sol,"pragma solidity 0.8.7;
/**
 * @author InsureDAO
 * @title InsureDAO market template contract
 * SPDX-License-Identifier: GPL-3.0
 */
 import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./InsureDAOERC20.sol"";
import ""./interfaces/IIndexTemplate.sol"";
import ""./interfaces/IUniversalMarket.sol"";

import ""./interfaces/IVault.sol"";
import ""./interfaces/IRegistry.sol"";
import ""./interfaces/IParameters.sol"";
import ""./interfaces/IPoolTemplate.sol"";
import ""./interfaces/ICDSTemplate.sol"";

/**
 * An index pool can index a certain number of pools with leverage.
 *
 * Index A
 * 　├ Pool A
 * 　├ Pool B
 * 　├ Pool C
 * 　...
 *
 */

contract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {
    /**
     * EVENTS
     */
    event Deposit(address indexed depositor, uint256 amount, uint256 mint);
    event WithdrawRequested(
        address indexed withdrawer,
        uint256 amount,
        uint256 time
    );
    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);
    event Compensated(address indexed index, uint256 amount);
    event Paused(bool paused);
    event Resumed();
    event Locked();
    event MetadataChanged(string metadata);
    event LeverageSet(uint256 target);
    event AllocationSet(
        uint256 indexed _index,
        address indexed pool,
        uint256 allocPoint
    );

    /**
     * Storage
     */
    /// @notice Market setting
    bool public initialized;
    bool public paused;
    bool public locked;
    uint256 public pendingEnd;
    string public metadata;

    /// @notice External contract call addresses
    IParameters public parameters;
    IVault public vault;
    IRegistry public registry;

    /// @notice Market variables for margin account
    uint256 public totalAllocatedCredit; 
    //total allocated credit(liquidity)
    mapping(address => uint256) public allocPoints; 
    //allocation point for each pool
    uint256 public totalAllocPoint; 
    //total allocation point
    address[] public poolList; 
    //list of all pools
    uint256 public targetLev; 
    //1x = MAGIC_SCALE_1E6
    //The allocated credits are deemed as liquidity in each underlying pool
    //Credit amount(liquidity) will be determined by the following math
    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point

    ///@notice user status management
    struct Withdrawal {
        uint256 timestamp;
        uint256 amount;
    }
    mapping(address => Withdrawal) public withdrawalReq;

    struct PoolStatus {
        uint256 current;
        uint256 available;
        uint256 allocation;
        address addr;
    }

    ///@notice magic numbers
    uint256 public constant MAGIC_SCALE_1E6 = 1e6; 
    //internal multiplication scale 1e6 to reduce decimal truncation

    /**
     * @notice Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(
            msg.sender == parameters.getOwner(),
            ""Restricted: caller is not allowed to operate""
        );
        _;
    }

    constructor() {
        initialized = true;
    }

    /**
     * Initialize interaction
     */

    /**
     * @notice Initialize market
     * This function registers market conditions.
     * references[0] = underlying token address
     * references[1] = registry
     * references[2] = parameter
     * @param _metaData arbitrary string to store market information
     * @param _conditions array of conditions
     * @param _references array of references
     */
    function initialize(
        string calldata _metaData,
        uint256[] calldata _conditions,
        address[] calldata _references
    ) external override {
        require(
            initialized == false &&
                bytes(_metaData).length > 0 &&
                _references[0] != address(0) &&
                _references[1] != address(0) &&
                _references[2] != address(0),
            ""ERROR: INITIALIZATION_BAD_CONDITIONS""
        );

        initialized = true;

        string memory _name = ""InsureDAO-Index"";
        string memory _symbol = ""iIndex"";
        uint8 _decimals = IERC20Metadata(_references[0]).decimals();

        initializeToken(_name, _symbol, _decimals);

        parameters = IParameters(_references[2]);
        vault = IVault(parameters.getVault(_references[0]));
        registry = IRegistry(_references[1]);

        metadata = _metaData;
    }

    /**
     * Pool interactions
     */

    /**
     * @notice A liquidity provider supplies collateral to the pool and receives iTokens
     * @param _amount amount of token to deposit
     * @return _mintAmount the amount of iToken minted from the transaction
     */
    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {
        require(locked == false && paused == false, ""ERROR: DEPOSIT_DISABLED"");
        require(_amount > 0, ""ERROR: DEPOSIT_ZERO"");

        uint256 _supply = totalSupply();
        uint256 _totalLiquidity = totalLiquidity();
        vault.addValue(_amount, msg.sender, address(this));

        if (_supply > 0 && _totalLiquidity > 0) {
            _mintAmount = (_amount * _supply) / _totalLiquidity;
        } else if (_supply > 0 && _totalLiquidity == 0) {
            //when
            _mintAmount = _amount * _supply;
        } else {
            _mintAmount = _amount;
        }
        emit Deposit(msg.sender, _amount, _mintAmount);
        //mint iToken
        _mint(msg.sender, _mintAmount);
        uint256 _liquidityAfter = _totalLiquidity + _amount;
        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /
            _liquidityAfter;
        //execut adjustAlloc only when the leverage became below target - lower-slack
        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {
            _adjustAlloc(_liquidityAfter);
        }
    }

    /**
     * @notice A liquidity provider requests withdrawal of collateral
     * @param _amount amount of iToken to burn
     */
    function requestWithdraw(uint256 _amount) external {
        uint256 _balance = balanceOf(msg.sender);
        require(_balance >= _amount, ""ERROR: REQUEST_EXCEED_BALANCE"");
        require(_amount > 0, ""ERROR: REQUEST_ZERO"");
        withdrawalReq[msg.sender].timestamp = block.timestamp;
        withdrawalReq[msg.sender].amount = _amount;
        emit WithdrawRequested(msg.sender, _amount, block.timestamp);
    }

    /**
     * @notice A liquidity provider burns iToken and receives collateral from the pool
     * @param _amount amount of iToken to burn
     * @return _retVal the amount underlying token returned
     */
    function withdraw(uint256 _amount) external returns (uint256 _retVal) {
        //Calculate underlying value

        uint256 _liquidty = totalLiquidity();
        uint256 _lockup = parameters.getLockup(msg.sender);
        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;
        _retVal = (_liquidty * _amount) / totalSupply();
        require(locked == false, ""ERROR: WITHDRAWAL_PENDING"");
        require(
            _requestTime + _lockup < block.timestamp,
            ""ERROR: WITHDRAWAL_QUEUE""
        );
        require(
            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >
                block.timestamp,
            ""ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST""
        );
        require(
            withdrawalReq[msg.sender].amount >= _amount,
            ""ERROR: WITHDRAWAL_EXCEEDED_REQUEST""
        );
        require(_amount > 0, ""ERROR: WITHDRAWAL_ZERO"");

        require(
            _retVal <= withdrawable(),
            ""ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY""
        );

        //reduce requested amount
        withdrawalReq[msg.sender].amount -= _amount;
        //Burn iToken
        _burn(msg.sender, _amount);

        //Check current leverage rate and get updated target total credit allocation
        uint256 _liquidityAfter = _liquidty - _retVal;

        if (_liquidityAfter > 0) {
            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /
                _liquidityAfter;
            //execute adjustAlloc only when the leverage became above target + upper-slack
            if (
                targetLev + parameters.getUpperSlack(address(this)) < _leverage
            ) {
                _adjustAlloc(_liquidityAfter);
            }
        } else {
            _adjustAlloc(0);
        }

        //Withdraw liquidity
        vault.withdrawValue(_retVal, msg.sender);

        emit Withdraw(msg.sender, _amount, _retVal);
    }

    /**
     * @notice Get how much can a user withdraw from this index
     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity
     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market
     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.
     * @return _retVal withdrawable amount
     */
    function withdrawable() public view returns (uint256 _retVal) {
        uint256 _totalLiquidity = totalLiquidity();
        if(_totalLiquidity > 0){
            uint256 _length = poolList.length;
            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;
            uint256 _targetAllocPoint;
            uint256 _targetLockedCreditScore;
            //Check which pool has the lowest available rate and keep stats
            for (uint256 i = 0; i < _length; i++) {
                address _poolAddress = poolList[i];
                uint256 _allocPoint = allocPoints[_poolAddress];
                if (_allocPoint > 0) {
                    uint256 _allocated = IPoolTemplate(_poolAddress)
                        .allocatedCredit(address(this));
                    uint256 _availableBalance = IPoolTemplate(_poolAddress)
                        .availableBalance();
                    //check if some portion of credit is locked
                    if (_allocated > _availableBalance) {
                        uint256 _availableRate = (_availableBalance *
                            MAGIC_SCALE_1E6) / _allocated;
                        uint256 _lockedCredit = _allocated - _availableBalance;
                        if (i == 0 || _availableRate < _lowestAvailableRate) {
                            _lowestAvailableRate = _availableRate;
                            _targetLockedCreditScore = _lockedCredit;
                            _targetAllocPoint = _allocPoint;
                        }
                    }
                }
            }
            //Calculate the return value
            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {
                _retVal = _totalLiquidity;
            } else {
                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;
                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;
                if(_necessaryAmount < _totalLiquidity){
                    _retVal = _totalLiquidity - _necessaryAmount;
                }else{
                    _retVal = 0;
                }
            }
        }
    }

    /**
     * @notice Adjust allocation of credit based on the target leverage rate
     */
    function adjustAlloc() public {
        _adjustAlloc(totalLiquidity());
    }

    /**
     * @notice Internal function to adjust allocation
     * @param _liquidity available liquidity of the index
     * Allocation adjustment of credit is done by the following steps
     * 1)Check total allocatable balance of the index
     * 2)Calculate ideal allocation for each pool
     * 3)Check Current allocated balance for each pool
     * 4)Adjust (withdraw/deposit) allocation for each Pool*
     *
     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,
     * then recalculated available balance and iterate 1)~4) for the remaining.
     *
     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.
     *
     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.
     */
    function _adjustAlloc(uint256 _liquidity) internal {
        //Check current leverage rate and get target total credit allocation
        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;
        uint256 _allocatable = _targetCredit;
        uint256 _allocatablePoints = totalAllocPoint;
        uint256 _length = poolList.length;
        PoolStatus[] memory _poolList = new PoolStatus[](_length);

        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit
        for (uint256 i = 0; i < _length; i++) {
            address _pool = poolList[i];
            if (_pool != address(0)) {
                uint256 _allocation = allocPoints[_pool];
                //Target credit allocation for a pool
                uint256 _target = (_targetCredit * _allocation) /
                    _allocatablePoints;
                //get how much has been allocated for a pool
                uint256 _current = IPoolTemplate(_pool).allocatedCredit(
                    address(this)
                );
                //get how much liquidty is available to withdraw
                uint256 _available = IPoolTemplate(_pool).availableBalance();
                //if needed to withdraw credit but unable, then withdraw all available.
                //Otherwise, skip.
                if (
                    (_current > _target && _current - _target > _available) ||
                    IPoolTemplate(_pool).paused() == true
                ) {
                    IPoolTemplate(_pool).withdrawCredit(_available);
                    totalAllocatedCredit -= _available;
                    _poolList[i].addr = address(0);
                    _allocatable -= _current - _available;
                    _allocatablePoints -= _allocation;
                } else {
                    _poolList[i].addr = _pool;
                    _poolList[i].current = _current;
                    _poolList[i].available = _available;
                    _poolList[i].allocation = _allocation;
                }
            }
        }
        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.
        for (uint256 i = 0; i < _length; i++) {
            if (_poolList[i].addr != address(0)) {
                //Target credit allocation for a pool
                uint256 _target = (_allocatable * _poolList[i].allocation) /
                    _allocatablePoints;
                //get how much has been allocated for a pool
                uint256 _current = _poolList[i].current;
                //get how much liquidty is available to withdraw
                uint256 _available = _poolList[i].available;
                //Withdraw or Deposit credit
                if (_current > _target && _available != 0) {
                    //if allocated credit is higher than the target, try to decrease
                    uint256 _decrease = _current - _target;
                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);
                    totalAllocatedCredit -= _decrease;
                }
                if (_current < _target) {
                    //Sometimes we need to allocate more
                    uint256 _allocate = _target - _current;
                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);
                    totalAllocatedCredit += _allocate;
                }
                if (_current == _target) {
                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);
                }
            }
        }
    }

    /**
     * Insurance interactions
     */

    /**
     * @notice Make a payout if an accident occured in a underlying pool
     * @param _amount amount of liquidity to compensate for the called pool
     * We compensate underlying pools by the following steps
     * 1) Compensate underlying pools from the liquidity of this pool
     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool
     */
    function compensate(uint256 _amount)
        external
        override
        returns (uint256 _compensated)
    {
        require(
            allocPoints[msg.sender] > 0,
            ""ERROR_COMPENSATE_UNAUTHORIZED_CALLER""
        );
        uint256 _value = vault.underlyingValue(address(this));
        if (_value >= _amount) {
            //When the deposited value without earned premium is enough to cover
            vault.offsetDebt(_amount, msg.sender);
            //vault.transferValue(_amount, msg.sender);
            _compensated = _amount;
        } else {
            //Withdraw credit to cashout the earnings
            uint256 _shortage;
            if (totalLiquidity() < _amount) {
                //Insolvency case
                _shortage = _amount - _value;
                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))
                    .compensate(_shortage);
                _compensated = _value + _cds;
            }
            vault.offsetDebt(_compensated, msg.sender);
        }
        adjustAlloc();
        emit Compensated(msg.sender, _compensated);
    }

    /**
     * Reporting interactions
     */

    /**
     * @notice Resume market
     */
    function resume() external override {
        uint256 _poolLength = poolList.length;

        for (uint256 i = 0; i < _poolLength; i++) {
            require(
                IPoolTemplate(poolList[i]).paused() == false,
                ""ERROR: POOL_IS_PAUSED""
            );
        }

        locked = false;
        emit Resumed();
    }

    /**
     * @notice lock market withdrawal
     */
    function lock() external override {
        require(allocPoints[msg.sender] > 0);

        locked = true;
        emit Locked();
    }

    /**
     * Utilities
     */

    /**
     * @notice get the current leverage rate 1e6x
     * @return _rate leverage rate
     */
    function leverage() public view returns (uint256 _rate) {
        //check current leverage rate
        if (totalLiquidity() > 0) {
            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();
        } else {
            return 0;
        }
    }

    /**
     * @notice total Liquidity of the pool (how much can the pool sell cover)
     * @return _balance total liquidity of the pool
     */
    function totalLiquidity() public view returns (uint256 _balance) {
        return vault.underlyingValue(address(this)) + _accruedPremiums();
    }

    /**
     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)
     * @return The value against the underlying token balance.
     */
    function rate() external view returns (uint256) {
        if (totalSupply() > 0) {
            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();
        } else {
            return 0;
        }
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @param _owner the target address to look up value
     * @return The balance of underlying token for the specified address
     */
    function valueOfUnderlying(address _owner) public view returns (uint256) {
        uint256 _balance = balanceOf(_owner);
        if (_balance == 0) {
            return 0;
        } else {
            return (_balance * totalLiquidity()) / totalSupply();
        }
    }

    /**
     * @notice Get all underlying pools
     * @return pool array
     */
    function getAllPools() external view returns (address[] memory) {
        return poolList;
    }

    /**
     * Admin functions
     */

    /**
     * @notice Used for changing settlementFeeRecipient
     * @param _state true to set paused and vice versa
     */
    function setPaused(bool _state) external override onlyOwner {
        if (paused != _state) {
            paused = _state;
            emit Paused(_state);
        }
    }

    /**
     * @notice Change metadata string
     * @param _metadata new metadata string
     */
    function changeMetadata(string calldata _metadata)
        external
        override
        onlyOwner
    {
        metadata = _metadata;
        emit MetadataChanged(_metadata);
    }

    /**
     * @notice Change target leverate rate for this index x 1e6
     * @param _target new leverage rate
     */
    function setLeverage(uint256 _target) external override onlyOwner {
        targetLev = _target;
        adjustAlloc();
        emit LeverageSet(_target);
    }

    /**
     * @notice Change allocation point for each pool
     * @param _index target id of the underlying pool
     * @param _pool address of pool
     * @param _allocPoint new allocation point
     */
    function set(
        uint256 _index,
        address _pool,
        uint256 _allocPoint
    ) public override onlyOwner {
        require(registry.isListed(_pool), ""ERROR:UNREGISTERED_POOL"");
        require(
            _index <= parameters.getMaxList(address(this)),
            ""ERROR: EXCEEEDED_MAX_INDEX""
        );
        uint256 _length = poolList.length;

        //create a new pool or replace existing
        if (_length <= _index) {
            require(_length == _index, ""ERROR: BAD_INDEX"");
            poolList.push(_pool);
        } else {
            address _poolAddress = poolList[_index];
            if (_poolAddress != address(0) && _poolAddress != _pool) {
                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(
                    address(this)
                );
                IPoolTemplate(_poolAddress).withdrawCredit(_current);
            }
            poolList[_index] = _pool;
        }
        if (totalAllocPoint > 0) {
            totalAllocPoint =
                totalAllocPoint -
                allocPoints[_pool] +
                _allocPoint;
        } else {
            totalAllocPoint = _allocPoint;
        }
        allocPoints[_pool] = _allocPoint;
        adjustAlloc();
        emit AllocationSet(_index, _pool, _allocPoint);
    }

    /**
     * Internal functions
     */

    /**
     * @notice Internal function to offset withdraw request and latest balance
     * @param from the account who send
     * @param to a
     * @param amount the amount of token to offset
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        if (from != address(0)) {
            uint256 _after = balanceOf(from) - amount;
            if (_after < withdrawalReq[from].amount) {
                withdrawalReq[from].amount = _after;
            }
        }
    }

    /**
     * @notice Get the total equivalent value of credit to token
     * @return _totalValue accrued but yet claimed premium within underlying pools
     */
    function _accruedPremiums() internal view returns (uint256 _totalValue) {
        for (uint256 i = 0; i < poolList.length; i++) {
            if (allocPoints[poolList[i]] > 0) {
                _totalValue =
                    _totalValue +
                    IPoolTemplate(poolList[i]).pendingPremium(address(this));
            }
        }
    }
}",5171,670,"H-08: IndexTemplate.sol#compensate() will most certainly fail. L438-L447 H-12: IndexTemplate.sol Wrong implementation allows lp of the index pool to resume a locked PayingOut pool and escape the responsibility for the compensation L459-471 M-04: System Debt Is Not Handled When Insurance Pools Become Insolvent. L691",3
112_StakerVault.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../libraries/ScaledMath.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/AddressProviderHelpers.sol"";

import ""../interfaces/IStakerVault.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/tokenomics/IRewardsGauge.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/pool/ILiquidityPool.sol"";
import ""../interfaces/tokenomics/ILpGauge.sol"";
import ""../interfaces/IERC20Full.sol"";

import ""./utils/Preparable.sol"";
import ""./Controller.sol"";
import ""./pool/LiquidityPool.sol"";
import ""./access/Authorization.sol"";
import ""./utils/Pausable.sol"";

/**
 * @notice This contract handles staked tokens from Backd pools
 * However, not that this is NOT an ERC-20 compliant contract and these
 * tokens should never be integrated with any protocol assuming ERC-20 compliant
 * tokens
 * @dev When paused, allows only withdraw/unstake
 */
contract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {
    using AddressProviderHelpers for IAddressProvider;
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;

    bytes32 internal constant _LP_GAUGE = ""lpGauge"";

    IController public immutable controller;

    address public token;

    mapping(address => uint256) public balances;
    mapping(address => uint256) public actionLockedBalances;

    mapping(address => mapping(address => uint256)) internal _allowances;

    // All the data fields required for the staking tracking
    uint256 private _poolTotalStaked;

    mapping(address => bool) public strategies;
    uint256 public strategiesTotalStaked;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        controller = _controller;
    }

    function initialize(address _token) external override initializer {
        token = _token;
    }

    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {
        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);
        _setConfig(_LP_GAUGE, _lpGauge);
        controller.inflationManager().addGaugeForVault(token);
        return true;
    }

    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {
        _prepare(_LP_GAUGE, _lpGauge);
        return true;
    }

    function executeLpGauge() external override onlyGovernance returns (bool) {
        _executeAddress(_LP_GAUGE);
        controller.inflationManager().addGaugeForVault(token);
        return true;
    }

    /**
     * @notice Registers an address as a strategy to be excluded from token accumulation.
     * @dev This should be used is a strategy deposits into a stakerVault and should not get gov. tokens.
     * @return `true` if success.
     */
    function addStrategy(address strategy) external override returns (bool) {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        strategies[strategy] = true;
        return true;
    }

    /**
     * @notice Transfer staked tokens to an account.
     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.
     * @param account Address to transfer to.
     * @param amount Amount to transfer.
     * @return `true` if success.
     */
    function transfer(address account, uint256 amount) external override notPaused returns (bool) {
        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        pool.handleLpTokenTransfer(msg.sender, account, amount);

        balances[msg.sender] -= amount;
        balances[account] += amount;

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(msg.sender);
            ILpGauge(lpGauge).userCheckpoint(account);
        }

        emit Transfer(msg.sender, account, amount);
        return true;
    }

    /**
     * @notice Transfer staked tokens from src to dst.
     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.
     * @param src Address to transfer from.
     * @param dst Address to transfer to.
     * @param amount Amount to transfer.
     * @return `true` if success.
     */
    function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external override notPaused returns (bool) {
        /* Do not allow self transfers */
        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);

        address spender = msg.sender;

        /* Get the allowance, infinite for the account owner */
        uint256 startingAllowance = 0;
        if (spender == src) {
            startingAllowance = type(uint256).max;
        } else {
            startingAllowance = _allowances[src][spender];
        }
        require(startingAllowance >= amount, Error.INSUFFICIENT_BALANCE);

        uint256 srcTokens = balances[src];
        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(src);
            ILpGauge(lpGauge).userCheckpoint(dst);
        }
        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        pool.handleLpTokenTransfer(src, dst, amount);

        uint256 allowanceNew = startingAllowance - amount;
        uint256 srcTokensNew = srcTokens - amount;
        uint256 dstTokensNew = balances[dst] + amount;

        /* Update token balances */
        balances[src] = srcTokensNew;
        balances[dst] = dstTokensNew;

        /* Update allowance if necessary */
        if (startingAllowance != type(uint256).max) {
            _allowances[src][spender] = allowanceNew;
        }
        emit Transfer(src, dst, amount);
        return true;
    }

    /**
     * @notice Approve staked tokens for spender.
     * @param spender Address to approve tokens for.
     * @param amount Amount to approve.
     * @return `true` if success.
     */
    function approve(address spender, uint256 amount) external override notPaused returns (bool) {
        address src = msg.sender;
        _allowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.
     * @param account Address that registered the action.
     * @param amount Amount staked by the action.
     * @return `true` if success.
     */
    function increaseActionLockedBalance(address account, uint256 amount)
        external
        override
        returns (bool)
    {
        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }
        actionLockedBalances[account] += amount;
        return true;
    }

    /**
     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.
     * @param account Address that registered the action.
     * @param amount Amount executed/reset by the action.
     * @return `true` if success.
     */
    function decreaseActionLockedBalance(address account, uint256 amount)
        external
        override
        returns (bool)
    {
        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }
        if (actionLockedBalances[account] > amount) {
            actionLockedBalances[account] -= amount;
        } else {
            actionLockedBalances[account] = 0;
        }
        return true;
    }

    function poolCheckpoint() external override returns (bool) {
        if (currentAddresses[_LP_GAUGE] != address(0)) {
            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();
        }
        return false;
    }

    function getLpGauge() external view override returns (address) {
        return currentAddresses[_LP_GAUGE];
    }

    function isStrategy(address user) external view override returns (bool) {
        return strategies[user];
    }

    /**
     * @notice Get the total amount of tokens that are staked by actions
     * @return Total amount staked by actions
     */
    function getStakedByActions() external view override returns (uint256) {
        address[] memory actions = controller.addressProvider().allActions();
        uint256 total;
        for (uint256 i = 0; i < actions.length; i++) {
            total += balances[actions[i]];
        }
        return total;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }

    function getPoolTotalStaked() external view override returns (uint256) {
        return _poolTotalStaked;
    }

    /**
     * @notice Returns the total balance in the staker vault, including that locked in positions.
     * @param account Account to query balance for.
     * @return Total balance in staker vault for account.
     */
    function stakedAndActionLockedBalanceOf(address account)
        external
        view
        override
        returns (uint256)
    {
        return balances[account] + actionLockedBalances[account];
    }

    function actionLockedBalanceOf(address account) external view override returns (uint256) {
        return actionLockedBalances[account];
    }

    function decimals() external view returns (uint8) {
        return IERC20Full(token).decimals();
    }

    function getToken() external view override returns (address) {
        return token;
    }

    function unstake(uint256 amount) public override returns (bool) {
        return unstakeFor(msg.sender, msg.sender, amount);
    }

    /**
     * @notice Stake an amount of vault tokens.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stake(uint256 amount) public override returns (bool) {
        return stakeFor(msg.sender, amount);
    }

    /**
     * @notice Stake amount of vault token on behalf of another account.
     * @param account Account for which tokens will be staked.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {
        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }

        uint256 oldBal = IERC20(token).balanceOf(address(this));

        if (msg.sender != account) {
            ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
            pool.handleLpTokenTransfer(msg.sender, account, amount);
        }

        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;
        require(staked == amount, Error.INVALID_AMOUNT);
        balances[account] += staked;

        if (strategies[account]) {
            strategiesTotalStaked += staked;
        } else {
            _poolTotalStaked += staked;
        }
        emit Staked(account, amount);
        return true;
    }

    /**
     * @notice Unstake tokens on behalf of another account.
     * @dev Needs to be approved.
     * @param src Account for which tokens will be unstaked.
     * @param dst Account receiving the tokens.
     * @param amount Amount of token to unstake/receive.
     * @return `true` if success.
     */
    function unstakeFor(
        address src,
        address dst,
        uint256 amount
    ) public override returns (bool) {
        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        uint256 allowance_ = _allowances[src][msg.sender];
        require(
            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,
            Error.UNAUTHORIZED_ACCESS
        );
        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);
        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(src);
        }
        uint256 oldBal = IERC20(token).balanceOf(address(this));

        if (src != dst) {
            pool.handleLpTokenTransfer(src, dst, amount);
        }

        IERC20(token).safeTransfer(dst, amount);

        uint256 unstaked = oldBal - IERC20(token).balanceOf(address(this));

        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {
            // update allowance
            _allowances[src][msg.sender] -= unstaked;
        }
        balances[src] -= unstaked;

        if (strategies[src]) {
            strategiesTotalStaked -= unstaked;
        } else {
            _poolTotalStaked -= unstaked;
        }
        emit Unstaked(src, amount);
        return true;
    }

    function _isAuthorizedToPause(address account) internal view override returns (bool) {
        return _roleManager().hasRole(Roles.GOVERNANCE, account);
    }
}",3192,405,"H-01: User can steal all rewards due to checkpoint after transfer. L112-L119 H-02: function lockFunds in TopUpActionLibrary can cause serious fund lose. fee and Capped bypass. It's not calling stakerVault.increaseActionLockedBalance when transfers stakes. L57-L65",2
64_TwabRewards.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";

import ""./interfaces/ITwabRewards.sol"";

/**
 * @title PoolTogether V4 TwabRewards
 * @author PoolTogether Inc Team
 * @notice Contract to distribute rewards to depositors in a pool.
 * This contract supports the creation of several promotions that can run simultaneously.
 * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.
 * This way, users simply need to hold their tickets to be eligible to claim rewards.
 * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.
 * @dev This contract supports only one prize pool ticket.
 * @dev This contract does not support the use of fee on transfer tokens.
 */
contract TwabRewards is ITwabRewards {
    using SafeERC20 for IERC20;

    /* ============ Global Variables ============ */

    /// @notice Prize pool ticket for which the promotions are created.
    ITicket public immutable ticket;

    /// @notice Period during which the promotion owner can't destroy a promotion.
    uint32 public constant GRACE_PERIOD = 60 days;

    /// @notice Settings of each promotion.
    mapping(uint256 => Promotion) internal _promotions;

    /**
     * @notice Latest recorded promotion id.
     * @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.
     */
    uint256 internal _latestPromotionId;

    /**
     * @notice Keeps track of claimed rewards per user.
     * @dev _claimedEpochs[promotionId][user] => claimedEpochs
     * @dev We pack epochs claimed by a user into a uint256. So we can't store more than 256 epochs.
     */
    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;

    /* ============ Events ============ */

    /**
     * @notice Emitted when a promotion is created.
     * @param promotionId Id of the newly created promotion
     */
    event PromotionCreated(uint256 indexed promotionId);

    /**
     * @notice Emitted when a promotion is ended.
     * @param promotionId Id of the promotion being ended
     * @param recipient Address of the recipient that will receive the remaining rewards
     * @param amount Amount of tokens transferred to the recipient
     * @param epochNumber Epoch number at which the promotion ended
     */
    event PromotionEnded(
        uint256 indexed promotionId,
        address indexed recipient,
        uint256 amount,
        uint8 epochNumber
    );

    /**
     * @notice Emitted when a promotion is destroyed.
     * @param promotionId Id of the promotion being destroyed
     * @param recipient Address of the recipient that will receive the unclaimed rewards
     * @param amount Amount of tokens transferred to the recipient
     */
    event PromotionDestroyed(
        uint256 indexed promotionId,
        address indexed recipient,
        uint256 amount
    );

    /**
     * @notice Emitted when a promotion is extended.
     * @param promotionId Id of the promotion being extended
     * @param numberOfEpochs Number of epochs the promotion has been extended by
     */
    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);

    /**
     * @notice Emitted when rewards have been claimed.
     * @param promotionId Id of the promotion for which epoch rewards were claimed
     * @param epochIds Ids of the epochs being claimed
     * @param user Address of the user for which the rewards were claimed
     * @param amount Amount of tokens transferred to the recipient address
     */
    event RewardsClaimed(
        uint256 indexed promotionId,
        uint8[] epochIds,
        address indexed user,
        uint256 amount
    );

    /* ============ Constructor ============ */

    /**
     * @notice Constructor of the contract.
     * @param _ticket Prize Pool ticket address for which the promotions will be created
     */
    constructor(ITicket _ticket) {
        _requireTicket(_ticket);
        ticket = _ticket;
    }

    /* ============ External Functions ============ */

    /// @inheritdoc ITwabRewards
    function createPromotion(
        IERC20 _token,
        uint64 _startTimestamp,
        uint256 _tokensPerEpoch,
        uint48 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        require(_tokensPerEpoch > 0, ""TwabRewards/tokens-not-zero"");
        require(_epochDuration > 0, ""TwabRewards/duration-not-zero"");
        _requireNumberOfEpochs(_numberOfEpochs);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        uint256 _amount = _tokensPerEpoch * _numberOfEpochs;

        _promotions[_nextPromotionId] = Promotion({
            creator: msg.sender,
            startTimestamp: _startTimestamp,
            numberOfEpochs: _numberOfEpochs,
            epochDuration: _epochDuration,
            createdAt: uint48(block.timestamp),
            token: _token,
            tokensPerEpoch: _tokensPerEpoch,
            rewardsUnclaimed: _amount
        });

        uint256 _beforeBalance = _token.balanceOf(address(this));

        _token.safeTransferFrom(msg.sender, address(this), _amount);

        uint256 _afterBalance = _token.balanceOf(address(this));

        require(_beforeBalance + _amount == _afterBalance, ""TwabRewards/promo-amount-diff"");

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }

    /// @inheritdoc ITwabRewards
    function endPromotion(uint256 _promotionId, address _to) external override returns (bool) {
        require(_to != address(0), ""TwabRewards/payee-not-zero-addr"");

        Promotion memory _promotion = _getPromotion(_promotionId);
        _requirePromotionCreator(_promotion);
        _requirePromotionActive(_promotion);

        uint8 _epochNumber = uint8(_getCurrentEpochId(_promotion));
        _promotions[_promotionId].numberOfEpochs = _epochNumber;

        uint256 _remainingRewards = _getRemainingRewards(_promotion);
        _promotions[_promotionId].rewardsUnclaimed -= _remainingRewards;

        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionEnded(_promotionId, _to, _remainingRewards, _epochNumber);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function destroyPromotion(uint256 _promotionId, address _to) external override returns (bool) {
        require(_to != address(0), ""TwabRewards/payee-not-zero-addr"");

        Promotion memory _promotion = _getPromotion(_promotionId);
        _requirePromotionCreator(_promotion);

        uint256 _promotionEndTimestamp = _getPromotionEndTimestamp(_promotion);
        uint256 _promotionCreatedAt = _promotion.createdAt;

        uint256 _gracePeriodEndTimestamp = (
            _promotionEndTimestamp < _promotionCreatedAt
                ? _promotionCreatedAt
                : _promotionEndTimestamp
        ) + GRACE_PERIOD;

        require(block.timestamp >= _gracePeriodEndTimestamp, ""TwabRewards/grace-period-active"");

        uint256 _rewardsUnclaimed = _promotion.rewardsUnclaimed;
        delete _promotions[_promotionId];

        _promotion.token.safeTransfer(_to, _rewardsUnclaimed);

        emit PromotionDestroyed(_promotionId, _to, _rewardsUnclaimed);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)
        external
        override
        returns (bool)
    {
        _requireNumberOfEpochs(_numberOfEpochs);

        Promotion memory _promotion = _getPromotion(_promotionId);
        _requirePromotionActive(_promotion);

        uint8 _currentNumberOfEpochs = _promotion.numberOfEpochs;

        require(
            _numberOfEpochs <= (type(uint8).max - _currentNumberOfEpochs),
            ""TwabRewards/epochs-over-limit""
        );

        _promotions[_promotionId].numberOfEpochs = _currentNumberOfEpochs + _numberOfEpochs;

        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;

        _promotions[_promotionId].rewardsUnclaimed += _amount;
        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);

        emit PromotionExtended(_promotionId, _numberOfEpochs);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint8[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];
        uint256 _epochIdsLength = _epochIds.length;

        for (uint256 index = 0; index < _epochIdsLength; index++) {
            uint8 _epochId = _epochIds[index];

            require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), ""TwabRewards/rewards-claimed"");

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;
        _promotions[_promotionId].rewardsUnclaimed -= _rewardsAmount;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

    /// @inheritdoc ITwabRewards
    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {
        return _getPromotion(_promotionId);
    }

    /// @inheritdoc ITwabRewards
    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {
        return _getCurrentEpochId(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {
        return _getRemainingRewards(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint8[] calldata _epochIds
    ) external view override returns (uint256[] memory) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _epochIdsLength = _epochIds.length;
        uint256[] memory _rewardsAmount = new uint256[](_epochIdsLength);

        for (uint256 index = 0; index < _epochIdsLength; index++) {
            if (_isClaimedEpoch(_claimedEpochs[_promotionId][_user], _epochIds[index])) {
                _rewardsAmount[index] = 0;
            } else {
                _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);
            }
        }

        return _rewardsAmount;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Determine if address passed is actually a ticket.
     * @param _ticket Address to check
     */
    function _requireTicket(ITicket _ticket) internal view {
        require(address(_ticket) != address(0), ""TwabRewards/ticket-not-zero-addr"");

        (bool succeeded, bytes memory data) = address(_ticket).staticcall(
            abi.encodePacked(_ticket.controller.selector)
        );

        require(
            succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0,
            ""TwabRewards/invalid-ticket""
        );
    }

    /**
     * @notice Allow a promotion to be created or extended only by a positive number of epochs.
     * @param _numberOfEpochs Number of epochs to check
     */
    function _requireNumberOfEpochs(uint8 _numberOfEpochs) internal pure {
        require(_numberOfEpochs > 0, ""TwabRewards/epochs-not-zero"");
    }

    /**
     * @notice Determine if a promotion is active.
     * @param _promotion Promotion to check
     */
    function _requirePromotionActive(Promotion memory _promotion) internal view {
        require(
            _getPromotionEndTimestamp(_promotion) > block.timestamp,
            ""TwabRewards/promotion-inactive""
        );
    }

    /**
     * @notice Determine if msg.sender is the promotion creator.
     * @param _promotion Promotion to check
     */
    function _requirePromotionCreator(Promotion memory _promotion) internal view {
        require(msg.sender == _promotion.creator, ""TwabRewards/only-promo-creator"");
    }

    /**
     * @notice Get settings for a specific promotion.
     * @dev Will revert if the promotion does not exist.
     * @param _promotionId Promotion id to get settings for
     * @return Promotion settings
     */
    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {
        Promotion memory _promotion = _promotions[_promotionId];
        require(_promotion.creator != address(0), ""TwabRewards/invalid-promotion"");
        return _promotion;
    }

    /**
     * @notice Compute promotion end timestamp.
     * @param _promotion Promotion to compute end timestamp for
     * @return Promotion end timestamp
     */
    function _getPromotionEndTimestamp(Promotion memory _promotion)
        internal
        pure
        returns (uint256)
    {
        unchecked {
            return
                _promotion.startTimestamp + (_promotion.epochDuration * _promotion.numberOfEpochs);
        }
    }

    /**
     * @notice Get the current epoch id of a promotion.
     * @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.
     * @dev We return the current epoch id if the promotion has not ended.
     * If the current timestamp is before the promotion start timestamp, we return 0.
     * Otherwise, we return the epoch id at the current timestamp. This could be greater than the number of epochs of the promotion.
     * @param _promotion Promotion to get current epoch for
     * @return Epoch id
     */
    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        uint256 _currentEpochId;

        if (block.timestamp > _promotion.startTimestamp) {
            unchecked {
                _currentEpochId =
                    (block.timestamp - _promotion.startTimestamp) /
                    _promotion.epochDuration;
            }
        }

        return _currentEpochId;
    }

    /**
     * @notice Get reward amount for a specific user.
     * @dev Rewards can only be calculated once the epoch is over.
     * @dev Will revert if `_epochId` is over the total number of epochs or if epoch is not over.
     * @dev Will return 0 if the user average balance of tickets is 0.
     * @param _user User to get reward amount for
     * @param _promotion Promotion from which the epoch is
     * @param _epochId Epoch id to get reward amount for
     * @return Reward amount
     */
    function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint8 _epochId
    ) internal view returns (uint256) {
        uint64 _epochDuration = _promotion.epochDuration;
        uint64 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint64 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp >= _epochEndTimestamp, ""TwabRewards/epoch-not-over"");
        require(_epochId < _promotion.numberOfEpochs, ""TwabRewards/invalid-epoch-id"");

        uint256 _averageBalance = ticket.getAverageBalanceBetween(
            _user,
            _epochStartTimestamp,
            _epochEndTimestamp
        );

        if (_averageBalance > 0) {
            uint64[] memory _epochStartTimestamps = new uint64[](1);
            _epochStartTimestamps[0] = _epochStartTimestamp;

            uint64[] memory _epochEndTimestamps = new uint64[](1);
            _epochEndTimestamps[0] = _epochEndTimestamp;

            uint256 _averageTotalSupply = ticket.getAverageTotalSuppliesBetween(
                _epochStartTimestamps,
                _epochEndTimestamps
            )[0];

            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupply;
        }

        return 0;
    }

    /**
     * @notice Get the total amount of tokens left to be rewarded.
     * @param _promotion Promotion to get the total amount of tokens left to be rewarded for
     * @return Amount of tokens left to be rewarded
     */
    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        if (block.timestamp > _getPromotionEndTimestamp(_promotion)) {
            return 0;
        }

        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }


    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)
        internal
        pure
        returns (uint256)
    {
        return _userClaimedEpochs | (uint256(1) << _epochId);
    }


    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)
        internal
        pure
        returns (bool)
    {
        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;
    }
}",3942,481,"H-01: createPromotion() Lack of input validation for _epochDuration can potentially freeze promotion creator's funds L88 H-04: cancelPromotion is too rigorous  L119 M-01: cancelPromotion() Unable to cancel unstarted promotions. L331 M-02: getRewardsAmount doesn't check epochs haven't been claimed L209 M-03: Dust Token Balances Cannot Be Claimed By An admin Account. L162 M-04: Unsafe uint64 casting may overflow. L304 M-05: Missing Check When Transferring Tokens Out For A Given Promotion",7
17_Exposure.sol,"// SPDX-License-Identifier: AGPLv3
pragma solidity >=0.6.0 <0.7.0;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../common/StructDefinitions.sol"";
import ""../common/Constants.sol"";
import ""../common/Controllable.sol"";
import ""../common/Whitelist.sol"";
import ""../interfaces/IERC20Detailed.sol"";
import ""../interfaces/ILifeGuard.sol"";
import ""../interfaces/IExposure.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IBuoy.sol"";

/// @notice Contract for calculating current protocol exposures on a stablecoin and
///     protocol level. This contract can be upgraded if the systems underlying protocols
///     or tokens have changed. Protocol exposure are calculated at a high level, as any
///     additional exposures from underlying protocol exposures should at most be equal to
///     the high level exposure.
///     For example: harvest finance stablecoin vaults (fTokens)
///         - High level exposure
///             - Harvest finance
///         - Low level exposures (from fToken investments):
///             - Compound
///             - Idle finance
///     Neither of these two low level exposures should matter as long as there arent
///     additional exposure to these protocol elsewhere. So by desing, the protocols
///     are given indexes based on the strategies in the stablecoin vaults, which need
///     to be symetrical for this to work - e.g. all vaults needs to have the same exposure
///     profile, and non of these exposure profiles can overlap. In the case where the
///     additional exposure needs to be taken into account (maker has USDC collateral,
///     Curve adds exposure to all stablecoins in a liquidity pool), they will be calculated
///     and added ontop of the base exposure from vaults and strategies.
///
///     --------------------------------------------------------
///     Current protocol setup:
///     --------------------------------------------------------
///     Stablecoins: DAI, USDC, USDT
///     LP tokens: 3Crv
///     Vaults: DAIVault, USDCVault, USDTVault, 3Crv vault
///     Strategy (exposures):
///         - Compound
///         - Idle finance
///         - Yearn Generic Lender:
///             - Cream
///         - CurveXpool:
///             - Curve3Pool
///             - CurveMetaPool
///             - Yearn
contract Exposure is Constants, Controllable, Whitelist, IExposure {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public protocolCount;
    uint256 public makerUSDCExposure;

    event LogNewProtocolCount(uint256 count);
    event LogNewMakerExposure(uint256 exposure);

    /// @notice Add protocol for the exposure calculations
    /// @dev Currently set to:
    ///     1 - Harvest finance
    ///     2 - Cream
    ///     Curve exposure is calculated separately as it has wider system impact
    function setProtocolCount(uint256 _protocolCount) external onlyOwner {
        protocolCount = _protocolCount;
        emit LogNewProtocolCount(_protocolCount);
    }

    /// @notice Specify additional USDC exposure to Maker
    /// @param _makerUSDCExposure Exposure amount to Maker
    function setMakerUSDCExposure(uint256 _makerUSDCExposure) external onlyOwner {
        makerUSDCExposure = _makerUSDCExposure;
        emit LogNewMakerExposure(_makerUSDCExposure);
    }

    function getExactRiskExposure(SystemState calldata sysState)
        external
        view
        override
        returns (ExposureState memory expState)
    {
        expState = _calcRiskExposure(sysState, false);
        ILifeGuard lifeguard = ILifeGuard(_controller().lifeGuard());
        IBuoy buoy = IBuoy(_controller().buoy());
        for (uint256 i = 0; i < N_COINS; i++) {
            uint256 assets = lifeguard.assets(i);
            uint256 assetsUsd = buoy.singleStableToUsd(assets, i);
            expState.stablecoinExposure[i] = expState.stablecoinExposure[i].add(
                assetsUsd.mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd)
            );
        }
    }

    /// @notice Calculate stablecoin and protocol level risk exposure
    /// @param sysState Struct holding info about systems current state
    /// @dev This loops through all the vaults, checks the amount of assets in them
    ///     and their underlying strategies to understand stablecoin exposure
    ///     - Any assets invested in Curve or similar AMM will have additional stablecoin exposure.
    ///     The protocol exposure is calculated by assessing the amount of assets each
    ///     vault has invested in a strategy.
    function calcRiskExposure(SystemState calldata sysState)
        external
        view
        override
        returns (ExposureState memory expState)
    {
        expState = _calcRiskExposure(sysState, true);

        // Establish if any stablecoin/protocol is over exposed
        (expState.stablecoinExposed, expState.protocolExposed) = isExposed(
            sysState.rebalanceThreshold,
            expState.stablecoinExposure,
            expState.protocolExposure,
            expState.curveExposure
        );
    }

    /// @notice Do a rough USD dollar calculation by treating every stablecoin as
    ///     worth 1 USD and set all Decimals to 18
    function getUnifiedAssets(address[N_COINS] calldata vaults)
        public
        view
        override
        returns (uint256 unifiedTotalAssets, uint256[N_COINS] memory unifiedAssets)
    {
        // unify all assets to 18 decimals, treat each stablecoin as being worth 1 USD
        for (uint256 i = 0; i < N_COINS; i++) {
            uint256 assets = IVault(vaults[i]).totalAssets();
            unifiedAssets[i] = assets.mul(DEFAULT_DECIMALS_FACTOR).div(
                uint256(10)**IERC20Detailed(IVault(vaults[i]).token()).decimals()
            );
            unifiedTotalAssets = unifiedTotalAssets.add(unifiedAssets[i]);
        }
    }

    /// @notice Rough delta calculation - assumes each stablecoin is priced at 1 USD,
    ///     and looks at differences between current allocations and target allocations
    /// @param targets Stable coin allocation targest
    /// @param vaults Stablecoin vaults
    /// @param withdrawUsd USD value of withdrawals
    function calcRoughDelta(
        uint256[N_COINS] calldata targets,
        address[N_COINS] calldata vaults,
        uint256 withdrawUsd
    ) external view override returns (uint256[N_COINS] memory delta) {
        (uint256 totalAssets, uint256[N_COINS] memory vaultTotalAssets) = getUnifiedAssets(vaults);

        require(totalAssets > withdrawUsd, ""totalAssets < withdrawalUsd"");
        totalAssets = totalAssets.sub(withdrawUsd);
        uint256 totalDelta;
        for (uint256 i; i < N_COINS; i++) {
            uint256 target = totalAssets.mul(targets[i]).div(PERCENTAGE_DECIMAL_FACTOR);
            if (vaultTotalAssets[i] > target) {
                delta[i] = vaultTotalAssets[i].sub(target);
                totalDelta = totalDelta.add(delta[i]);
            }
        }
        uint256 percent = PERCENTAGE_DECIMAL_FACTOR;
        for (uint256 i; i < N_COINS - 1; i++) {
            if (delta[i] > 0) {
                delta[i] = delta[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(totalDelta);
                percent = percent.sub(delta[i]);
            }
        }
        delta[N_COINS - 1] = percent;
        return delta;
    }

    /// @notice Sort vaults by the delta of target asset - current asset,
    ///     only support 3 vaults now
    /// @param bigFirst Return array order most exposed -> least exposed
    /// @param unifiedTotalAssets Estimated system USD assets
    /// @param unifiedAssets Estimated vault USD assets
    /// @param targetPercents Vault target percent array
    function sortVaultsByDelta(
        bool bigFirst,
        uint256 unifiedTotalAssets,
        uint256[N_COINS] calldata unifiedAssets,
        uint256[N_COINS] calldata targetPercents
    ) external pure override returns (uint256[N_COINS] memory vaultIndexes) {
        uint256 maxIndex;
        uint256 minIndex;
        int256 maxDelta;
        int256 minDelta;
        for (uint256 i = 0; i < N_COINS; i++) {
            // Get difference between vault current assets and vault target
            int256 delta = int256(
                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)
            );
            // Establish order
            if (delta > maxDelta) {
                maxDelta = delta;
                maxIndex = i;
            } else if (delta < minDelta) {
                minDelta = delta;
                minIndex = i;
            }
        }
        if (bigFirst) {
            vaultIndexes[0] = maxIndex;
            vaultIndexes[2] = minIndex;
        } else {
            vaultIndexes[0] = minIndex;
            vaultIndexes[2] = maxIndex;
        }
        vaultIndexes[1] = N_COINS - maxIndex - minIndex;
    }

    /// @notice Calculate what percentage of system total assets the assets in a strategy make up
    /// @param vault Address of target vault that holds the strategy
    /// @param index Index of strategy
    /// @param vaultAssetsPercent Percentage of system assets
    /// @param vaultAssets Total assets in vaults
    function calculatePercentOfSystem(
        address vault,
        uint256 index,
        uint256 vaultAssetsPercent,
        uint256 vaultAssets
    ) private view returns (uint256 percentOfSystem) {
        if (vaultAssets == 0) return 0;
        uint256 strategyAssetsPercent = IVault(vault).getStrategyAssets(index).mul(PERCENTAGE_DECIMAL_FACTOR).div(
            vaultAssets
        );

        percentOfSystem = vaultAssetsPercent.mul(strategyAssetsPercent).div(PERCENTAGE_DECIMAL_FACTOR);
    }

    /// @notice Calculate the net stablecoin exposure
    /// @param directlyExposure Amount of stablecoin in vault+strategies
    /// @param curveExposure Percent of assets in Curve
    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure)
        private
        view
        returns (uint256[N_COINS] memory stableCoinExposure)
    {
        uint256 maker = directlyExposure[0].mul(makerUSDCExposure).div(PERCENTAGE_DECIMAL_FACTOR);
        for (uint256 i = 0; i < N_COINS; i++) {
            uint256 indirectExposure = curveExposure;
            if (i == 1) {
                indirectExposure = indirectExposure.add(maker);
            }
            stableCoinExposure[i] = directlyExposure[i].add(indirectExposure);
        }
    }

    /// @notice Determine if an assets or protocol is overexposed
    /// @param rebalanceThreshold Threshold for triggering a rebalance due to overexposure
    /// @param stableCoinExposure Current stable coin exposures
    /// @param protocolExposure Current prtocol exposures
    /// @param curveExposure Current Curve exposure
    function isExposed(
        uint256 rebalanceThreshold,
        uint256[N_COINS] memory stableCoinExposure,
        uint256[] memory protocolExposure,
        uint256 curveExposure
    ) private pure returns (bool stablecoinExposed, bool protocolExposed) {
        for (uint256 i = 0; i < N_COINS; i++) {
            if (stableCoinExposure[i] > rebalanceThreshold) {
                stablecoinExposed = true;
                break;
            }
        }
        for (uint256 i = 0; i < protocolExposure.length; i++) {
            if (protocolExposure[i] > rebalanceThreshold) {
                protocolExposed = true;
                break;
            }
        }
        if (!protocolExposed && curveExposure > rebalanceThreshold) protocolExposed = true;
        return (stablecoinExposed, protocolExposed);
    }

    function _calcRiskExposure(SystemState memory sysState, bool treatLifeguardAsCurve)
        private
        view
        returns (ExposureState memory expState)
    {
        address[N_COINS] memory vaults = _controller().vaults();
        uint256 pCount = protocolCount;
        expState.protocolExposure = new uint256[](pCount);
        if (sysState.totalCurrentAssetsUsd == 0) {
            return expState;
        }
        // Stablecoin exposure
        for (uint256 i = 0; i < N_COINS; i++) {
            uint256 vaultAssetsPercent = sysState.vaultCurrentAssetsUsd[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(
                sysState.totalCurrentAssetsUsd
            );
            expState.stablecoinExposure[i] = vaultAssetsPercent;
            // Protocol exposure
            for (uint256 j = 0; j < pCount; j++) {
                uint256 percentOfSystem = calculatePercentOfSystem(
                    vaults[i],
                    j,
                    vaultAssetsPercent,
                    sysState.vaultCurrentAssets[i]
                );
                expState.protocolExposure[j] = expState.protocolExposure[j].add(percentOfSystem);
            }
        }
        if (treatLifeguardAsCurve) {
            // Curve exposure is calculated by adding the Curve vaults total assets and any
            // assets in the lifeguard which are poised to be invested into the Curve vault
            expState.curveExposure = sysState.curveCurrentAssetsUsd.add(sysState.lifeguardCurrentAssetsUsd);
        } else {
            expState.curveExposure = sysState.curveCurrentAssetsUsd;
        }
        expState.curveExposure = expState.curveExposure.mul(PERCENTAGE_DECIMAL_FACTOR).div(
            sysState.totalCurrentAssetsUsd
        );

        // Calculate stablecoin exposures
        expState.stablecoinExposure = calculateStableCoinExposure(expState.stablecoinExposure, expState.curveExposure);
    }
}",3117,319,"H-01: implicit underflows. L178 H-04: sortVaultsByDelta doesn't work as expected",2
75_XDEFIDistribution.sol,"// SPDX-License-Identifier: MIT

pragma solidity =0.8.10;

import { ERC721, ERC721Enumerable, Strings } from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import { IERC20, SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import { IEIP2612 } from ""./interfaces/IEIP2612.sol"";
import { IXDEFIDistribution } from ""./interfaces/IXDEFIDistribution.sol"";

/// @dev Handles distributing XDEFI to NFTs that have locked up XDEFI for various durations of time.
contract XDEFIDistribution is IXDEFIDistribution, ERC721Enumerable {

    uint88 internal MAX_TOTAL_XDEFI_SUPPLY = uint88(240_000_000_000_000_000_000_000_000);

    // See https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728
    uint256 internal constant _pointsMultiplier = uint256(2**128);
    uint256 internal _pointsPerUnit;

    address public immutable XDEFI;

    uint256 public distributableXDEFI;
    uint256 public totalDepositedXDEFI;
    uint256 public totalUnits;

    mapping(uint256 => Position) public positionOf;

    mapping(uint256 => uint8) public bonusMultiplierOf;  
    // Scaled by 100 (i.e. 1.1x is 110, 2.55x is 255).

    uint256 internal immutable _zeroDurationPointBase;

    string public baseURI;

    address public owner;
    address public pendingOwner;

    uint256 internal _locked;

    constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(""Locked XDEFI"", ""lXDEFI"") {
        require((XDEFI = XDEFI_) != address(0), ""INVALID_TOKEN"");
        owner = msg.sender;
        baseURI = baseURI_;
        _zeroDurationPointBase = zeroDurationPointBase_;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""NOT_OWNER"");
        _;
    }

    modifier noReenter() {
        require(_locked == 0, ""LOCKED"");
        _locked = uint256(1);
        _;
        _locked = uint256(0);
    }

    /*******************/
    /* Admin Functions */
    /*******************/

    function acceptOwnership() external {
        require(pendingOwner == msg.sender, ""NOT_PENDING_OWNER"");
        emit OwnershipAccepted(owner, msg.sender);
        owner = msg.sender;
        pendingOwner = address(0);
    }

    function proposeOwnership(address newOwner_) external onlyOwner {
        emit OwnershipProposed(owner, pendingOwner = newOwner_);
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {
        uint256 count = durations_.length;

        for (uint256 i; i < count; ++i) {
            uint256 duration = durations_[i];
            require(duration <= uint256(18250 days), ""INVALID_DURATION"");
            emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);
        }
    }

    /**********************/
    /* Position Functions */
    /**********************/

    function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {
        // Lock the XDEFI in the contract.
        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);

        // Handle the lock position creation and get the tokenId of the locked position.
        return _lock(amount_, duration_, destination_);
    }

    function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {
        // Approve this contract for the amount, using the provided signature.
        IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);

        // Lock the XDEFI in the contract.
        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);

        // Handle the lock position creation and get the tokenId of the locked position.
        return _lock(amount_, duration_, destination_);
    }

    function relock(uint256 tokenId_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {
        // Handle the unlock and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlock(msg.sender, tokenId_);

        // Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.
        require(lockAmount_ <= amountUnlocked_, ""INSUFFICIENT_AMOUNT_UNLOCKED"");

        // Handle the lock position creation and get the tokenId of the locked position.
        newTokenId_ = _lock(lockAmount_, duration_, destination_);

        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;

        if (withdrawAmount != uint256(0)) {
            // Send the excess XDEFI to the destination, if needed.
            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);
        }

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.
        _updateXDEFIBalance();
    }

    function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {
        // Handle the unlock and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlock(msg.sender, tokenId_);

        // Send the the unlocked XDEFI to the destination.
        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.
        _updateXDEFIBalance();
    }

    function updateDistribution() external {
        uint256 totalUnitsCached = totalUnits;

        require(totalUnitsCached > uint256(0), ""NO_UNIT_SUPPLY"");

        uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());

        if (newXDEFI == uint256(0)) return;

        _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);

        emit DistributionUpdated(msg.sender, newXDEFI);
    }

    function withdrawableOf(uint256 tokenId_) public view returns (uint256 withdrawableXDEFI_) {
        Position storage position = positionOf[tokenId_];
        return _withdrawableGiven(position.units, position.depositedXDEFI, position.pointsCorrection);
    }

    /****************************/
    /* Batch Position Functions */
    /****************************/

    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {
        // Handle the unlocks and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);

        // Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.
        require(lockAmount_ <= amountUnlocked_, ""INSUFFICIENT_AMOUNT_UNLOCKED"");

        // Handle the lock position creation and get the tokenId of the locked position.
        newTokenId_ = _lock(lockAmount_, duration_, destination_);

        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;

        if (withdrawAmount != uint256(0)) {
            // Send the excess XDEFI to the destination, if needed.
            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);
        }

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlockBatch`) and transferring out.
        _updateXDEFIBalance();
    }

    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) {
        // Handle the unlocks and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);

        // Send the the unlocked XDEFI to the destination.
        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlockBatch`) and transferring out.
        _updateXDEFIBalance();
    }

    /*****************/
    /* NFT Functions */
    /*****************/

    function getPoints(uint256 amount_, uint256 duration_) external view returns (uint256 points_) {
        return _getPoints(amount_, duration_);
    }

    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {
        uint256 count = tokenIds_.length;
        require(count > uint256(1), ""MIN_2_TO_MERGE"");

        uint256 points;

        // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.
        for (uint256 i; i < count; ++i) {
            uint256 tokenId = tokenIds_[i];
            require(ownerOf(tokenId) == msg.sender, ""NOT_OWNER"");
            require(positionOf[tokenId].expiry == uint32(0), ""POSITION_NOT_UNLOCKED"");

            _burn(tokenId);

            points += _getPointsFromTokenId(tokenId);
        }

        // Mine a new NFT to the destinations, based on the accumulated points.
        _safeMint(destination_, tokenId_ = _generateNewTokenId(points));
    }

    function pointsOf(uint256 tokenId_) external view returns (uint256 points_) {
        require(_exists(tokenId_), ""NO_TOKEN"");
        return _getPointsFromTokenId(tokenId_);
    }

    function tokenURI(uint256 tokenId_) public view override(IXDEFIDistribution, ERC721) returns (string memory tokenURI_) {
        require(_exists(tokenId_), ""NO_TOKEN"");
        return string(abi.encodePacked(baseURI, Strings.toString(tokenId_)));
    }

    /**********************/
    /* Internal Functions */
    /**********************/

    function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {
        // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.
        return (points_ << uint256(128)) + uint128(totalSupply() + 1);
    }

    function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {
        return amount_ * (duration_ + _zeroDurationPointBase);
    }

    function _getPointsFromTokenId(uint256 tokenId_) internal pure returns (uint256 points_) {
        return tokenId_ >> uint256(128);
    }

    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {
        // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.
        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, ""INVALID_AMOUNT"");

        // Get bonus multiplier and check that it is not zero (which validates the duration).
        uint8 bonusMultiplier = bonusMultiplierOf[duration_];
        require(bonusMultiplier != uint8(0), ""INVALID_DURATION"");

        // Mint a locked staked position NFT to the destination.
        _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));

        // Track deposits.
        totalDepositedXDEFI += amount_;

        // Create Position.
        uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));
        totalUnits += units;
        positionOf[tokenId_] =
            Position({
                units: units,
                depositedXDEFI: uint88(amount_),
                expiry: uint32(block.timestamp + duration_),
                created: uint32(block.timestamp),
                bonusMultiplier: bonusMultiplier,
                pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)
            });

        emit LockPositionCreated(tokenId_, destination_, amount_, duration_);
    }

    function _toInt256Safe(uint256 x_) internal pure returns (int256 y_) {
        y_ = int256(x_);
        assert(y_ >= int256(0));
    }

    function _toUint256Safe(int256 x_) internal pure returns (uint256 y_) {
        assert(x_ >= int256(0));
        return uint256(x_);
    }

    function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {
        // Check that the account is the position NFT owner.
        require(ownerOf(tokenId_) == account_, ""NOT_OWNER"");

        // Fetch position.
        Position storage position = positionOf[tokenId_];
        uint96 units = position.units;
        uint88 depositedXDEFI = position.depositedXDEFI;
        uint32 expiry = position.expiry;

        // Check that enough time has elapsed in order to unlock.
        require(expiry != uint32(0), ""NO_LOCKED_POSITION"");
        require(block.timestamp >= uint256(expiry), ""CANNOT_UNLOCK"");

        // Get the withdrawable amount of XDEFI for the position.
        amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);

        // Track deposits.
        totalDepositedXDEFI -= uint256(depositedXDEFI);

        // Burn FDT Position.
        totalUnits -= units;
        delete positionOf[tokenId_];

        emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);
    }

    function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {
        uint256 count = tokenIds_.length;
        require(count > uint256(1), ""USE_UNLOCK"");

        // Handle the unlock for each position and accumulate the unlocked amount.
        for (uint256 i; i < count; ++i) {
            amountUnlocked_ += _unlock(account_, tokenIds_[i]);
        }
    }

    function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {
        uint256 previousDistributableXDEFI = distributableXDEFI;
        uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;

        return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);
    }

    function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {
        return
            (
                _toUint256Safe(
                    _toInt256Safe(_pointsPerUnit * uint256(units_)) +
                    pointsCorrection_
                ) / _pointsMultiplier
            ) + uint256(depositedXDEFI_);
    }

}",3290,349,H-01: Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases. L151,1
38_QuickAccManager.sol,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.7;

import ""../Identity.sol"";
import ""../interfaces/IERC20.sol"";

contract QuickAccManager {
	// Note: nonces are scoped by identity rather than by accHash - the reason for this is that there's no reason to scope them by accHash,
	// we merely need them for replay protection
	mapping (address => uint) nonces;
	mapping (bytes32 => uint) scheduled;

	bytes4 immutable CANCEL_PREFIX = 0xc47c3100;

	// Events
	// we only need those for timelocked stuff so we can show scheduled txns to the user; the oens that get executed immediately do not need logs
	event LogScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint nonce, uint time, Identity.Transaction[] txns);
	event LogCancelled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint time);
	event LogExecScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, uint time);

	// EIP 2612
	bytes32 public DOMAIN_SEPARATOR;
	constructor() {
		DOMAIN_SEPARATOR = keccak256(
			abi.encode(
				keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
				// @TODO: maybe we should use a more user friendly name here?
				keccak256(bytes('QuickAccManager')),
				keccak256(bytes('1')),
				block.chainid,
				address(this)
			)
		);
	}

	struct QuickAccount {
		uint timelock;
		address one;
		address two;
		// We decided to not allow certain options here such as ability to skip the second sig for send(), but leaving this a struct rather than a tuple
		// for clarity and to ensure it's future proof
	}
	struct DualSig {
		bool isBothSigned;
		bytes one;
		bytes two;
	}

	// NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]
	// this is by design

	// isBothSigned is hashed in so that we don't allow signatures from two-sig txns to be reused for single sig txns,
	// ...potentially frontrunning a normal two-sig transaction and making it wait
	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {
		bytes32 accHash = keccak256(abi.encode(acc));
		require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');
		uint initialNonce = nonces[address(identity)];
		// Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs
		bytes32 hash = keccak256(abi.encode(
			address(this),
			block.chainid,
			accHash,
			nonces[address(identity)]++,
			txns,
			sigs.isBothSigned
		));
		if (sigs.isBothSigned) {
			require(acc.one == SignatureValidator.recoverAddr(hash, sigs.one), 'SIG_ONE');
			require(acc.two == SignatureValidator.recoverAddr(hash, sigs.two), 'SIG_TWO');
			identity.executeBySender(txns);
		} else {
			address signer = SignatureValidator.recoverAddr(hash, sigs.one);
			require(acc.one == signer || acc.two == signer, 'SIG');
			// no need to check whether `scheduled[hash]` is already set here cause of the incrementing nonce
			scheduled[hash] = block.timestamp + acc.timelock;
			emit LogScheduled(hash, accHash, signer, initialNonce, block.timestamp, txns);
		}
	}

	function cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {
		bytes32 accHash = keccak256(abi.encode(acc));
		require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');

		bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));
		address signer = SignatureValidator.recoverAddr(hash, sig);
		require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');

		// @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief
		// opportunity: someone wants to cancel post-maturity, and you front them with execScheduled
		bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));
		require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');
		delete scheduled[hashTx];

		emit LogCancelled(hashTx, accHash, signer, block.timestamp);
	}

	function execScheduled(Identity identity, bytes32 accHash, uint nonce, Identity.Transaction[] calldata txns) external {
		require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');

		bytes32 hash = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));
		require(scheduled[hash] != 0 && block.timestamp >= scheduled[hash], 'NOT_TIME');
		delete scheduled[hash];
		identity.executeBySender(txns);

		emit LogExecScheduled(hash, accHash, block.timestamp);
	}

	// EIP 1271 implementation
	// see https://eips.ethereum.org/EIPS/eip-1271
	function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {
		(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));
		bytes32 accHash = keccak256(abi.encode(QuickAccount({
			timelock: timelock,
			one: SignatureValidator.recoverAddr(hash, sig1),
			two: SignatureValidator.recoverAddr(hash, sig2)
		})));
		if (Identity(id).privileges(address(this)) == accHash) {
			// bytes4(keccak256(""isValidSignature(bytes32,bytes)"")
			return 0x1626ba7e;
		} else {
			return 0xffffffff;
		}
	}

	// EIP 712 methods
	// all of the following are 2/2 only
	bytes32 private TRANSFER_TYPEHASH = keccak256('Transfer(address tokenAddr,address to,uint256 value,uint256 fee,uint256 nonce)');
	struct Transfer { address token; address to; uint amount; uint fee; }
	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function sendTransfer(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Transfer calldata t) external {
		require(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');

		bytes32 hash = keccak256(abi.encodePacked(
			'\x19\x01',
			DOMAIN_SEPARATOR,
			keccak256(abi.encode(TRANSFER_TYPEHASH, t.token, t.to, t.amount, t.fee, nonces[address(identity)]++))
		));
		require(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');
		require(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');
		Identity.Transaction[] memory txns = new Identity.Transaction[](2);
		txns[0].to = t.token;
		txns[0].data = abi.encodeWithSelector(IERC20.transfer.selector, t.to, t.amount);
		txns[1].to = t.token;
		txns[1].data = abi.encodeWithSelector(IERC20.transfer.selector, msg.sender, t.fee);
		identity.executeBySender(txns);
	}

	// Reference for arrays: https://github.com/sportx-bet/smart-contracts/blob/e36965a0c4748bf73ae15ed3cab5660c9cf722e1/contracts/impl/trading/EIP712FillHasher.sol
	// and https://eips.ethereum.org/EIPS/eip-712
	// and for signTypedData_v4: https://gist.github.com/danfinlay/750ce1e165a75e1c3387ec38cf452b71
	struct Txn { string description; address to; uint value; bytes data; }
	bytes32 private TXNS_TYPEHASH = keccak256('Txn(string description,address to,uint256 value,bytes data)');
	bytes32 private BUNDLE_TYPEHASH = keccak256('Bundle(uint256 nonce,Txn[] transactions)');
	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function sendTxns(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Txn[] calldata txns) external {
		require(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');

		// hashing + prepping args
		bytes32[] memory txnBytes = new bytes32[](txns.length);
		Identity.Transaction[] memory identityTxns = new Identity.Transaction[](txns.length);
		for (uint256 i = 0; i < txns.length; i++) {
			txnBytes[i] = keccak256(abi.encode(TXNS_TYPEHASH, txns[i].description, txns[i].to, txns[i].value, txns[i].data));
			identityTxns[i].to = txns[i].to;
			identityTxns[i].value = txns[i].value;
			identityTxns[i].data = txns[i].data;
		}
		bytes32 txnsHash = keccak256(abi.encodePacked(txnBytes));
		bytes32 hash = keccak256(abi.encodePacked(
			'\x19\x01',
			DOMAIN_SEPARATOR,
			keccak256(abi.encode(BUNDLE_TYPEHASH, nonces[address(identity)]++, txnsHash))
		));
		require(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');
		require(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');
		identity.executeBySender(identityTxns);
	}

}",2281,180,"H-02: QuickAccManager.sol#cancel() Wrong hashTx makes it impossible to cancel a scheduled transaction L91 H-03: Signature replay attacks for different identities (nonce on wrong party) H-04: QuickAccManager Smart Contract signature verification can be exploited",3
17_Buoy3Pool.sol,"// SPDX-License-Identifier: AGPLv3
pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import {FixedStablecoins} from ""contracts/common/FixedContracts.sol"";
import {ICurve3Pool} from ""contracts/interfaces/ICurve.sol"";

import ""contracts/common/Controllable.sol"";

import ""contracts/interfaces/IBuoy.sol"";
import ""contracts/interfaces/IChainPrice.sol"";
import ""contracts/interfaces/IChainlinkAggregator.sol"";
import ""contracts/interfaces/IERC20Detailed.sol"";

/// @notice Contract for calculating prices of underlying assets and LP tokens in Curve pool. Also
///     used to sanity check pool against external oracle, to ensure that pools underlying coin ratios
///     are within a specific range (measued in BP) of the external oracles coin price ratios.
///     Sanity check:
///         The Buoy checks previously recorded (cached) curve coin dy, which it compares against current curve dy,
///         blocking any interaction that is outside a certain tolerance (BASIS_POINTS). When updting the cached
///         value, the buoy uses chainlink to ensure that curves prices arent off peg.
contract Buoy3Pool is FixedStablecoins, Controllable, IBuoy, IChainPrice {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 TIME_LIMIT = 3000;
    uint256 public BASIS_POINTS = 20;
    uint256 constant CHAIN_FACTOR = 100;

    ICurve3Pool public immutable override curvePool;
    IERC20 public immutable lpToken;

    mapping(uint256 => uint256) lastRatio;

    // Chianlink price feed
    address public immutable daiUsdAgg;
    address public immutable usdcUsdAgg;
    address public immutable usdtUsdAgg;

    mapping(address => mapping(address => uint256)) public tokenRatios;

    event LogNewBasisPointLimit(uint256 oldLimit, uint256 newLimit);

    constructor(
        address _crv3pool,
        address poolToken,
        address[N_COINS] memory _tokens,
        uint256[N_COINS] memory _decimals,
        address[N_COINS] memory aggregators
    ) public FixedStablecoins(_tokens, _decimals) {
        curvePool = ICurve3Pool(_crv3pool);
        lpToken = IERC20(poolToken);
        daiUsdAgg = aggregators[0];
        usdcUsdAgg = aggregators[1];
        usdtUsdAgg = aggregators[2];
    }

    /// @notice Set limit for how much Curve pool and external oracle is allowed
    ///     to deviate before failing transactions
    /// @param newLimit New limit in BP
    function setBasisPointsLmit(uint256 newLimit) external onlyOwner {
        uint256 oldLimit = BASIS_POINTS;
        BASIS_POINTS = newLimit;
        emit LogNewBasisPointLimit(oldLimit, newLimit);
    }

    /// @notice Check the health of the Curve pool:
    ///     Ratios are checked by the following heuristic:
    ///     Orcale A - Curve
    ///     Oracle B - External oracle
    ///     Both oracles establish ratios for a set of stable coins
    ///         (a, b, c)
    ///     and product the following set of ratios:
    ///         (a/a, a/b, a/c), (b/b, b/a, b/c), (c/c, c/a, c/b)
    ///     It's simply to reduce the number of comparisons to be made
    ///     in order to have complete coverage of the system ratios:
    ///         1) ratios between a stable coin and itself can be discarded
    ///         2) inverted ratios, a/b bs b/a, while producing different results
    ///             should both reflect the same change in any one of the two
    ///             underlying assets, but in opposite directions
    ///     This mean that the following set should provide the necessary coverage checks
    ///     to establish that the coins pricing is healthy:
    ///         (a/b, a/c)
    function safetyCheck() external view override returns (bool) {
        for (uint256 i = 1; i < N_COINS; i++) {
            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));
            _ratio = abs(int256(_ratio - lastRatio[i]));
            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {
                return false;
            }
        }
        return true;
    }

    /// @notice Updated cached curve value with a custom tolerance towards chainlink
    /// @param tolerance How much difference between curve and chainlink can be tolerated
    function updateRatiosWithTolerance(uint256 tolerance) external override returns (bool) {
        require(msg.sender == controller || msg.sender == owner(), ""updateRatiosWithTolerance: !authorized"");
        return _updateRatios(tolerance);
    }

    /// @notice Updated cached curve values
    function updateRatios() external override returns (bool) {
        require(msg.sender == controller || msg.sender == owner(), ""updateRatios: !authorized"");
        return _updateRatios(BASIS_POINTS);
    }

    /// @notice Get USD value for a specific input amount of tokens, slippage included
    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) {
        return _stableToUsd(inAmounts, deposit);
    }

    /// @notice Get estimate USD price of a stablecoin amount
    /// @param inAmount Token amount
    /// @param i Index of token
    function singleStableToUsd(uint256 inAmount, uint256 i) external view override returns (uint256) {
        uint256[N_COINS] memory inAmounts;
        inAmounts[i] = inAmount;
        return _stableToUsd(inAmounts, true);
    }

    /// @notice Get LP token value of input amount of tokens
    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {
        return _stableToLp(tokenAmounts, deposit);
    }

    /// @notice Get LP token value of input amount of single token
    function singleStableFromUsd(uint256 inAmount, int128 i) external view override returns (uint256) {
        return _singleStableFromLp(_usdToLp(inAmount), i);
    }

    /// @notice Get LP token value of input amount of single token
    function singleStableFromLp(uint256 inAmount, int128 i) external view override returns (uint256) {
        return _singleStableFromLp(inAmount, i);
    }

    /// @notice Get USD price of LP tokens you receive for a specific input amount of tokens, slippage included
    function lpToUsd(uint256 inAmount) external view override returns (uint256) {
        return _lpToUsd(inAmount);
    }

    /// @notice Convert USD amount to LP tokens
    function usdToLp(uint256 inAmount) external view override returns (uint256) {
        return _usdToLp(inAmount);
    }

    /// @notice Split LP token amount to balance of pool tokens
    /// @param inAmount Amount of LP tokens
    /// @param totalBalance Total balance of pool
    function poolBalances(uint256 inAmount, uint256 totalBalance)
        internal
        view
        returns (uint256[N_COINS] memory balances)
    {
        uint256[N_COINS] memory _balances;
        for (uint256 i = 0; i < N_COINS; i++) {
            _balances[i] = (IERC20(getToken(i)).balanceOf(address(curvePool)).mul(inAmount)).div(totalBalance);
        }
        balances = _balances;
    }

    function getVirtualPrice() external view override returns (uint256) {
        return curvePool.get_virtual_price();
    }

    // Internal functions
    function _lpToUsd(uint256 inAmount) internal view returns (uint256) {
        return inAmount.mul(curvePool.get_virtual_price()).div(DEFAULT_DECIMALS_FACTOR);
    }

    function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {
        require(tokenAmounts.length == N_COINS, ""deposit: !length"");
        uint256[N_COINS] memory _tokenAmounts;
        for (uint256 i = 0; i < N_COINS; i++) {
            _tokenAmounts[i] = tokenAmounts[i];
        }
        uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);
        return _lpToUsd(lpAmount);
    }

    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {
        require(tokenAmounts.length == N_COINS, ""deposit: !length"");
        uint256[N_COINS] memory _tokenAmounts;
        for (uint256 i = 0; i < N_COINS; i++) {
            _tokenAmounts[i] = tokenAmounts[i];
        }
        return curvePool.calc_token_amount(_tokenAmounts, deposit);
    }

    function _singleStableFromLp(uint256 inAmount, int128 i) internal view returns (uint256) {
        uint256 result = curvePool.calc_withdraw_one_coin(inAmount, i);
        return result;
    }

    /// @notice Convert USD amount to LP tokens
    function _usdToLp(uint256 inAmount) internal view returns (uint256) {
        return inAmount.mul(DEFAULT_DECIMALS_FACTOR).div(curvePool.get_virtual_price());
    }

    /// @notice Calculate price ratios for stablecoins
    ///     Get USD price data for stablecoin
    /// @param i Stablecoin to get USD price for
    function getPriceFeed(uint256 i) external view override returns (uint256 _price) {
        _price = uint256(IChainlinkAggregator(getAggregator(i)).latestAnswer());
    }

    /// @notice Fetch chainlink token ratios
    /// @param i Token in
    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) {
        uint256[3] memory _prices;
        _prices[0] = uint256(IChainlinkAggregator(getAggregator(0)).latestAnswer());
        _prices[1] = uint256(IChainlinkAggregator(getAggregator(1)).latestAnswer());
        _prices[2] = uint256(IChainlinkAggregator(getAggregator(2)).latestAnswer());
        for (uint256 j = 0; j < 3; j++) {
            if (i == j) {
                _ratios[i] = CHAINLINK_PRICE_DECIMAL_FACTOR;
            } else {
                _ratios[j] = _prices[i].mul(CHAINLINK_PRICE_DECIMAL_FACTOR).div(_prices[j]);
            }
        }
        return _ratios;
    }

    function getAggregator(uint256 index) private view returns (address) {
        if (index == 0) {
            return daiUsdAgg;
        } else if (index == 1) {
            return usdcUsdAgg;
        } else {
            return usdtUsdAgg;
        }
    }

    /// @notice Get absolute value
    function abs(int256 x) private pure returns (uint256) {
        return x >= 0 ? uint256(x) : uint256(-x);
    }

    function _updateRatios(uint256 tolerance) private returns (bool) {
        uint256[N_COINS] memory chainRatios = getTokenRatios(0);
        uint256[N_COINS] memory newRatios;
        for (uint256 i = 1; i < N_COINS; i++) {
            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));
            uint256 check = abs(int256(_ratio) - int256(chainRatios[i].div(CHAIN_FACTOR)));
            if (check.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > tolerance) {
                return false;
            } else {
                newRatios[i] = _ratio;
            }
        }
        for (uint256 i = 1; i < N_COINS; i++) {
            lastRatio[i] = newRatios[i];
        }
        return true;
    }
}",2761,260,"H-01: implicit underflows  L87 H-03: Buoy3Pool.safetyCheck is not precise and has some assumptions M-05: Use of deprecated Chainlink function latestAnswer. L207, L214",3
192_Position.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";
import ""./utils/MetaContext.sol"";
import ""./interfaces/IPosition.sol"";

contract Position is ERC721Enumerable, MetaContext, IPosition {

    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {
        return ERC721.ownerOf(_id);
    }

    using Counters for Counters.Counter;
    uint constant public DIVISION_CONSTANT = 1e10; 
    // 100%

    mapping(uint => mapping(address => uint)) public vaultFundingPercent;

    mapping(address => bool) private _isMinter; 
    // Trading contract should be minter
    mapping(uint256 => Trade) private _trades; 
    // NFT id to Trade

    uint256[] private _openPositions;
    mapping(uint256 => uint256) private _openPositionsIndexes;

    mapping(uint256 => uint256[]) private _assetOpenPositions;
    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;

    mapping(uint256 => uint256[]) private _limitOrders; 
    // List of limit order nft ids per asset
    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; 
    // Keeps track of asset -> id -> array index

    // Funding
    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;
    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;
    mapping(uint256 => mapping(address => uint256)) private lastUpdate;
    mapping(uint256 => int256) private initId;
    mapping(uint256 => mapping(address => uint256)) private longOi;
    mapping(uint256 => mapping(address => uint256)) private shortOi;

    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }
    function trades(uint _id) public view returns (Trade memory) {
        Trade memory _trade = _trades[_id];
        _trade.trader = ownerOf(_id);
        if (_trade.orderType > 0) return _trade;
        
        int256 _pendingFunding;
        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {
            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);
            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {
                _pendingFunding = -_pendingFunding;
            } else {
                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;
            }
        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {
            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);
            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {
                _pendingFunding = -_pendingFunding;
            } else {
                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;
            }
        }
        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];
        
        return _trade;
    }
    function openPositions() public view returns (uint256[] memory) { return _openPositions; }
    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }
    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }
    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }
    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }
    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }

    Counters.Counter private _tokenIds;
    string public baseURI;

    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
        _tokenIds.increment();
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function setBaseURI(string memory _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    /**
    * @notice Update funding rate after open interest change
    * @dev only callable by minter
    * @param _asset pair id
    * @param _tigAsset tigAsset token address
    * @param _longOi long open interest
    * @param _shortOi short open interest
    * @param _baseFundingRate base funding rate of a pair
    * @param _vaultFundingPercent percent of earned funding going to the stablevault
    */
    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {
        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {
            if (longOi[_asset][_tigAsset] > 0) {
                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;
            }
            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);

        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {
            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);
            if (shortOi[_asset][_tigAsset] > 0) {
                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;
            }
        }
        lastUpdate[_asset][_tigAsset] = block.timestamp;
        int256 _oiDelta;
        if (_longOi > _shortOi) {
            _oiDelta = int256(_longOi)-int256(_shortOi);
        } else {
            _oiDelta = int256(_shortOi)-int256(_longOi);
        }
        
        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;
        longOi[_asset][_tigAsset] = _longOi;
        shortOi[_asset][_tigAsset] = _shortOi;
        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;
    }

    /**
    * @notice mint a new position nft
    * @dev only callable by minter
    * @param _mintTrade New trade params in struct
    */
    function mint(
        MintTrade memory _mintTrade
    ) external onlyMinter {
        uint newTokenID = _tokenIds.current();

        Trade storage newTrade = _trades[newTokenID];
        newTrade.margin = _mintTrade.margin;
        newTrade.leverage = _mintTrade.leverage;
        newTrade.asset = _mintTrade.asset;
        newTrade.direction = _mintTrade.direction;
        newTrade.price = _mintTrade.price;
        newTrade.tpPrice = _mintTrade.tp;
        newTrade.slPrice = _mintTrade.sl;
        newTrade.orderType = _mintTrade.orderType;
        newTrade.id = newTokenID;
        newTrade.tigAsset = _mintTrade.tigAsset;

        _safeMint(_mintTrade.account, newTokenID);
        if (_mintTrade.orderType > 0) {
            _limitOrders[_mintTrade.asset].push(newTokenID);
            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;
        } else {
            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;
            _openPositions.push(newTokenID);
            _openPositionsIndexes[newTokenID] = _openPositions.length-1;

            _assetOpenPositions[_mintTrade.asset].push(newTokenID);
            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;
        }
        _tokenIds.increment();
    }

    /**
     * @param _id id of the position NFT
     * @param _price price used for execution
     * @param _newMargin margin after fees
     */
    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {
        Trade storage _trade = _trades[_id];
        if (_trade.orderType == 0) {
            return;
        }
        _trade.orderType = 0;
        _trade.price = _price;
        _trade.margin = _newMargin;
        uint _asset = _trade.asset;
        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];
        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];
        delete _limitOrderIndexes[_asset][_id];
        _limitOrders[_asset].pop();

        _openPositions.push(_id);
        _openPositionsIndexes[_id] = _openPositions.length-1;
        _assetOpenPositions[_asset].push(_id);
        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;

        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;
    }

    /**
    * @notice modifies margin and leverage
    * @dev only callable by minter
    * @param _id position id
    * @param _newMargin new margin amount
    * @param _newLeverage new leverage amount
    */
    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {
        _trades[_id].margin = _newMargin;
        _trades[_id].leverage = _newLeverage;
    }

    /**
    * @notice modifies margin and entry price
    * @dev only callable by minter
    * @param _id position id
    * @param _newMargin new margin amount
    * @param _newPrice new entry price
    */
    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {
        _trades[_id].margin = _newMargin;
        _trades[_id].price = _newPrice;
        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;
    }

    /**
    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding
    * @dev only callable by minter
    * @param _id position id
    */
    function setAccInterest(uint256 _id) external onlyMinter {
        _trades[_id].accInterest = trades(_id).accInterest;
    }

    /**
    * @notice Reduces position size by %
    * @dev only callable by minter
    * @param _id position id
    * @param _percent percent of a position being closed
    */
    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {
        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);
        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;
        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;
    }

    /**
    * @notice change a position tp price
    * @dev only callable by minter
    * @param _id position id
    * @param _tpPrice tp price
    */
    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {
        _trades[_id].tpPrice = _tpPrice;
    }

    /**
    * @notice change a position sl price
    * @dev only callable by minter
    * @param _id position id
    * @param _slPrice sl price
    */
    function modifySl(uint _id, uint _slPrice) external onlyMinter {
        _trades[_id].slPrice = _slPrice;
    }

    /**
    * @dev Burns an NFT and it's data
    * @param _id ID of the trade
    */
    function burn(uint _id) external onlyMinter {
        _burn(_id);
        uint _asset = _trades[_id].asset;
        if (_trades[_id].orderType > 0) {
            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];
            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];
            delete _limitOrderIndexes[_asset][_id];
            _limitOrders[_asset].pop();            
        } else {
            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];
            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];
            delete _assetOpenPositionsIndexes[_asset][_id];
            _assetOpenPositions[_asset].pop();  

            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];
            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];
            delete _openPositionsIndexes[_id];
            _openPositions.pop();              
        }
        delete _trades[_id];
    }

    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {
        return _assetOpenPositions[_asset].length;
    }

    function limitOrdersLength(uint _asset) external view returns (uint256) {
        return _limitOrders[_asset].length;
    }

    function getCount() external view returns (uint) {
        return _tokenIds.current();
    }

    function userTrades(address _user) external view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        for (uint i=0; i<_ids.length; i++) {
            _ids[i] = tokenOfOwnerByIndex(_user, i);
        }
        return _ids;
    }

    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {
        uint[] memory _ids = new uint[](_to-_from);
        for (uint i=0; i<_ids.length; i++) {
            _ids[i] = _openPositions[i+_from];
        }
        return _ids;
    }

    function setMinter(address _minter, bool _bool) external onlyOwner {
        _isMinter[_minter] = _bool;
    }    

    modifier onlyMinter() {
        require(_isMinter[_msgSender()], ""!Minter"");
        _;
    }

    // META-TX
    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {
        return MetaContext._msgSender();
    }
    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {
        return MetaContext._msgData();
    }
}",3889,331,H-07: reentrancy attack during mint() function in Position contract which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value,1
5_USDV.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";

contract USDV is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    uint public nextEraTime;
    uint public blockDelay;

    address public VADER;
    address public VAULT;
    address public ROUTER;

    mapping(address => uint) public lastBlock;

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool isMatured){
        if(lastBlock[tx.origin] + blockDelay <= block.number){ 
            return true;
        }
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER STABLE DOLLAR';
        symbol = 'USDV';
        decimals = 18;
        totalSupply = 0;
    }
    function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        if(amount > 0){                                     
            require(sender != address(0), ""sender"");
            _balances[sender] -= amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
            _checkIncentives();
        }
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""recipient"");
            totalSupply += amount;
            _balances[account] += amount;
            emit Transfer(address(0), account, amount);
        }
    }
    // Burn supply
    function burn(uint amount) external virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender)- amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""address err"");
            _balances[account] -= amount;
            totalSupply -= amount;
            emit Transfer(account, address(0), amount);
        }
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newDelay) external onlyDAO {
        blockDelay = newDelay;
    }

   //======================================INCENTIVES========================================//
    // Internal - Update incentives function
    function _checkIncentives() private {
        if (block.timestamp >= nextEraTime && emitting()) {                 
            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _balance = iERC20(VADER).balanceOf(address(this));        
            if(_balance > 4){
                uint _USDVShare = _balance/2;                                   
                _convert(address(this), _USDVShare);                            
                if(balanceOf(address(this)) > 2){
                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              
                    _transfer(address(this), VAULT, balanceOf(address(this)));                   
                }
                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   
                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      
            }
        }
    }
    
    //======================================ASSET MINTING========================================//
    // Convert to USDV
    function convert(uint amount) external returns(uint) {
        return convertForMember(msg.sender, amount);
    }
    // Convert for members
    function convertForMember(address member, uint amount) public returns(uint) {
        getFunds(VADER, amount);
        return _convert(member, amount);
    }
    // Internal convert
    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){
        if(minting()){
            lastBlock[tx.origin] = block.number;                    
            iERC20(VADER).burn(amount);
            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); 
            _mint(_member, _convertAmount);
        }
    }
    // Redeem to VADER
    function redeem(uint amount) external returns(uint) {
        return redeemForMember(msg.sender, amount);
    }
    // Contracts to redeem for members
    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {
        _transfer(msg.sender, VADER, amount);                   
        redeemAmount = iVADER(VADER).redeemToMember(member);   
        lastBlock[tx.origin] = block.number;                    
    }

    //============================== ASSETS ================================//

    function getFunds(address token, uint amount) internal {
        if(token == address(this)){
            _transfer(msg.sender, address(this), amount);
        } else {
            if(tx.origin==msg.sender){
                require(iERC20(token).transferTo(address(this), amount));
            }else{
                require(iERC20(token).transferFrom(msg.sender, address(this), amount));
            }
        }
    }

    //============================== HELPERS ================================//

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function minting() public view returns(bool){
        return iVADER(VADER).minting();
    }

}",1713,219,"H-02: Flash attack mitigation does not work as intended in USDV.sol M-13: Init function can be called by everyone M-17: Vader.redeemToMember() vulnerable to front running",3
37_TempusController.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""./amm/interfaces/ITempusAMM.sol"";
import ""./amm/interfaces/IVault.sol"";
import ""./ITempusPool.sol"";
import ""./math/Fixed256xVar.sol"";
import ""./utils/PermanentlyOwnable.sol"";
import ""./utils/AMMBalancesHelper.sol"";
import ""./utils/UntrustedERC20.sol"";

contract TempusController is PermanentlyOwnable, ReentrancyGuard {
    using Fixed256xVar for uint256;
    using SafeERC20 for IERC20;
    using UntrustedERC20 for IERC20;
    using AMMBalancesHelper for uint256[];

    /// @dev Event emitted on a successful BT/YBT deposit.
    /// @param pool The Tempus Pool to which assets were deposited
    /// @param depositor Address of the user who deposited Yield Bearing Tokens to mint
    ///                  Tempus Principal Share (TPS) and Tempus Yield Shares
    /// @param recipient Address of the recipient who will receive TPS and TYS tokens
    /// @param yieldTokenAmount Amount of yield tokens received from underlying pool
    /// @param backingTokenValue Value of @param yieldTokenAmount expressed in backing tokens
    /// @param shareAmounts Number of Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS) granted to `recipient`
    /// @param interestRate Interest Rate of the underlying pool from Yield Bearing Tokens to the underlying asset
    /// @param fee The fee which was deducted (in terms of yield bearing tokens)
    event Deposited(
        address indexed pool,
        address indexed depositor,
        address indexed recipient,
        uint256 yieldTokenAmount,
        uint256 backingTokenValue,
        uint256 shareAmounts,
        uint256 interestRate,
        uint256 fee
    );

    /// @dev Event emitted on a successful BT/YBT redemption.
    /// @param pool The Tempus Pool from which Tempus Shares were redeemed
    /// @param redeemer Address of the user whose Shares (Principals and Yields) are redeemed
    /// @param recipient Address of user that recieved Yield Bearing Tokens
    /// @param principalShareAmount Number of Tempus Principal Shares (TPS) to redeem into the Yield Bearing Token (YBT)
    /// @param yieldShareAmount Number of Tempus Yield Shares (TYS) to redeem into the Yield Bearing Token (YBT)
    /// @param yieldTokenAmount Number of Yield bearing tokens redeemed from the pool
    /// @param backingTokenValue Value of @param yieldTokenAmount expressed in backing tokens
    /// @param interestRate Interest Rate of the underlying pool from Yield Bearing Tokens to the underlying asset
    /// @param fee The fee which was deducted (in terms of yield bearing tokens)
    /// @param isEarlyRedeem True in case of early redemption, otherwise false
    event Redeemed(
        address indexed pool,
        address indexed redeemer,
        address indexed recipient,
        uint256 principalShareAmount,
        uint256 yieldShareAmount,
        uint256 yieldTokenAmount,
        uint256 backingTokenValue,
        uint256 interestRate,
        uint256 fee,
        bool isEarlyRedeem
    );

    /// @dev Atomically deposits YBT/BT to TempusPool and provides liquidity
    ///      to the corresponding Tempus AMM with the issued TYS & TPS
    /// @param tempusAMM Tempus AMM to use to swap TYS for TPS
    /// @param tokenAmount Amount of YBT/BT to be deposited
    /// @param isBackingToken specifies whether the deposited asset is the Backing Token or Yield Bearing Token
    function depositAndProvideLiquidity(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken
    ) external payable nonReentrant {
        _depositAndProvideLiquidity(tempusAMM, tokenAmount, isBackingToken);
    }

    /// @dev Adds liquidity to tempusAMM with ratio of shares that is equal to ratio in AMM
    /// @param tempusAMM Tempus AMM to provide liquidity to
    /// @param sharesAmount Amount of shares to be used to provide liquidity, one of the sahres will be partially used
    /// @notice If sharesAmount is 100 and amm balances ratio is 1 principal : 10 yields 90 principal will be ""unused""
    ///         So, liquidity will be provided with 10 principals and 100 yields
    /// @notice msg.sender needs to approve Controller for both Principals and Yields for @param sharesAmount
    function provideLiquidity(ITempusAMM tempusAMM, uint256 sharesAmount) external nonReentrant {
        (
            IVault vault,
            bytes32 poolId,
            IERC20[] memory ammTokens,
            uint256[] memory ammBalances
        ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        _provideLiquidity(msg.sender, vault, poolId, ammTokens, ammBalances, sharesAmount, msg.sender);
    }

    /// @dev Atomically deposits YBT/BT to TempusPool and swaps TYS for TPS to get fixed yield
    ///      See https://docs.balancer.fi/developers/guides/single-swaps#swap-overview
    /// @param tempusAMM Tempus AMM to use to swap TYS for TPS
    /// @param tokenAmount Amount of YBT/BT to be deposited in underlying YBT/BT decimal precision
    /// @param isBackingToken specifies whether the deposited asset is the Backing Token or Yield Bearing Token
    /// @param minTYSRate Minimum exchange rate of TYS (denominated in TPS) to receive in exchange for TPS
    function depositAndFix(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken,
        uint256 minTYSRate
    ) external payable nonReentrant {
        _depositAndFix(tempusAMM, tokenAmount, isBackingToken, minTYSRate);
    }

    /// @dev Deposits Yield Bearing Tokens to a Tempus Pool.
    /// @param targetPool The Tempus Pool to which tokens will be deposited
    /// @param yieldTokenAmount amount of Yield Bearing Tokens to be deposited
    ///                         in YBT Contract precision which can be 18 or 8 decimals
    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)
    function depositYieldBearing(
        ITempusPool targetPool,
        uint256 yieldTokenAmount,
        address recipient
    ) public nonReentrant {
        _depositYieldBearing(targetPool, yieldTokenAmount, recipient);
    }

    /// @dev Deposits Backing Tokens into the underlying protocol and
    ///      then deposited the minted Yield Bearing Tokens to the Tempus Pool.
    /// @param targetPool The Tempus Pool to which tokens will be deposited
    /// @param backingTokenAmount amount of Backing Tokens to be deposited into the underlying protocol
    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)
    function depositBacking(
        ITempusPool targetPool,
        uint256 backingTokenAmount,
        address recipient
    ) public payable nonReentrant {
        _depositBacking(targetPool, backingTokenAmount, recipient);
    }

    /// @dev Redeem TPS+TYS held by msg.sender into Yield Bearing Tokens
    /// @notice `msg.sender` must approve Principals and Yields amounts to `targetPool`
    /// @notice `msg.sender` will receive yield bearing tokens
    /// @notice Before maturity, `principalAmount` must equal to `yieldAmount`
    /// @param targetPool The Tempus Pool from which to redeem Tempus Shares
    /// @param principalAmount Amount of Tempus Principals to redeem in PrincipalShare decimal precision
    /// @param yieldAmount Amount of Tempus Yields to redeem in YieldShare decimal precision
    /// @param recipient Address of user that will recieve yield bearing tokens
    function redeemToYieldBearing(
        ITempusPool targetPool,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    ) public nonReentrant {
        _redeemToYieldBearing(targetPool, msg.sender, principalAmount, yieldAmount, recipient);
    }

    /// @dev Redeem TPS+TYS held by msg.sender into Backing Tokens
    /// @notice `sender` must approve Principals and Yields amounts to this TempusPool
    /// @notice `recipient` will receive the backing tokens
    /// @notice Before maturity, `principalAmount` must equal to `yieldAmount`
    /// @param targetPool The Tempus Pool from which to redeem Tempus Shares
    /// @param principalAmount Amount of Tempus Principals to redeem in PrincipalShare decimal precision
    /// @param yieldAmount Amount of Tempus Yields to redeem in YieldShare decimal precision
    /// @param recipient Address of user that will recieve yield bearing tokens
    function redeemToBacking(
        ITempusPool targetPool,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    ) public nonReentrant {
        _redeemToBacking(targetPool, msg.sender, principalAmount, yieldAmount, recipient);
    }

    /// @dev Withdraws liquidity from TempusAMM
    /// @notice `msg.sender` needs to approve controller for @param lpTokensAmount of LP tokens
    /// @notice Transfers LP tokens to controller and exiting tempusAmm with `msg.sender` as recipient
    /// @param tempusAMM Tempus AMM instance
    /// @param lpTokensAmount Amount of LP tokens to be withdrawn
    /// @param principalAmountOutMin Minimal amount of TPS to be withdrawn
    /// @param yieldAmountOutMin Minimal amount of TYS to be withdrawn
    /// @param toInternalBalances Withdrawing liquidity to internal balances
    function exitTempusAMM(
        ITempusAMM tempusAMM,
        uint256 lpTokensAmount,
        uint256 principalAmountOutMin,
        uint256 yieldAmountOutMin,
        bool toInternalBalances
    ) external nonReentrant {
        _exitTempusAMM(tempusAMM, lpTokensAmount, principalAmountOutMin, yieldAmountOutMin, toInternalBalances);
    }

    /// @dev Withdraws liquidity from TempusAMM and redeems Shares to Yield Bearing or Backing Tokens
    ///      Checks user's balance of principal shares and yield shares
    ///      and exits AMM with exact amounts needed for redemption.
    /// @notice `msg.sender` needs to approve `tempusAMM.tempusPool` for both Yields and Principals
    ///         for `sharesAmount`
    /// @notice `msg.sender` needs to approve controller for whole balance of LP token
    /// @notice Transfers users' LP tokens to controller, then exits tempusAMM with `msg.sender` as recipient.
    ///         After exit transfers remainder of LP tokens back to user
    /// @notice Can fail if there is not enough user balance
    /// @notice Only available before maturity since exiting AMM with exact amounts is disallowed after maturity
    /// @param tempusAMM TempusAMM instance to withdraw liquidity from
    /// @param principals Amount of Principals to redeem
    /// @param yields Amount of Yields to redeem
    /// @param principalsStaked Amount of staked principals (in TempusAMM) to redeem
    /// @param yieldsStaked Amount of staked yields (in TempusAMM) to redeem
    /// @param maxLpTokensToRedeem Maximum amount of LP tokens to spend for staked shares redemption
    /// @param toBackingToken If true redeems to backing token, otherwise redeems to yield bearing
    function exitTempusAMMAndRedeem(
        ITempusAMM tempusAMM,
        uint256 principals,
        uint256 yields,
        uint256 principalsStaked,
        uint256 yieldsStaked,
        uint256 maxLpTokensToRedeem,
        bool toBackingToken
    ) external nonReentrant {
        _exitTempusAMMAndRedeem(
            tempusAMM,
            principals,
            yields,
            principalsStaked,
            yieldsStaked,
            maxLpTokensToRedeem,
            toBackingToken
        );
    }

    /// @dev Withdraws ALL liquidity from TempusAMM and redeems Shares to Yield Bearing or Backing Tokens
    /// @notice `msg.sender` needs to approve controller for whole balance for both Yields and Principals
    /// @notice `msg.sender` needs to approve controller for whole balance of LP token
    /// @notice Can fail if there is not enough user balance
    /// @param tempusAMM TempusAMM instance to withdraw liquidity from
    /// @param lpTokens Number of Lp tokens to redeem
    /// @param principals Number of Principals to redeem
    /// @param yields Number of Yields to redeem
    /// @param minPrincipalsStaked Minimum amount of staked principals to redeem for `lpTokens`
    /// @param minYieldsStaked Minimum amount of staked yields to redeem for `lpTokens`
    /// @param maxLeftoverShares Maximum amount of Principals or Yields to be left in case of early exit
    /// @param toBackingToken If true redeems to backing token, otherwise redeems to yield bearing
    function exitTempusAmmAndRedeem(
        ITempusAMM tempusAMM,
        uint256 lpTokens,
        uint256 principals,
        uint256 yields,
        uint256 minPrincipalsStaked,
        uint256 minYieldsStaked,
        uint256 maxLeftoverShares,
        bool toBackingToken
    ) external nonReentrant {
        _exitTempusAmmAndRedeem(
            tempusAMM,
            lpTokens,
            principals,
            yields,
            getAMMOrderedAmounts(tempusAMM.tempusPool(), minPrincipalsStaked, minYieldsStaked),
            maxLeftoverShares,
            toBackingToken
        );
    }

    /// Finalize the pool after maturity.
    function finalize(ITempusPool targetPool) external nonReentrant {
        targetPool.finalize();
    }

    /// Transfers accumulated Yield Bearing Token (YBT) fees
    /// from @param targetPool contract to `recipient`.
    /// @param targetPool The Tempus Pool from which to transfer fees
    /// @param recipient Address which will receive the specified amount of YBT
    function transferFees(ITempusPool targetPool, address recipient) external nonReentrant {
        targetPool.transferFees(msg.sender, recipient);
    }

    function swap(
        ITempusAMM tempusAMM,
        uint256 swapAmount,
        IERC20 tokenIn,
        IERC20 tokenOut,
        uint256 minReturn
    ) private {
        require(swapAmount > 0, ""Invalid swap amount."");
        tokenIn.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);

        (IVault vault, bytes32 poolId, , ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        IVault.SingleSwap memory singleSwap = IVault.SingleSwap({
            poolId: poolId,
            kind: IVault.SwapKind.GIVEN_IN,
            assetIn: tokenIn,
            assetOut: tokenOut,
            amount: swapAmount,
            userData: """"
        });

        IVault.FundManagement memory fundManagement = IVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });
        vault.swap(singleSwap, fundManagement, minReturn, block.timestamp);
    }

    function _depositAndProvideLiquidity(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken
    ) private {
        (
            IVault vault,
            bytes32 poolId,
            IERC20[] memory ammTokens,
            uint256[] memory ammBalances
        ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        uint256 mintedShares = _deposit(tempusAMM.tempusPool(), tokenAmount, isBackingToken);

        uint256[] memory sharesUsed = _provideLiquidity(
            address(this),
            vault,
            poolId,
            ammTokens,
            ammBalances,
            mintedShares,
            msg.sender
        );

        // Send remaining Shares to user
        if (sharesUsed[0] < mintedShares) {
            ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);
        }
        if (sharesUsed[1] < mintedShares) {
            ammTokens[1].safeTransfer(msg.sender, mintedShares - sharesUsed[1]);
        }
    }

    function _provideLiquidity(
        address sender,
        IVault vault,
        bytes32 poolId,
        IERC20[] memory ammTokens,
        uint256[] memory ammBalances,
        uint256 sharesAmount,
        address recipient
    ) private returns (uint256[] memory) {
        uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);

        if (sender != address(this)) {
            ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);
            ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);
        }

        ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);
        ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: ammTokens,
            maxAmountsIn: ammLiquidityProvisionAmounts,
            userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),
            fromInternalBalance: false
        });

        // Provide TPS/TYS liquidity to TempusAMM
        vault.joinPool(poolId, address(this), recipient, request);

        return ammLiquidityProvisionAmounts;
    }

    function _depositAndFix(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken,
        uint256 minTYSRate
    ) private {
        ITempusPool targetPool = tempusAMM.tempusPool();
        IERC20 principalShares = IERC20(address(targetPool.principalShare()));
        IERC20 yieldShares = IERC20(address(targetPool.yieldShare()));

        uint256 swapAmount = _deposit(targetPool, tokenAmount, isBackingToken);

        yieldShares.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);
        uint256 minReturn = swapAmount.mulfV(minTYSRate, targetPool.backingTokenONE());
        swap(tempusAMM, swapAmount, yieldShares, principalShares, minReturn);

        // At this point all TYS must be swapped for TPS
        uint256 principalsBalance = principalShares.balanceOf(address(this));
        assert(principalsBalance > 0);
        assert(yieldShares.balanceOf(address(this)) == 0);

        principalShares.safeTransfer(msg.sender, principalsBalance);
    }

    function _deposit(
        ITempusPool targetPool,
        uint256 tokenAmount,
        bool isBackingToken
    ) private returns (uint256 mintedShares) {
        mintedShares = isBackingToken
            ? _depositBacking(targetPool, tokenAmount, address(this))
            : _depositYieldBearing(targetPool, tokenAmount, address(this));
    }

    function _depositYieldBearing(
        ITempusPool targetPool,
        uint256 yieldTokenAmount,
        address recipient
    ) private returns (uint256) {
        require(yieldTokenAmount > 0, ""yieldTokenAmount is 0"");

        IERC20 yieldBearingToken = IERC20(targetPool.yieldBearingToken());

        // Deposit to controller and approve transfer from controller to targetPool
        uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, address(this), yieldTokenAmount);
        yieldBearingToken.safeIncreaseAllowance(address(targetPool), transferredYBT);

        (uint mintedShares, uint depositedBT, uint fee, uint rate) = targetPool.deposit(transferredYBT, recipient);

        emit Deposited(
            address(targetPool),
            msg.sender,
            recipient,
            transferredYBT,
            depositedBT,
            mintedShares,
            rate,
            fee
        );

        return mintedShares;
    }

    function _depositBacking(
        ITempusPool targetPool,
        uint256 backingTokenAmount,
        address recipient
    ) private returns (uint256) {
        require(backingTokenAmount > 0, ""backingTokenAmount is 0"");

        IERC20 backingToken = IERC20(targetPool.backingToken());

        if (msg.value == 0) {
            backingTokenAmount = backingToken.untrustedTransferFrom(msg.sender, address(this), backingTokenAmount);
            backingToken.safeIncreaseAllowance(address(targetPool), backingTokenAmount);
        } else {
            require(address(backingToken) == address(0), ""given TempusPool's Backing Token is not ETH"");
        }

        (uint256 mintedShares, uint256 depositedYBT, uint256 fee, uint256 interestRate) = targetPool.depositBacking{
            value: msg.value
        }(backingTokenAmount, recipient);

        emit Deposited(
            address(targetPool),
            msg.sender,
            recipient,
            depositedYBT,
            backingTokenAmount,
            mintedShares,
            interestRate,
            fee
        );

        return mintedShares;
    }

    function _redeemToYieldBearing(
        ITempusPool targetPool,
        address sender,
        uint256 principals,
        uint256 yields,
        address recipient
    ) private {
        require((principals > 0) || (yields > 0), ""principalAmount and yieldAmount cannot both be 0"");

        (uint redeemedYBT, uint fee, uint interestRate) = targetPool.redeem(sender, principals, yields, recipient);

        uint redeemedBT = targetPool.numAssetsPerYieldToken(redeemedYBT, targetPool.currentInterestRate());
        bool earlyRedeem = !targetPool.matured();
        emit Redeemed(
            address(targetPool),
            sender,
            recipient,
            principals,
            yields,
            redeemedYBT,
            redeemedBT,
            fee,
            interestRate,
            earlyRedeem
        );
    }

    function _redeemToBacking(
        ITempusPool targetPool,
        address sender,
        uint256 principals,
        uint256 yields,
        address recipient
    ) private {
        require((principals > 0) || (yields > 0), ""principalAmount and yieldAmount cannot both be 0"");

        (uint redeemedYBT, uint redeemedBT, uint fee, uint rate) = targetPool.redeemToBacking(
            sender,
            principals,
            yields,
            recipient
        );

        bool earlyRedeem = !targetPool.matured();
        emit Redeemed(
            address(targetPool),
            sender,
            recipient,
            principals,
            yields,
            redeemedYBT,
            redeemedBT,
            fee,
            rate,
            earlyRedeem
        );
    }

    function _exitTempusAMM(
        ITempusAMM tempusAMM,
        uint256 lpTokensAmount,
        uint256 principalAmountOutMin,
        uint256 yieldAmountOutMin,
        bool toInternalBalances
    ) private {
        require(tempusAMM.transferFrom(msg.sender, address(this), lpTokensAmount), ""LP token transfer failed"");

        ITempusPool tempusPool = tempusAMM.tempusPool();
        uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalAmountOutMin, yieldAmountOutMin);
        _exitTempusAMMGivenLP(tempusAMM, address(this), msg.sender, lpTokensAmount, amounts, toInternalBalances);

        assert(tempusAMM.balanceOf(address(this)) == 0);
    }

    function _exitTempusAMMGivenLP(
        ITempusAMM tempusAMM,
        address sender,
        address recipient,
        uint256 lpTokensAmount,
        uint256[] memory minAmountsOut,
        bool toInternalBalances
    ) private {
        require(lpTokensAmount > 0, ""LP token amount is 0"");

        (IVault vault, bytes32 poolId, IERC20[] memory ammTokens, ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest({
            assets: ammTokens,
            minAmountsOut: minAmountsOut,
            userData: abi.encode(uint8(ITempusAMM.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT), lpTokensAmount),
            toInternalBalance: toInternalBalances
        });
        vault.exitPool(poolId, sender, payable(recipient), request);
    }

    function _exitTempusAMMGivenAmountsOut(
        ITempusAMM tempusAMM,
        address sender,
        address recipient,
        uint256[] memory amountsOut,
        uint256 lpTokensAmountInMax,
        bool toInternalBalances
    ) private {
        (IVault vault, bytes32 poolId, IERC20[] memory ammTokens, ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest({
            assets: ammTokens,
            minAmountsOut: amountsOut,
            userData: abi.encode(
                uint8(ITempusAMM.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT),
                amountsOut,
                lpTokensAmountInMax
            ),
            toInternalBalance: toInternalBalances
        });
        vault.exitPool(poolId, sender, payable(recipient), request);
    }

    function _exitTempusAMMAndRedeem(
        ITempusAMM tempusAMM,
        uint256 principals,
        uint256 yields,
        uint256 principalsStaked,
        uint256 yieldsStaked,
        uint256 maxLpTokensToRedeem,
        bool toBackingToken
    ) private {
        ITempusPool tempusPool = tempusAMM.tempusPool();
        require(!tempusPool.matured(), ""Pool already finalized"");
        principals += principalsStaked;
        yields += yieldsStaked;
        require(principals == yields, ""Needs equal amounts of shares before maturity"");

        // transfer LP tokens to controller
        require(tempusAMM.transferFrom(msg.sender, address(this), maxLpTokensToRedeem), ""LP token transfer failed"");

        uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalsStaked, yieldsStaked);
        _exitTempusAMMGivenAmountsOut(tempusAMM, address(this), msg.sender, amounts, maxLpTokensToRedeem, false);

        // transfer remainder of LP tokens back to user
        uint256 lpTokenBalance = tempusAMM.balanceOf(address(this));
        require(tempusAMM.transferFrom(address(this), msg.sender, lpTokenBalance), ""LP token transfer failed"");

        if (toBackingToken) {
            _redeemToBacking(tempusPool, msg.sender, principals, yields, msg.sender);
        } else {
            _redeemToYieldBearing(tempusPool, msg.sender, principals, yields, msg.sender);
        }
    }

    function _exitTempusAmmAndRedeem(
        ITempusAMM tempusAMM,
        uint256 lpTokens,
        uint256 principals,
        uint256 yields,
        uint256[] memory minLpAmountsOut,
        uint256 maxLeftoverShares,
        bool toBackingToken
    ) private {
        ITempusPool tempusPool = tempusAMM.tempusPool();

        IERC20 principalShare = IERC20(address(tempusPool.principalShare()));
        IERC20 yieldShare = IERC20(address(tempusPool.yieldShare()));
        require(principalShare.transferFrom(msg.sender, address(this), principals), ""Principals transfer failed"");
        require(yieldShare.transferFrom(msg.sender, address(this), yields), ""Yields transfer failed"");

        if (lpTokens > 0) {
            // if there is LP balance, transfer to controller
            require(tempusAMM.transferFrom(msg.sender, address(this), lpTokens), ""LP token transfer failed"");

            // exit amm and sent shares to controller
            _exitTempusAMMGivenLP(tempusAMM, address(this), address(this), lpTokens, minLpAmountsOut, false);
        }

        principals = principalShare.balanceOf(address(this));
        yields = yieldShare.balanceOf(address(this));

        if (!tempusPool.matured()) {
            bool yieldsIn = yields > principals;
            uint256 difference = yieldsIn ? (yields - principals) : (principals - yields);

            if (difference >= maxLeftoverShares) {
                (IERC20 tokenIn, IERC20 tokenOut) = yieldsIn
                    ? (yieldShare, principalShare)
                    : (principalShare, yieldShare);

                swap(
                    tempusAMM,
                    tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),
                    tokenIn,
                    tokenOut,
                    0
                );

                principals = principalShare.balanceOf(address(this));
                yields = yieldShare.balanceOf(address(this));
            }
            (yields, principals) = (principals <= yields) ? (principals, principals) : (yields, yields);
        }

        if (toBackingToken) {
            _redeemToBacking(tempusPool, address(this), principals, yields, msg.sender);
        } else {
            _redeemToYieldBearing(tempusPool, address(this), principals, yields, msg.sender);
        }
    }

    function _getAMMDetailsAndEnsureInitialized(ITempusAMM tempusAMM)
        private
        view
        returns (
            IVault vault,
            bytes32 poolId,
            IERC20[] memory ammTokens,
            uint256[] memory ammBalances
        )
    {
        vault = tempusAMM.getVault();
        poolId = tempusAMM.getPoolId();
        (ammTokens, ammBalances, ) = vault.getPoolTokens(poolId);
        require(
            ammTokens.length == 2 && ammBalances.length == 2 && ammBalances[0] > 0 && ammBalances[1] > 0,
            ""AMM not initialized""
        );
    }

    function getAMMOrderedAmounts(
        ITempusPool tempusPool,
        uint256 principalAmount,
        uint256 yieldAmount
    ) private view returns (uint256[] memory) {
        uint256[] memory amounts = new uint256[](2);
        (amounts[0], amounts[1]) = (tempusPool.principalShare() < tempusPool.yieldShare())
            ? (principalAmount, yieldAmount)
            : (yieldAmount, principalAmount);
        return amounts;
    }
}",6853,704,"H-01: Steal tokens from TempusController. L73-L79 M-01: exitTempusAMM can be made to fail.   M-02: depositAndFix can be made to fail",3
58_UniV3Vault.sol,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/external/univ3/INonfungiblePositionManager.sol"";
import ""./interfaces/external/univ3/IUniswapV3Pool.sol"";
import ""./interfaces/external/univ3/IUniswapV3Factory.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./libraries/external/TickMath.sol"";
import ""./libraries/external/LiquidityAmounts.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.
contract UniV3Vault is IERC721Receiver, Vault {
    struct Options {
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct Pair {
        uint256 a0;
        uint256 a1;
    }

    IUniswapV3Pool public immutable pool;

    uint256 public uniV3Nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param fee Fee of the underlying UniV3 pool
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) Vault(vaultGovernance_, vaultTokens_) {
        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);
        pool = IUniswapV3Pool(
            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)
        );
    }

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {
        require(msg.sender == address(_positionManager()), ""SNFT"");
        require(_isStrategy(operator), ""STR"");
        (
            , ,
            address token0,
            address token1,
            , , , , , , ,
        ) = _positionManager().positions(tokenId);
        // new position should have vault tokens
        require(
            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],
            ""VT""
        );

        if (uniV3Nft != 0) {
            (
                , , , , , , ,
                uint128 liquidity,
                , ,
                uint128 tokensOwed0,
                uint128 tokensOwed1
            ) = _positionManager().positions(uniV3Nft);
            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, ""TVL"");
            // return previous uni v3 position nft
            _positionManager().transferFrom(address(this), from, uniV3Nft);
        }

        uniV3Nft = tokenId;
        return this.onERC721Received.selector;
    }

    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        collectedEarnings = new uint256[](2);
        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );
        collectedEarnings[0] = collectedEarnings0;
        collectedEarnings[1] = collectedEarnings1;
        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        tokenAmounts = new uint256[](_vaultTokens.length);
        if (uniV3Nft == 0)
            return tokenAmounts;
        (
            , , , , , 
            int24 tickLower, 
            int24 tickUpper, 
            uint128 liquidity,
            , , ,
        ) = _positionManager().positions(uniV3Nft);
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
            sqrtPriceX96,
            sqrtPriceAX96,
            sqrtPriceBX96,
            liquidity
        );
        tokenAmounts[0] = amount0;
        tokenAmounts[1] = amount1;
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < tokens.length; i++)
            _allowTokenIfNecessary(tokens[i]);

        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = Pair({
            a0: tokenAmounts[0],
            a1: tokenAmounts[1]
        });
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: uniV3Nft,
                amount0Desired: amounts.a0,
                amount1Desired: amounts.a1,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        actualTokenAmounts[0] = amount0;
        actualTokenAmounts[1] = amount1;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);
        actualTokenAmounts[0] = amounts.a0;
        actualTokenAmounts[1] = amounts.a1;
    }

    function _pullUniV3Nft(
        uint256[] memory tokenAmounts,
        address to,
        Options memory opts
    ) internal returns (Pair memory) {
        uint128 liquidityToPull;
        // scope the code below to avoid stack-too-deep exception
        {
            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);
            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(
                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]
            );
            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;
            if (liquidityToPull == 0) {
                return Pair({a0: 0, a1: 0});
            }
        }
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: uniV3Nft,
                liquidity: liquidityToPull,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: uint128(amount0),
                amount1Max: uint128(amount1)
            })
        );
        return Pair({a0: amount0Collected, a1: amount1Collected});
    }

    function _postReclaimTokens(address, address[] memory tokens) internal view override {}

    /// TODO: make a virtual function here? Or other better approach
    function _positionManager() internal view returns (INonfungiblePositionManager) {
        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;
    }

    function _allowTokenIfNecessary(address token) internal {
        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)
            IERC20(token).approve(address(_positionManager()), type(uint256).max);
    }

    function _parseOptions(bytes memory options) internal view returns (Options memory) {
        if (options.length == 0)
            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});

        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);
        return abi.decode(options, (Options));
    }

    function _isStrategy(address addr) internal view returns (bool) {
        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;
    }

    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);
}",2299,245,H-03: UniV3Vault.sol#collectEarnings() can be front run L100,1
16_Pricing.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./lib/LibMath.sol"";
import ""./lib/LibPrices.sol"";
import ""./Interfaces/IPricing.sol"";
import ""./Interfaces/ITracerPerpetualSwaps.sol"";
import ""./Interfaces/IInsurance.sol"";
import ""./Interfaces/IOracle.sol"";
import ""prb-math/contracts/PRBMathSD59x18.sol"";

contract Pricing is IPricing {
    using LibMath for uint256;
    using LibMath for int256;
    using PRBMathSD59x18 for int256;

    address public tracer;
    IInsurance public insurance;
    IOracle public oracle;

    // pricing metrics
    Prices.PriceInstant[24] internal hourlyTracerPrices;
    Prices.PriceInstant[24] internal hourlyOraclePrices;

    // funding index => funding rate
    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;

    // funding index => insurance funding rate
    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;

    // market's time value
    int256 public override timeValue;

    // funding index
    uint256 public override currentFundingIndex;

    // timing variables
    uint256 public startLastHour;
    uint256 public startLast24Hours;
    uint8 public override currentHour;

    event HourlyPriceUpdated(uint256 price, uint256 currentHour);
    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);
    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);

    /**
     * @dev Set tracer perps factory
     * @dev ensure that oracle contract is returning WAD values. This may be done
     *      by wrapping the raw oracle in an adapter (see contracts/oracle)
     * @param _tracer The address of the tracer this pricing contract links too
     */
    constructor(
        address _tracer,
        address _insurance,
        address _oracle
    ) {
        tracer = _tracer;
        insurance = IInsurance(_insurance);
        oracle = IOracle(_oracle);
        startLastHour = block.timestamp;
        startLast24Hours = block.timestamp;
    }

    /**
     * @notice Updates pricing information given a trade of a certain volume at
     *         a set price
     * @param tradePrice the price the trade executed at
     */
    function recordTrade(uint256 tradePrice) external override onlyTracer {
        uint256 currentOraclePrice = oracle.latestAnswer();
        if (startLastHour <= block.timestamp - 1 hours) {
            // emit the old hourly average
            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);
            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);

            // update funding rate for the previous hour
            updateFundingRate();

            // update the time value
            if (startLast24Hours <= block.timestamp - 24 hours) {
                // Update the interest rate every 24 hours
                updateTimeValue();
                startLast24Hours = block.timestamp;
            }

            // update time metrics after all other state
            startLastHour = block.timestamp;

            // Check current hour and loop around if need be
            if (currentHour == 23) {
                currentHour = 0;
            } else {
                currentHour = currentHour + 1;
            }

            // add new pricing entry for new hour
            updatePrice(tradePrice, currentOraclePrice, true);
        } else {
            // Update old pricing entry
            updatePrice(tradePrice, currentOraclePrice, false);
        }
    }

    /**
     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price
     *         and an oracle price.
     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled
     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle
     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)
     */
    function updatePrice(
        uint256 marketPrice,
        uint256 oraclePrice,
        bool newRecord
    ) internal {
        // Price records entries updated every hour
        if (newRecord) {
            // Make new hourly record, total = marketprice, numtrades set to 1;
            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);
            hourlyTracerPrices[currentHour] = newHourly;
            // As above but with Oracle price
            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);
            hourlyOraclePrices[currentHour] = oracleHour;
        } else {
            // If an update is needed, add the market price to a running total and increment number of trades
            hourlyTracerPrices[currentHour].cumulativePrice =
                hourlyTracerPrices[currentHour].cumulativePrice +
                marketPrice;
            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;
            // As above but with oracle price
            hourlyOraclePrices[currentHour].cumulativePrice =
                hourlyOraclePrices[currentHour].cumulativePrice +
                oraclePrice;
            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;
        }
    }

    /**
     * @notice Updates the funding rate and the insurance funding rate
     */
    function updateFundingRate() internal {
        // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable
        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);
        Prices.TWAP memory twapPrices = getTWAPs(currentHour);
        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();
        uint256 underlyingTWAP = twapPrices.underlying;
        uint256 derivativeTWAP = twapPrices.derivative;

        int256 newFundingRate = PRBMathSD59x18.mul(
            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,
            _tracer.fundingRateSensitivity().toInt256()
        );

        // Create variable with value of new funding rate value
        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;
        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;

        // as above but with insurance funding rate value
        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;
        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;

        // Call setter functions on calculated variables
        setFundingRate(newFundingRate, cumulativeFundingRate);
        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);
        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);
        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);
        // increment funding index
        currentFundingIndex = currentFundingIndex + 1;
    }

    /**
     * @notice Given the address of a tracer market this function will get the current fair price for that market
     */
    function fairPrice() external view override returns (uint256) {
        return Prices.fairPrice(oracle.latestAnswer(), timeValue);
    }

    ////////////////////////////
    ///  SETTER FUNCTIONS   ///
    //////////////////////////

    /**
     * @notice Calculates and then updates the time Value for a tracer market
     */
    function updateTimeValue() internal {
        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();

        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);
    }

    /**
     * @notice Sets the values of the fundingRate struct
     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate
     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated
     */
    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {
        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(
            block.timestamp,
            fundingRate,
            cumulativeFundingRate
        );
    }

    /**
     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker
     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate
     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated
     */
    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {
        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(
            block.timestamp,
            fundingRate,
            cumulativeFundingRate
        );
    }

    // todo by using public variables lots of these can be removed
    /**
     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index
     */
    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {
        return fundingRates[index];
    }

    /**
     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market
     */
    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {
        return insuranceFundingRates[index];
    }

    /**
     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.
     * @param hour An integer representing what hour of the day to collect from (0-24)
     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price
     */
    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {
        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);
    }

    /**
     * @notice Gets a 24 hour tracer and oracle price for a given tracer market
     * @return the average price over a 24 hour period for oracle and Tracer price
     */
    function get24HourPrices() public view override returns (uint256, uint256) {
        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));
    }

    /**
     * @notice Gets the average tracer price for a given market during a certain hour
     * @param hour The hour of which you want the hourly average Price
     * @return the average price of the tracer for a particular hour
     */
    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {
        return Prices.averagePrice(hourlyTracerPrices[hour]);
    }

    /**
     * @notice Gets the average oracle price for a given market during a certain hour
     * @param hour The hour of which you want the hourly average Price
     */
    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {
        return Prices.averagePrice(hourlyOraclePrices[hour]);
    }

    /**
     * @dev Used when only valid tracers are allowed
     */
    modifier onlyTracer() {
        require(msg.sender == tracer, ""PRC: Only Tracer"");
        _;
    }
}",2497,274,"H-01: Wrong trading pricing calculations H-02: Use of incorrect index leads to incorrect updation of funding rates. L155",2
66_StabilityPool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a ""compounded deposit"": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 
        // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 
        // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 
        // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; 
        // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a ""feedback"" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate ""per-unit-staked"" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; 
        // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a ""feedback"" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate ""per-unit-staked"" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; 
            // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want ""slightly too much"" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P ""favors the Pool"", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",12394,1184,H-01: receiveCollateral() can be called by anyone. L1143,1
30_Vault.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./VaultToken.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/ExtendedIERC20.sol"";

/**
 * @title Vault
 * @notice The vault is where users deposit and withdraw
 * like-kind assets that have been added by governance.
 */
contract Vault is VaultToken, IVault {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MAX = 10000;

    IManager public immutable override manager;

    // Strategist-updated variables
    address public override gauge;
    uint256 public min;
    uint256 public totalDepositCap;

    event Deposit(address indexed account, uint256 amount);
    event Withdraw(address indexed account, uint256 amount);
    event Earn(address indexed token, uint256 amount);

    /**
     * @param _name The name of the vault token for depositors
     * @param _symbol The symbol of the vault token for depositors
     * @param _manager The address of the vault manager contract
     */
    constructor(
        string memory _name,
        string memory _symbol,
        address _manager
    )
        public
        VaultToken(_name, _symbol)
    {
        manager = IManager(_manager);
        min = 9500;
        totalDepositCap = 10000000 ether;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the value of this vault's gauge
     * @dev Allow to be unset with the zero address
     * @param _gauge The address of the gauge
     */
    function setGauge(
        address _gauge
    )
        external
        notHalted
        onlyStrategist
    {
        gauge = _gauge;
    }

    /**
     * @notice Sets the value for min
     * @dev min is the minimum percent of funds to keep small withdrawals cheap
     * @param _min The new min value
     */
    function setMin(
        uint256 _min
    )
        external
        notHalted
        onlyStrategist
    {
        require(_min <= MAX, ""!_min"");
        min = _min;
    }

    /**
     * @notice Sets the value for the totalDepositCap
     * @dev totalDepositCap is the maximum amount of value that can be deposited
     * to the metavault at a time
     * @param _totalDepositCap The new totalDepositCap value
     */
    function setTotalDepositCap(
        uint256 _totalDepositCap
    )
        external
        notHalted
        onlyStrategist
    {
        totalDepositCap = _totalDepositCap;
    }

    /**
     * @notice Swaps tokens held within the vault
     * @param _token0 The token address to swap out
     * @param _token1 The token address to to
     * @param _expectedAmount The expected amount of _token1 to receive
     */
    function swap(
        address _token0,
        address _token1,
        uint256 _expectedAmount
    )
        external
        override
        notHalted
        onlyStrategist
        returns (uint256 _balance)
    {
        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));
        _balance = IERC20(_token0).balanceOf(address(this));
        IERC20(_token0).safeTransfer(address(_converter), _balance);
        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies
     */
    function earn(
        address _token,
        address _strategy
    )
        external
        override
        checkToken(_token)
        notHalted
        onlyHarvester
    {
        require(manager.allowedStrategies(_strategy), ""!_strategy"");
        IController _controller = IController(manager.controllers(address(this)));
        if (_controller.investEnabled()) {
            uint256 _balance = available(_token);
            IERC20(_token).safeTransfer(address(_controller), _balance);
            _controller.earn(_strategy, _token, _balance);
            emit Earn(_token, _balance);
        }
    }

    /**
     * USER-FACING FUNCTIONS
     */

    /**
     * @notice Deposits the given token into the vault
     * @param _token The address of the token
     * @param _amount The amount of tokens to deposit
     */
     function deposit(
        address _token,
        uint256 _amount
     )
        public
        override
        checkToken(_token)
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);

        if (_amount > 0) {
            _amount = _normalizeDecimals(_token, _amount);

            if (totalSupply() > 0) {
                _amount = (_amount.mul(totalSupply())).div(_balance);
            }

            _shares = _amount;
        }

        if (_shares > 0) {
            _mint(msg.sender, _shares);
            require(totalSupply() <= totalDepositCap, "">totalDepositCap"");
            emit Deposit(msg.sender, _shares);
        }
    }

    /**
     * @notice Deposits multiple tokens simultaneously to the vault
     * @dev Users must approve the vault to spend their stablecoin
     * @param _tokens The addresses of each token being deposited
     * @param _amounts The amounts of each token being deposited
     */
    function depositMultiple(
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
        override
        returns (uint256 _shares)
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i; i < _amounts.length; i++) {
            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));
        }
    }

    /**
     * @notice Withdraws an amount of shares to a given output token
     * @param _shares The amount of shares to withdraw
     * @param _output The address of the token to receive
     */
    function withdraw(
        uint256 _shares,
        address _output
    )
        public
        override
        checkToken(_output)
    {
        uint256 _amount = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();
        if (_withdrawalProtectionFee > 0) {
            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);
            _amount = _amount.sub(_withdrawalProtection);
        }

        uint256 _balance = IERC20(_output).balanceOf(address(this));
        if (_balance < _amount) {
            IController _controller = IController(manager.controllers(address(this)));
            uint256 _toWithdraw = _amount.sub(_balance);
            if (_controller.strategies() > 0) {
                _controller.withdraw(_output, _toWithdraw);
            }
            uint256 _after = IERC20(_output).balanceOf(address(this));
            uint256 _diff = _after.sub(_balance);
            if (_diff < _toWithdraw) {
                _amount = _after;
            }
        }

        IERC20(_output).safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /**
     * @notice Withdraw the entire balance for an account
     * @param _output The address of the desired token to receive
     */
    function withdrawAll(
        address _output
    )
        external
        override
    {
        withdraw(balanceOf(msg.sender), _output);
    }

    /**
     * VIEWS
     */

    /**
     * @notice Returns the amount of tokens available to be sent to strategies
     * @dev Custom logic in here for how much the vault allows to be borrowed
     * @dev Sets minimum required on-hand to keep small withdrawals cheap
     * @param _token The address of the token
     */
    function available(
        address _token
    )
        public
        view
        override
        returns (uint256)
    {
        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);
    }

    /**
     * @notice Returns the total balance of the vault, including strategies
     */
    function balance()
        public
        view
        override
        returns (uint256 _balance)
    {
        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());
    }

    /**
     * @notice Returns the balance of allowed tokens present on the vault only
     */
    function balanceOfThis()
        public
        view
        returns (uint256 _balance)
    {
        address[] memory _tokens = manager.getTokens(address(this));
        for (uint8 i; i < _tokens.length; i++) {
            address _token = _tokens[i];
            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
        }
    }

    /**
     * @notice Returns the rate of vault shares
     */
    function getPricePerFullShare()
        external
        view
        override
        returns (uint256)
    {
        if (totalSupply() > 0) {
            return balance().mul(1e18).div(totalSupply());
        } else {
            return balance();
        }
    }

    /**
     * @notice Returns an array of the tokens for this vault
     */
    function getTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return manager.getTokens(address(this));
    }

    /**
     * @notice Returns the fee for withdrawing the given amount
     * @param _amount The amount to withdraw
     */
    function withdrawFee(
        uint256 _amount
    )
        external
        view
        override
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    function _normalizeDecimals(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (uint256)
    {
        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());
        if (_decimals < 18) {
            _amount = _amount.mul(10**(18-_decimals));
        }
        return _amount;
    }

    /**
     * MODIFIERS
     */

    modifier checkToken(address _token) {
        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), ""!_token"");
        _;
    }

    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",2561,409,"H-03: No safety check in addToken  L293 H-05: Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.   L147-L180 H-06: earn results in decreasing share price.  L293 H-09: removeToken would break the vault/protocol.   L217 H-10: An attacker can steal funds from multi-token vaults  L324 L310",5
69_NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1672,171,"H-02 The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees L157 L49 M-02: NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver M-10: NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract M-16: Malicious receiver can make distribute function denial of service",4
16_Liquidation.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./lib/LibMath.sol"";
import ""./lib/LibLiquidation.sol"";
import ""./lib/LibBalances.sol"";
import ""./lib/LibPerpetuals.sol"";
import ""./Interfaces/ILiquidation.sol"";
import ""./Interfaces/ITrader.sol"";
import ""./Interfaces/ITracerPerpetualSwaps.sol"";
import ""./Interfaces/ITracerPerpetualsFactory.sol"";
import ""./Interfaces/IOracle.sol"";
import ""./Interfaces/IPricing.sol"";
import ""./Interfaces/IInsurance.sol"";

/**
 * Each call enforces that the contract calling the account is only updating the balance
 * of the account for that contract.
 */
contract Liquidation is ILiquidation, Ownable {
    using LibMath for uint256;
    using LibMath for int256;

    uint256 public override currentLiquidationId;
    uint256 public override maxSlippage;
    uint256 public override releaseTime = 15 minutes;
    uint256 public override minimumLeftoverGasCostMultiplier = 10;
    IPricing public pricing;
    ITracerPerpetualSwaps public tracer;
    address public insuranceContract;
    address public fastGasOracle;

    // Receipt ID => LiquidationReceipt
    mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;

    event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);
    event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);
    event Liquidate(
        address indexed account,
        address indexed liquidator,
        int256 liquidationAmount,
        Perpetuals.Side side,
        address indexed market,
        uint256 liquidationId
    );
    event InvalidClaimOrder(uint256 indexed receiptId);

    /**
     * @param _pricing Pricing.sol contract address
     * @param _tracer TracerPerpetualSwaps.sol contract address
     * @param _insuranceContract Insurance.sol contract address
     * @param _fastGasOracle Address of the contract that implements the IOracle.sol interface
     * @param _maxSlippage The maximum slippage percentage that is allowed on selling a
                           liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18
     */
    constructor(
        address _pricing,
        address _tracer,
        address _insuranceContract,
        address _fastGasOracle,
        uint256 _maxSlippage
    ) Ownable() {
        pricing = IPricing(_pricing);
        tracer = ITracerPerpetualSwaps(_tracer);
        insuranceContract = _insuranceContract;
        fastGasOracle = _fastGasOracle;
        maxSlippage = _maxSlippage;
    }

    /**
     * @notice Creates a liquidation receipt for a given trader
     * @param liquidator the account executing the liquidation
     * @param liquidatee the account being liquidated
     * @param price the price at which this liquidation event occurred
     * @param escrowedAmount the amount of funds required to be locked into escrow
     *                       by the liquidator
     * @param amountLiquidated the amount of positions that were liquidated
     * @param liquidationSide the side of the positions being liquidated. true for long
     *                        false for short.
     */
    function submitLiquidation(
        address liquidator,
        address liquidatee,
        uint256 price,
        uint256 escrowedAmount,
        int256 amountLiquidated,
        Perpetuals.Side liquidationSide
    ) internal {
        liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({
            tracer: address(tracer),
            liquidator: liquidator,
            liquidatee: liquidatee,
            price: price,
            time: block.timestamp,
            escrowedAmount: escrowedAmount,
            releaseTime: block.timestamp + releaseTime,
            amountLiquidated: amountLiquidated,
            escrowClaimed: false,
            liquidationSide: liquidationSide,
            liquidatorRefundClaimed: false
        });
        currentLiquidationId += 1;
    }

    /**
     * @notice Allows a trader to claim escrowed funds after the escrow period has expired
     * @param receiptId The ID number of the insurance receipt from which funds are being claimed from
     */
    function claimEscrow(uint256 receiptId) public override {
        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];
        require(!receipt.escrowClaimed, ""LIQ: Escrow claimed"");
        require(block.timestamp > receipt.releaseTime, ""LIQ: Not released"");

        // Mark as claimed
        liquidationReceipts[receiptId].escrowClaimed = true;

        // Update balance
        int256 amountToReturn = receipt.escrowedAmount.toInt256();
        emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);
        tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);
    }

    /**
     * @notice Returns liquidation receipt data for a given receipt id.
     * @param id the receipt id to get data for
     */
    function getLiquidationReceipt(uint256 id)
        external
        view
        override
        returns (LibLiquidation.LiquidationReceipt memory)
    {
        return liquidationReceipts[id];
    }

    /**
     * @notice Verify that a Liquidation is valid; submits liquidation receipt if it is
     * @dev Reverts if the liquidation is invalid
     * @param base Amount of base in the account to be liquidated (denominated in base tokens)
     * @param price Fair price of the asset (denominated in quote/base)
     * @param quote Amount of quote in the account to be liquidated (denominated in quote tokens)
     * @param amount Amount of tokens to be liquidated
     * @param gasPrice Current gas price, denominated in gwei
     * @param account Account to be liquidated
     * @return Amount to be escrowed for the liquidation
     */
    function verifyAndSubmitLiquidation(
        int256 base,
        uint256 price,
        int256 quote,
        int256 amount,
        uint256 gasPrice,
        address account
    ) internal returns (uint256) {
        require(amount > 0, ""LIQ: Liquidation amount <= 0"");
        require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), ""LIQ: GasPrice > FGasPrice"");

        Balances.Position memory pos = Balances.Position(quote, base);
        uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();

        int256 currentMargin = Balances.margin(pos, price);
        require(
            currentMargin <= 0 ||
                uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),
            ""LIQ: Account above margin""
        );
        require(amount <= base.abs(), ""LIQ: Liquidate Amount > Position"");

        // calc funds to liquidate and move to Escrow
        uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(
            Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),
            currentMargin,
            amount,
            base
        );

        // create a liquidation receipt
        Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;
        submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);
        return amountToEscrow;
    }

    /**
     * @return true if the margin is greater than 10x liquidation gas cost (in quote tokens)
     * @param updatedPosition The agent's position after being liquidated
     * @param lastUpdatedGasPrice The last updated gas price of the account to be liquidated
     */
    function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)
        public
        view
        returns (bool)
    {
        uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();
        uint256 price = pricing.fairPrice();

        return
            LibLiquidation.partialLiquidationIsValid(
                updatedPosition,
                lastUpdatedGasPrice,
                liquidationGasCost,
                price,
                minimumLeftoverGasCostMultiplier
            );
    }

    /**
     * @notice Liquidates the margin account of a particular user. A deposit is needed from the liquidator.
     *         Generates a liquidation receipt for the liquidator to use should they need a refund.
     * @param amount The amount of tokens to be liquidated
     * @param account The account that is to be liquidated.
     */
    function liquidate(int256 amount, address account) external override {
        /* Liquidated account's balance */
        Balances.Account memory liquidatedBalance = tracer.getBalance(account);

        uint256 amountToEscrow = verifyAndSubmitLiquidation(
            liquidatedBalance.position.base,
            pricing.fairPrice(),
            liquidatedBalance.position.quote,
            amount,
            liquidatedBalance.lastUpdatedGasPrice,
            account
        );

        (
            int256 liquidatorQuoteChange,
            int256 liquidatorBaseChange,
            int256 liquidateeQuoteChange,
            int256 liquidateeBaseChange
        ) = LibLiquidation.liquidationBalanceChanges(
            liquidatedBalance.position.base,
            liquidatedBalance.position.quote,
            amount
        );

        Balances.Position memory updatedPosition = Balances.Position(
            liquidatedBalance.position.quote + liquidateeQuoteChange,
            liquidatedBalance.position.base + liquidateeBaseChange
        );

        require(
            checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),
            ""LIQ: leaves too little left over""
        );

        tracer.updateAccountsOnLiquidation(
            msg.sender,
            account,
            liquidatorQuoteChange,
            liquidatorBaseChange,
            liquidateeQuoteChange,
            liquidateeBaseChange,
            amountToEscrow
        );

        emit Liquidate(
            account,
            msg.sender,
            amount,
            (liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),
            address(tracer),
            currentLiquidationId - 1
        );
    }

    /**
     * @notice Calculates the number of units sold and the average price of those units by a trader
     *         given multiple order
     * @param orders a list of orders for which the units sold is being calculated from
     * @param traderContract The trader contract with which the orders were made
     * @param receiptId the id of the liquidation receipt the orders are being claimed against
     */
    function calcUnitsSold(
        Perpetuals.Order[] memory orders,
        address traderContract,
        uint256 receiptId
    ) public override returns (uint256, uint256) {
        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];
        uint256 unitsSold;
        uint256 avgPrice;
        for (uint256 i; i < orders.length; i++) {
            Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);

            if (
                order.created < receipt.time || // Order made before receipt
                order.maker != receipt.liquidator || // Order made by someone who isn't liquidator
                order.side == receipt.liquidationSide // Order is in same direction as liquidation
                /* Order should be the opposite to the position acquired on liquidation */
            ) {
                emit InvalidClaimOrder(receiptId);
                continue;
            }
            if (
                (receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||
                (receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)
            ) {
                // Liquidation position was long
                // Price went up, so not a slippage order
                // or
                // Liquidation position was short
                // Price went down, so not a slippage order
                emit InvalidClaimOrder(receiptId);
                continue;
            }
            uint256 orderFilled = ITrader(traderContract).filledAmount(order);
            uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);

            /* order.created >= receipt.time
             * && order.maker == receipt.liquidator
             * && order.side != receipt.liquidationSide */
            unitsSold = unitsSold + orderFilled;
            avgPrice = avgPrice + (averageExecutionPrice * orderFilled);
        }

        // Avoid divide by 0 if no orders sold
        if (unitsSold == 0) {
            return (0, 0);
        }
        return (unitsSold, avgPrice / unitsSold);
    }

    /**
     * @notice Marks receipts as claimed and returns the refund amount
     * @param escrowId the id of the receipt created during the liquidation event
     * @param orders the orders that sell the liquidated positions
     * @param traderContract the address of the trader contract the selling orders were made by
     */
    function calcAmountToReturn(
        uint256 escrowId,
        Perpetuals.Order[] memory orders,
        address traderContract
    ) public override returns (uint256) {
        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];
        // Validate the escrowed order was fully sold
        (uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);
        require(unitsSold <= uint256(receipt.amountLiquidated.abs()), ""LIQ: Unit mismatch"");

        uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);
        return amountToReturn;
    }

    /**
     * @notice Drains a certain amount from insurance pool to cover excess slippage not covered by escrow
     * @param amountWantedFromInsurance How much we want to drain
     * @param receipt The liquidation receipt for which we are calling on the insurance pool to cover
     */
    function drainInsurancePoolOnLiquidation(
        uint256 amountWantedFromInsurance,
        LibLiquidation.LiquidationReceipt memory receipt
    ) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {
        /*
         * If there was not enough escrowed, we want to call the insurance pool to help out.
         * First, check the margin of the insurance Account. If this is enough, just drain from there.
         * If this is not enough, call Insurance.drainPool to get some tokens from the insurance pool.
         * If drainPool is able to drain enough, drain from the new margin.
         * If the margin still does not have enough after calling drainPool, we are not able to fully
         * claim the receipt, only up to the amount the insurance pool allows for.
         */

        Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);
        if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {
            // We don't need to drain insurance contract. The balance is already in the market contract
            _amountTakenFromInsurance = amountWantedFromInsurance;
        } else {
            // insuranceBalance.quote < amountWantedFromInsurance
            if (insuranceBalance.position.quote <= 0) {
                // attempt to drain entire balance that is needed from the pool
                IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);
            } else {
                // attempt to drain the required balance taking into account the insurance balance in the account contract
                IInsurance(insuranceContract).drainPool(
                    amountWantedFromInsurance - uint256(insuranceBalance.position.quote)
                );
            }
            Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);
            if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {
                // Still not enough
                _amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);
            } else {
                _amountTakenFromInsurance = amountWantedFromInsurance;
            }
        }

        _amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;
        // Don't add any to liquidatee
    }

    /**
     * @notice Allows a liquidator to submit a single liquidation receipt and multiple order ids. If the
     *         liquidator experienced slippage, will refund them a proportional amount of their deposit.
     * @param receiptId Used to identify the receipt that will be claimed
     * @param orders The orders that sold the liquidated position
     */
    function claimReceipt(
        uint256 receiptId,
        Perpetuals.Order[] memory orders,
        address traderContract
    ) external override {
        // Claim the receipts from the escrow system, get back amount to return
        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];
        require(receipt.liquidator == msg.sender, ""LIQ: Liquidator mismatch"");
        // Mark refund as claimed
        require(!receipt.liquidatorRefundClaimed, ""LIQ: Already claimed"");
        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;
        liquidationReceipts[receiptId].escrowClaimed = true;
        require(block.timestamp < receipt.releaseTime, ""LIQ: claim time passed"");
        require(tracer.tradingWhitelist(traderContract), ""LIQ: Trader is not whitelisted"");

        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);

        if (amountToReturn > receipt.escrowedAmount) {
            liquidationReceipts[receiptId].escrowedAmount = 0;
        } else {
            liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;
        }

        // Keep track of how much was actually taken out of insurance
        uint256 amountTakenFromInsurance;
        uint256 amountToGiveToClaimant;
        uint256 amountToGiveToLiquidatee;

        if (amountToReturn > receipt.escrowedAmount) {
            // Need to cover some loses with the insurance contract
            // Whatever is the remainder that can't be covered from escrow
            uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;
            (amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(
                amountWantedFromInsurance,
                receipt
            );
        } else {
            amountToGiveToClaimant = amountToReturn;
            amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;
        }

        tracer.updateAccountsOnClaim(
            receipt.liquidator,
            amountToGiveToClaimant.toInt256(),
            receipt.liquidatee,
            amountToGiveToLiquidatee.toInt256(),
            amountTakenFromInsurance.toInt256()
        );
        emit ClaimedReceipts(msg.sender, address(tracer), receiptId);
    }

    function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {
        super.transferOwnership(newOwner);
    }

    /**
     * @notice Modifies the release time
     * @param _releaseTime new release time
     */
    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {
        releaseTime = _releaseTime;
    }

    /**
     * @notice Modifies the value to multiply the liquidation cost by in determining
     *         the minimum leftover margin on partial liquidation
     * @param _minimumLeftoverGasCostMultiplier The new multiplier
     */
    function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {
        minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;
    }

    /**
     * @notice Modifies the max slippage
     * @param _maxSlippage new max slippage
     */
    function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {
        maxSlippage = _maxSlippage;
    }
}",4346,474,L-23: Using array memory parameter without checking its length. L274,1
70_VaderPoolV2.sol,"// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""./BasePoolV2.sol"";

import ""../../external/libraries/FixedPoint.sol"";

import ""../../interfaces/shared/IERC20Extended.sol"";
import ""../../interfaces/dex-v2/pool/IVaderPoolV2.sol"";
import ""../../interfaces/dex-v2/wrapper/ILPWrapper.sol"";
import ""../../interfaces/dex-v2/synth/ISynthFactory.sol"";

/*
 * @dev Implementation of {VaderPoolV2} contract.
 *
 * The contract VaderPool inherits from {BasePoolV2} contract and implements
 * queue system.
 *
 * Extends on the liquidity redeeming function by introducing the `burn` function
 * that internally calls the namesake on `BasePoolV2` contract and computes the
 * loss covered by the position being redeemed and returns it along with amounts
 * of native and foreign assets sent.
 **/
contract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {
    /* ========== LIBRARIES ========== */

    // Used for safe token transfers
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    // The LP wrapper contract
    ILPWrapper public wrapper;

    // The Synth Factory
    ISynthFactory public synthFactory;

    // Denotes whether the queue system is active
    bool public queueActive;

    /* ========== CONSTRUCTOR ========== */

    /*
     * @dev Initialised the contract state by passing the native asset's address
     * to the inherited {BasePoolV2} contract's constructor and setting queue status
     * to the {queueActive} state variable.
     **/
    constructor(bool _queueActive, IERC20 _nativeAsset)
        BasePoolV2(_nativeAsset)
    {
        queueActive = _queueActive;
    }

    /* ========== VIEWS ========== */

    /*
     * @dev Returns cumulative prices and the timestamp the were last updated
     * for both native and foreign assets against the pair specified by
     * parameter {foreignAsset}.
     **/
    function cumulativePrices(IERC20 foreignAsset)
        public
        view
        returns (
            uint256 price0CumulativeLast,
            uint256 price1CumulativeLast,
            uint32 blockTimestampLast
        )
    {
        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]
            .priceCumulative;
        price0CumulativeLast = priceCumulative.nativeLast;
        price1CumulativeLast = priceCumulative.foreignLast;
        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;

        if (blockTimestampLast < block.timestamp) {
            uint256 timeElapsed = block.timestamp - blockTimestampLast;
            unchecked {
                price0CumulativeLast +=
                    uint256(
                        FixedPoint
                            .fraction(
                                pairInfo[foreignAsset].reserveForeign,
                                pairInfo[foreignAsset].reserveNative
                            )
                            ._x
                    ) *
                    timeElapsed;
                price1CumulativeLast +=
                    uint256(
                        FixedPoint
                            .fraction(
                                pairInfo[foreignAsset].reserveNative,
                                pairInfo[foreignAsset].reserveForeign
                            )
                            ._x
                    ) *
                    timeElapsed;
            }
        }
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Initializes contract's state with LP wrapper, synth factory
     * and router addresses.
     *
     * Requirements:
     * - None of the parameters are zero addresses.
     * - The parameters are not already set.
     * - Only callable by contract owner.
     **/
    function initialize(
        ILPWrapper _wrapper,
        ISynthFactory _synthFactory,
        address _router
    ) external onlyOwner {
        require(
            wrapper == ILPWrapper(_ZERO_ADDRESS),
            ""VaderPoolV2::initialize: Already initialized""
        );
        require(
            _wrapper != ILPWrapper(_ZERO_ADDRESS),
            ""VaderPoolV2::initialize: Incorrect Wrapper Specified""
        );
        require(
            _synthFactory != ISynthFactory(_ZERO_ADDRESS),
            ""VaderPoolV2::initialize: Incorrect SynthFactory Specified""
        );
        require(
            _router != _ZERO_ADDRESS,
            ""VaderPoolV2::initialize: Incorrect Router Specified""
        );
        wrapper = _wrapper;
        synthFactory = _synthFactory;
        router = _router;
    }

    /*
     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based
     * on the native asset amount deposited and returns the minted synth asset amount.
     *
     * Creates the synthetic asset against {foreignAsset} if it does not already exist.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Requirements:
     * - {foreignAsset} must be a supported token.
     **/
    function mintSynth(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        address from,
        address to
    )
        external
        override
        nonReentrant
        supportedToken(foreignAsset)
        returns (uint256 amountSynth)
    {
        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);

        ISynth synth = synthFactory.synths(foreignAsset);

        if (synth == ISynth(_ZERO_ADDRESS))
            synth = synthFactory.createSynth(
                IERC20Extended(address(foreignAsset))
            );

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); 
        // gas savings

        amountSynth = VaderMath.calculateSwap(
            nativeDeposit,
            reserveNative,
            reserveForeign
        );

        // TODO: Clarify
        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign,
            reserveNative,
            reserveForeign
        );

        synth.mint(to, amountSynth);
    }

    /*
     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}
     * and returns the redeemed amount of native asset.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Requirements:
     * - {foreignAsset} must have a valid synthetic asset against it.
     * - {synthAmount} must be greater than zero.
     **/
    function burnSynth(
        IERC20 foreignAsset,
        uint256 synthAmount,
        address to
    ) external override nonReentrant returns (uint256 amountNative) {
        ISynth synth = synthFactory.synths(foreignAsset);

        require(
            synth != ISynth(_ZERO_ADDRESS),
            ""VaderPoolV2::burnSynth: Inexistent Synth""
        );

        require(
            synthAmount > 0,
            ""VaderPoolV2::burnSynth: Insufficient Synth Amount""
        );

        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);
        synth.burn(synthAmount);

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); 
        // gas savings

        amountNative = VaderMath.calculateSwap(
            synthAmount,
            reserveForeign,
            reserveNative
        );

        // TODO: Clarify
        _update(
            foreignAsset,
            reserveNative - amountNative,
            reserveForeign,
            reserveNative,
            reserveForeign
        );

        nativeAsset.safeTransfer(to, amountNative);
    }

    /*
     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.
     *
     * Deletes the position in {positions} mapping against the burned NFT token.
     *
     * Internally calls `_burn` function on {BasePoolV2} contract.
     *
     * Calculates the impermanent loss incurred by the position.
     *
     * Returns the amounts for native and foreign assets sent to the {to} address
     * along with the covered loss.
     *
     * Requirements:
     * - Can only be called by the Router.
     **/
    // NOTE: IL is only covered via router!
    // NOTE: Loss is in terms of USDV
    function burn(uint256 id, address to)
        external
        override
        onlyRouter
        returns (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        )
    {
        (amountNative, amountForeign) = _burn(id, to);

        Position storage position = positions[id];

        uint256 creation = position.creation;
        uint256 originalNative = position.originalNative;
        uint256 originalForeign = position.originalForeign;

        delete positions[id];

        uint256 loss = VaderMath.calculateLoss(
            originalNative,
            originalForeign,
            amountNative,
            amountForeign
        );

        // TODO: Original Implementation Applied 100 Days
        coveredLoss =
            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /
            _ONE_YEAR;
    }

    /*
     * @dev Allows minting of liquidity in fungible tokens. The fungible token
     * is a wrapped LP token against a particular pair. The liquidity issued is also
     * tracked within this contract along with liquidity issued against non-fungible
     * token.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Calls 'mint' on the LP wrapper token contract.
     *
     * Requirements:
     * - LP wrapper token must exist against {foreignAsset}.
     **/
    function mintFungible(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    ) external override nonReentrant returns (uint256 liquidity) {
        IERC20Extended lp = wrapper.tokens(foreignAsset);

        require(
            lp != IERC20Extended(_ZERO_ADDRESS),
            ""VaderPoolV2::mintFungible: Unsupported Token""
        );

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); 
        // gas savings

        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);
        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 totalLiquidityUnits = pair.totalSupply;
        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""VaderPoolV2::mintFungible: Insufficient Liquidity Provided""
        );

        pair.totalSupply = totalLiquidityUnits + liquidity;

        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign + foreignDeposit,
            reserveNative,
            reserveForeign
        );

        lp.mint(to, liquidity);

        emit Mint(from, to, nativeDeposit, foreignDeposit);
    }

    /*
     * @dev Allows burning of liquidity issued in fungible tokens.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Calls 'burn' on the LP wrapper token contract.
     *
     * Requirements:
     * - LP wrapper token must exist against {foreignAsset}.
     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,
     **/
    function burnFungible(
        IERC20 foreignAsset,
        uint256 liquidity,
        address to
    )
        external
        override
        nonReentrant
        returns (uint256 amountNative, uint256 amountForeign)
    {
        IERC20Extended lp = wrapper.tokens(foreignAsset);

        require(
            lp != IERC20Extended(_ZERO_ADDRESS),
            ""VaderPoolV2::burnFungible: Unsupported Token""
        );

        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);
        lp.burn(liquidity);

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); 
        // gas savings

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 _totalSupply = pair.totalSupply;
        amountNative = (liquidity * reserveNative) / _totalSupply;
        amountForeign = (liquidity * reserveForeign) / _totalSupply;

        require(
            amountNative > 0 && amountForeign > 0,
            ""VaderPoolV2::burnFungible: Insufficient Liquidity Burned""
        );

        pair.totalSupply = _totalSupply - liquidity;

        nativeAsset.safeTransfer(to, amountNative);
        foreignAsset.safeTransfer(to, amountForeign);

        _update(
            foreignAsset,
            reserveNative - amountNative,
            reserveForeign - amountForeign,
            reserveNative,
            reserveForeign
        );

        emit Burn(msg.sender, amountNative, amountForeign, to);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function setQueue(bool _queueActive) external override onlyOwner {
        require(
            _queueActive != queueActive,
            ""VaderPoolV2::setQueue: Already At Desired State""
        );
        queueActive = _queueActive;
        emit QueueActive(_queueActive);
    }

    /*
     * @dev Sets the supported state of the token represented by param {foreignAsset}.
     *
     * Requirements:
     * - The param {foreignAsset} is not already a supported token.
     **/
    function setTokenSupport(
        IERC20 foreignAsset,
        bool support,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    ) external override onlyOwner returns (uint256 liquidity) {
        require(
            supported[foreignAsset] != support,
            ""VaderPoolV2::supportToken: Already At Desired State""
        );
        supported[foreignAsset] = support;
        if (!support) {
            PairInfo storage pair = pairInfo[foreignAsset];
            require(
                pair.reserveNative == 0 && pair.reserveForeign == 0,
                ""VaderPoolV2::supportToken: Cannot Unsupport Token w/ Liquidity""
            );
        } else {
            require(
                nativeDeposit != 0 && foreignDeposit != 0,
                ""VaderPoolV2::supportToken: Improper First-Time Liquidity Provision""
            );
            liquidity = _mint(
                foreignAsset,
                nativeDeposit,
                foreignDeposit,
                from,
                to
            );
        }
    }

    /*
     * @dev Allows the gas throttle to be toggled on/off in case of emergency
     **/
    function setGasThrottle(bool _gasThrottleEnabled)
        external
        override
        onlyOwner
    {
        require(
            gasThrottleEnabled != _gasThrottleEnabled,
            ""VaderPoolV2::setGasThrottle: Already At Desired State""
        );
        gasThrottleEnabled = _gasThrottleEnabled;
    }

    /*
     * @dev Sets the supported state of the token represented by param {foreignAsset}.
     *
     * Requirements:
     * - The param {foreignAsset} is not already a supported token.
     **/
    function setFungibleTokenSupport(IERC20 foreignAsset)
        external
        override
        onlyOwner
    {
        wrapper.createWrapper(foreignAsset);
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /**
     * @dev Calculates the minimum of the two values
     */
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
}",3319,520,"H-02: VaderPoolV2 owner can steal all user assets which are approved VaderPoolV2.  L442 H-06: LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.  L265 H-07: Redemption value of synths can be manipulated to drain VaderPoolV2 of all native assets in the associated pair. L153 H-12: Using single total native reserve variable for synth and non-synth reserves of VaderPoolV2 can lead to losses for synth holders H-14: Denial of service. L334 M-01: VaderPoolV2.mintFungible exposes users to unlimited slippage",6
26_RCOrderbook.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";

/// @title Reality Cards Orderbook
/// @author Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {

    /// @dev a record of a users single bid.
    /// @dev now declared in the interface, left here for reference
    // struct Bid {
    //     address market;
    //     address next;
    //     address prev;
    //     uint64 card;
    //     uint128 price;
    //     uint64 timeHeldLimit;
    // }

    /// @dev maps a user address to an array of their bids
    mapping(address => Bid[]) public user;
    /// @dev index of a bid record in the user array, User|Market|Token->Index
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    /// @dev record of market specific variables
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    /// @dev map a market address to a market record
    mapping(address => Market) public market;
    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    /// @dev an array of closed markets, used to reduce user bid rates
    address[] public override closedMarkets;
    /// @dev how far through the array a given user is, saves iterating the whole array every time.
    mapping(address => uint256) public override userClosedMarketIndex;

    ///// GOVERNANCE VARIABLES /////
    /// @dev the current treasury
    IRCTreasury public override treasury;
    /// @dev max number of searches to place an order in the book
    /// @dev current estimates place limit around 2000 but 1000 is sufficient
    uint256 public override maxSearchIterations = 1000;
    /// @dev max number of records to delete in one transaction
    uint256 public override maxDeletions = 70;
    /// @dev number of bids a user should clean when placing a new bid
    uint256 public override cleaningLoops = 2;
    /// @dev max number of market records to put into the waste pile in one go
    uint256 public override marketCloseLimit = 70;
    /// @dev nonce emitted with orderbook insertions, for frontend sorting
    uint256 public override nonce;


    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");


    /// @notice only allow markets to call certain functions
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    /// @dev emitted every time an order is added to the orderbook
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    /// @dev emitted when an order is removed from the orderbook
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );


    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }


    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }


    /// @notice adds a new market to the orderbook
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            // create new record for each card that becomes the head&tail of the linked list
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    /// @notice adds or updates a bid in the orderbook
    /// @param _user the user placing the bid
    /// @param _card the card to place the bid on
    /// @param _price the price of the new bid
    /// @param _timeHeldLimit an optional time limit for the bid
    /// @param _prevUserAddress to help find where to insert the bid
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        // each new bid can help clean up some junk
        cleanWastePile();

        if (user[_user].length == 0) {
            //users first bid, skip already closed markets
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            // old bid exists, update it
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            // new bid, add it
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    /// @dev finds the correct location in the orderbook for a given bid
    /// @dev returns an adjusted (lowered) bid price if necessary.
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            // break loop if match price above AND above price below (so if either is false, continue, hence OR )
            // if match previous then must be greater than next to continue
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            // break loop if price x% above below
            _price < _requiredPrice &&
            // break loop if hits max iterations
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        // if previous price is zero it must be the market and this is a new owner
        // .. then don't reduce their price, we already checked they are 10% higher
        // .. than the previous owner.
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    /// @dev add a new bid to the orderbook
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // create new record
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // insert in linked list
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link
        user[_user].push(_newBid);

        // update the index to help find the record later
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    /// @dev updates a bid that is already in the orderbook
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        // TODO no need to unlink and relink if bid doesn't change position in orderbook
        // unlink current bid
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        // find new position
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // update price, save old price for rental rate adjustment later
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // relink bid
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            // if owner before and after, update the price difference
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            // if owner before and not after, remove the old price
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            // if not owner before but is owner after, add new price
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    /*╔══════════════════════════════════════════╗
      ║                DELETIONS                 ║      
      ║ functions that remove from the orderbook ║
      ╚══════════════════════════════════════════╝*/

    /// @notice removes a single bid from the orderbook - onlyMarkets
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    /// @dev removes a single bid from the orderbook, doesn't update ownership
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        // extract from linked list
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        // return next users price to check they're eligible later
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        // update rate
        treasury.decreaseBidRate(_user, _currUser.price);

        // overwrite array element
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        // no point overwriting itself
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        // update the index to help find the record later
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    /// @notice find the next valid owner of a given card - onlyMarkets
    /// @param _card the card to remove
    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        // the market is the head of the list, the next bid is therefore the owner
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        // delete current owner
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            // delete next bid if foreclosed
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            // the old owner is dead, long live the new owner
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            // we hit the limit, save the old owner, we'll try again next time
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards
    /// @notice .. as the markets will need to finish the accounting for them first.
    /// @param _user the user whose bids to start deleting
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                // If the prev record isn't the market, this is only a bid (not owned) so we can delete
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    /// @notice reduces the rentalRates of the card owners when a market closes
    /// @dev too many bidders to reduce all bid rates also
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        // check if the market was ever added to the orderbook
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; // start on the last record so we can easily pop()
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    // store last bid for later
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    // detach market from rest of list
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    // insert bids in the waste pile
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    // reduce owners rental rate
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                // remove the market record
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    /// @notice Remove bids in closed markets for a given user
    /// @notice this can reduce the users bidRate and chance to foreclose
    /// @param _user the address of the users bids to remove
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                // Just do the whole market at once
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        // reduce bidRate
                        uint256 _price = user[_user][_index].price;

                        // preserve linked list
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        // no point overwriting itself
                        if (_index != _lastRecord) {
                            // overwrite array element
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        // update the index to help find the record later
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        // count deletions
                        _loopCounter++;
                    } else {
                        // iterations cost gas also
                        // after enough increment the loopCounter
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    /// @dev remove bids in closed markets, not user specific
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                // extract from linked list
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                // overwrite array element
                uint256 _lastRecord = user[_user].length - 1;
                // no point overwriting itself
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                // update the index to help find the record later
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }


    /// @notice check if a bid exists
    /// @param _user the address of the user
    /// @param _market the address of the market
    /// @param _card the card index
    /// @return if the bid exists or not
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            //some bids exist
            if (index[_user][_market][_card] != 0) {
                // this bid exists
                return true;
            } else {
                // check bid isn't index 0
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    /// @dev just to pass old tests, not needed otherwise
    /// @dev but also useful to have so probably will stay
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
}",7359,903,"H-01: findNewOwner edgecase. L549 L-04: Return Value is Not Validated.",2
3_IncentiveDistribution.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./RoleAware.sol"";
import ""./Fund.sol"";

struct Claim {
    uint256 startingRewardRateFP;
    uint256 amount;
    uint256 intraDayGain;
    uint256 intraDayLoss;
}

/// @title Manage distribution of liquidity stake incentives
/// Some efforts have been made to reduce gas cost at claim time
/// and shift gas burden onto those who would want to withdraw
contract IncentiveDistribution is RoleAware, Ownable {
    // fixed point number factor
    uint256 internal constant FP32 = 2**32;
    // the amount of contraction per thousand, per day
    // of the overal daily incentive distribution
    // https://en.wikipedia.org/wiki/Per_mil
    uint256 public constant contractionPerMil = 999;
    address public immutable MFI;

    constructor(
        address _MFI,
        uint256 startingDailyDistributionWithoutDecimals,
        address _roles
    ) RoleAware(_roles) Ownable() {
        MFI = _MFI;
        currentDailyDistribution =
            startingDailyDistributionWithoutDecimals *
            (1 ether);
    }

    // how much is going to be distributed, contracts every day
    uint256 public currentDailyDistribution;

    uint256 public trancheShareTotal;
    uint256[] public allTranches;

    struct TrancheMeta {
        // portion of daily distribution per each tranche
        uint256 rewardShare;

        uint256 currentDayGains;
        uint256 currentDayLosses;

        uint256 tomorrowOngoingTotals;
        uint256 yesterdayOngoingTotals;

        // aggregate all the unclaimed intra-days
        uint256 intraDayGains;
        uint256 intraDayLosses;
        uint256 intraDayRewardGains;
        uint256 intraDayRewardLosses;


        // how much each claim unit would get if they had staked from the dawn of time
        // expressed as fixed point number
        // claim amounts are expressed relative to this ongoing aggregate
        uint256 aggregateDailyRewardRateFP;
        uint256 yesterdayRewardRateFP;

        mapping(address => Claim) claims;
    }

    mapping(uint256 => TrancheMeta) public trancheMetadata;

    // last updated day
    uint256 public lastUpdatedDay;

    mapping(address => uint256) public accruedReward;

    /// Set share of tranche
    function setTrancheShare(uint256 tranche, uint256 share)
        external
        onlyOwner
    {
        require(
            trancheMetadata[tranche].rewardShare > 0,
            ""Tranche is not initialized, please initialize first""
        );
        _setTrancheShare(tranche, share);
    }

    function _setTrancheShare(uint256 tranche, uint256 share) internal {
        TrancheMeta storage tm = trancheMetadata[tranche];

        if (share > tm.rewardShare) {
            trancheShareTotal += share - tm.rewardShare;
        } else {
            trancheShareTotal -= tm.rewardShare - share;
        }
        tm.rewardShare = share;
    }

    /// Initialize tranche
    function initTranche(uint256 tranche, uint256 share) external onlyOwner {
        TrancheMeta storage tm = trancheMetadata[tranche];
        require(tm.rewardShare == 0, ""Tranche already initialized"");
        _setTrancheShare(tranche, share);

        // simply initialize to 1.0
        tm.aggregateDailyRewardRateFP = FP32;
        allTranches.push(tranche);
    }

    /// Start / increase amount of claim
    function addToClaimAmount(
        uint256 tranche,
        address recipient,
        uint256 claimAmount
    ) external {
        require(
            isIncentiveReporter(msg.sender),
            ""Contract not authorized to report incentives""
        );
        if (currentDailyDistribution > 0) {
            TrancheMeta storage tm = trancheMetadata[tranche];
            Claim storage claim = tm.claims[recipient];

            uint256 currentDay =
                claimAmount * (1 days - (block.timestamp % (1 days)));

            tm.currentDayGains += currentDay;
            claim.intraDayGain += currentDay * currentDailyDistribution;

            tm.tomorrowOngoingTotals += claimAmount * 1 days;
            updateAccruedReward(tm, recipient, claim);

            claim.amount += claimAmount * (1 days);
        }
    }

    /// Decrease amount of claim
    function subtractFromClaimAmount(
        uint256 tranche,
        address recipient,
        uint256 subtractAmount
    ) external {
        require(
            isIncentiveReporter(msg.sender),
            ""Contract not authorized to report incentives""
        );
        uint256 currentDay = subtractAmount * (block.timestamp % (1 days));

        TrancheMeta storage tm = trancheMetadata[tranche];
        Claim storage claim = tm.claims[recipient];

        tm.currentDayLosses += currentDay;
        claim.intraDayLoss += currentDay * currentDailyDistribution;

        tm.tomorrowOngoingTotals -= subtractAmount * 1 days;

        updateAccruedReward(tm, recipient, claim);
        claim.amount -= subtractAmount * (1 days);
    }

    function updateAccruedReward(
        TrancheMeta storage tm,
        address recipient,
        Claim storage claim
                                 ) internal returns (uint256 rewardDelta){
        if (claim.startingRewardRateFP > 0) {
            rewardDelta = calcRewardAmount(tm, claim);
            accruedReward[recipient] += rewardDelta;
        }
        // don't reward for current day (approximately)
        claim.startingRewardRateFP =
            tm.yesterdayRewardRateFP +
            tm.aggregateDailyRewardRateFP;
    }

    /// @dev additional reward accrued since last update
    function calcRewardAmount(TrancheMeta storage tm, Claim storage claim)
        internal
        view
        returns (uint256 rewardAmount)
    {
        uint256 ours = claim.startingRewardRateFP;
        uint256 aggregate = tm.aggregateDailyRewardRateFP;
        if (aggregate > ours) {
            rewardAmount = (claim.amount * (aggregate - ours)) / FP32;
        }
    }

    function applyIntraDay(
                           TrancheMeta storage tm,
        Claim storage claim
                           ) internal view returns (uint256 gainImpact, uint256 lossImpact) {
        uint256 gain = claim.intraDayGain;
        uint256 loss = claim.intraDayLoss;

        if (gain + loss > 0) {
            gainImpact =
                (gain * tm.intraDayRewardGains) /
                    (tm.intraDayGains + 1);
            lossImpact =
                (loss * tm.intraDayRewardLosses) /
                    (tm.intraDayLosses + 1);
        }
    }

    /// Get a view of reward amount
    function viewRewardAmount(uint256 tranche, address claimant)
        external
        view
        returns (uint256)
    {
        TrancheMeta storage tm = trancheMetadata[tranche];
        Claim storage claim = tm.claims[claimant];

        uint256 rewardAmount =
            accruedReward[claimant] + calcRewardAmount(tm, claim);
        (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(tm, claim);

        return rewardAmount + gainImpact - lossImpact;
    }

    /// Withdraw current reward amount
    function withdrawReward(uint256[] calldata tranches)
        external
        returns (uint256 withdrawAmount)
    {
        require(
            isIncentiveReporter(msg.sender),
            ""Contract not authorized to report incentives""
        );

        updateDayTotals();

        withdrawAmount = accruedReward[msg.sender];
        for (uint256 i; tranches.length > i; i++) {
            uint256 tranche = tranches[i];

            TrancheMeta storage tm = trancheMetadata[tranche];
            Claim storage claim = tm.claims[msg.sender];

            withdrawAmount += updateAccruedReward(tm, msg.sender, claim);

            (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(
                                                                     tm,
                claim
            );

            withdrawAmount = withdrawAmount + gainImpact - lossImpact;

            tm.intraDayGains -= claim.intraDayGain;
            tm.intraDayLosses -= claim.intraDayLoss;
            tm.intraDayRewardGains -= gainImpact;
            tm.intraDayRewardLosses -= lossImpact;
            
            claim.intraDayGain = 0;
        }

        accruedReward[msg.sender] = 0;

        Fund(fund()).withdraw(MFI, msg.sender, withdrawAmount);
    }

    function updateDayTotals() internal {
        uint256 nowDay = block.timestamp / (1 days);
        uint256 dayDiff = nowDay - lastUpdatedDay;

        // shrink the daily distribution for every day that has passed
        for (uint256 i = 0; i < dayDiff; i++) {
            _updateTrancheTotals();

            currentDailyDistribution =
                (currentDailyDistribution * contractionPerMil) /
                1000;

            lastUpdatedDay += 1;
        }
    }

    function _updateTrancheTotals() internal {
        for (uint256 i; allTranches.length > i; i++) {
            uint256 tranche = allTranches[i];
            TrancheMeta storage tm = trancheMetadata[tranche];

            uint256 todayTotal =
                tm.yesterdayOngoingTotals +
                    tm.currentDayGains -
                tm.currentDayLosses;

            uint256 todayRewardRateFP =
                (FP32 * (currentDailyDistribution * tm.rewardShare)) /
                    trancheShareTotal /
                    todayTotal;

            tm.yesterdayRewardRateFP = todayRewardRateFP;

            tm.aggregateDailyRewardRateFP += todayRewardRateFP;

            tm.intraDayGains +=
                tm.currentDayGains *
                currentDailyDistribution;

            tm.intraDayLosses +=
                tm.currentDayLosses *
                currentDailyDistribution;

            tm.intraDayRewardGains +=
                (tm.currentDayGains * todayRewardRateFP) /
                FP32;

            tm.intraDayRewardLosses +=
                (tm.currentDayLosses * todayRewardRateFP) /
                FP32;

            tm.yesterdayOngoingTotals = tm.tomorrowOngoingTotals;
            tm.currentDayGains = 0;
            tm.currentDayLosses = 0;
        }
    }
}",2215,321,"H-08: Rewards cannot be withdrawn The rewards for a recipient in IncentiveDistribution.sol are stored in the storage mapping indexed by recipient accruedReward[recipient] and the recipient is the actual margin trader account, see updateAccruedReward. H-09: lastUpdatedDay not initialized H-11: Impossible to call withdrawReward fails due to run out of gas",3
16_TracerPerpetualSwaps.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./lib/SafetyWithdraw.sol"";
import ""./lib/LibMath.sol"";
import {Balances} from ""./lib/LibBalances.sol"";
import {Types} from ""./Interfaces/Types.sol"";
import ""./lib/LibPrices.sol"";
import ""./lib/LibPerpetuals.sol"";
import ""./Interfaces/IOracle.sol"";
import ""./Interfaces/IInsurance.sol"";
import ""./Interfaces/ITracerPerpetualSwaps.sol"";
import ""./Interfaces/IPricing.sol"";
import ""./Interfaces/ITrader.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""prb-math/contracts/PRBMathSD59x18.sol"";
import ""prb-math/contracts/PRBMathUD60x18.sol"";

contract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {
    using LibMath for uint256;
    using LibMath for int256;
    using PRBMathSD59x18 for int256;
    using PRBMathUD60x18 for uint256;

    uint256 public constant override LIQUIDATION_GAS_COST = 63516;
    address public immutable override tracerQuoteToken;
    uint256 public immutable override quoteTokenDecimals;
    bytes32 public immutable override marketId;
    IPricing public pricingContract;
    IInsurance public insuranceContract;
    address public override liquidationContract;
    uint256 public override feeRate;
    uint256 public override fees;
    address public override feeReceiver;

    /* Config variables */
    // The price of gas in gwei
    address public override gasPriceOracle;
    // The maximum ratio of notionalValue to margin
    uint256 public override maxLeverage;
    // WAD value. sensitivity of 1 = 1*10^18
    uint256 public override fundingRateSensitivity;
    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins
    uint256 public override deleveragingCliff;
    /* The percentage of insurance holdings to target at which the insurance pool
       funding rate changes, and lowestMaxLeverage is reached */
    uint256 public override insurancePoolSwitchStage;
    // The lowest value that maxLeverage can be, if insurance pool is empty.
    uint256 public override lowestMaxLeverage;

    // Account State Variables
    mapping(address => Balances.Account) public balances;
    uint256 public tvl;
    uint256 public override leveragedNotionalValue;

    // Trading interfaces whitelist
    mapping(address => bool) public override tradingWhitelist;

    event FeeReceiverUpdated(address indexed receiver);
    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);
    event Deposit(address indexed user, uint256 indexed amount);
    event Withdraw(address indexed user, uint256 indexed amount);
    event Settled(address indexed account, int256 margin);
    event MatchedOrders(
        address indexed long,
        address indexed short,
        uint256 amount,
        uint256 price,
        bytes32 longOrderId,
        bytes32 shortOrderId
    );
    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);

    /**
     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone
     *         will be able to purchase and trade tracers after this deployment.
     * @param _marketId the id of the market, given as BASE/QUOTE
     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)
     * @param _tokenDecimals the number of decimal places the quote token supports
     * @param _gasPriceOracle the address of the contract implementing gas price oracle
     * @param _maxLeverage the max leverage of the market represented as a WAD value.
     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)
     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16
     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market
     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.
     *                           WAD value. e.g. 20% = 20*10^18
     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.
     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool
     *                                  funding rate changes, and lowestMaxLeverage is reached
     */
    constructor(
        bytes32 _marketId,
        address _tracerQuoteToken,
        uint256 _tokenDecimals,
        address _gasPriceOracle,
        uint256 _maxLeverage,
        uint256 _fundingRateSensitivity,
        uint256 _feeRate,
        address _feeReceiver,
        uint256 _deleveragingCliff,
        uint256 _lowestMaxLeverage,
        uint256 _insurancePoolSwitchStage
    ) Ownable() {
        // don't convert to interface as we don't need to interact with the contract
        tracerQuoteToken = _tracerQuoteToken;
        quoteTokenDecimals = _tokenDecimals;
        gasPriceOracle = _gasPriceOracle;
        marketId = _marketId;
        feeRate = _feeRate;
        maxLeverage = _maxLeverage;
        fundingRateSensitivity = _fundingRateSensitivity;
        feeReceiver = _feeReceiver;
        deleveragingCliff = _deleveragingCliff;
        lowestMaxLeverage = _lowestMaxLeverage;
        insurancePoolSwitchStage = _insurancePoolSwitchStage;
    }

    /**
     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target
     */
    function trueMaxLeverage() public view override returns (uint256) {
        IInsurance insurance = IInsurance(insuranceContract);

        return
            Perpetuals.calculateTrueMaxLeverage(
                insurance.getPoolHoldings(),
                insurance.getPoolTarget(),
                maxLeverage,
                lowestMaxLeverage,
                deleveragingCliff,
                insurancePoolSwitchStage
            );
    }

    /**
     * @notice Allows a user to deposit into their margin account
     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.
     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount
     * should be given in WAD format.
     */
    function deposit(uint256 amount) external override {
        Balances.Account storage userBalance = balances[msg.sender];
        // settle outstanding payments
        settle(msg.sender);

        // convert the WAD amount to the correct token amount to transfer
        // cast is safe since amount is a uint, and wadToToken can only
        // scale down the value
        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());
        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);

        // this prevents dust from being added to the user account
        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits
        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);

        // update user state
        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;
        _updateAccountLeverage(msg.sender);

        // update market TVL
        tvl = tvl + uint256(convertedWadAmount);
        emit Deposit(msg.sender, amount);
    }

    /**
     * @notice Allows a user to withdraw from their margin account
     * @dev Ensures that the users margin percent is valid after withdraw
     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount
     * should be given in WAD format
     */
    function withdraw(uint256 amount) external override {
        // settle outstanding payments
        settle(msg.sender);

        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);
        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);

        Balances.Account storage userBalance = balances[msg.sender];
        int256 newQuote = userBalance.position.quote - convertedWadAmount;

        // this may be able to be optimised
        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);

        require(
            Balances.marginIsValid(
                newPosition,
                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,
                pricingContract.fairPrice(),
                trueMaxLeverage()
            ),
            ""TCR: Withdraw below valid Margin""
        );

        // update user state
        userBalance.position.quote = newQuote;
        _updateAccountLeverage(msg.sender);

        // Safemath will throw if tvl < amount
        tvl = tvl - amount;

        // perform transfer
        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);
        emit Withdraw(msg.sender, uint256(convertedWadAmount));
    }

    /**
     * @notice Attempt to match two orders that exist on-chain against each other
     * @dev Emits a FailedOrders or MatchedOrders event based on whether the
     *      orders were successfully able to be matched
     * @param order1 The first order
     * @param order2 The second order
     * @param fillAmount Amount that the two orders are being filled for
     * @return Whether the two orders were able to be matched successfully
     */
    function matchOrders(
        Perpetuals.Order memory order1,
        Perpetuals.Order memory order2,
        uint256 fillAmount
    ) external override onlyWhitelisted returns (bool) {
        bytes32 order1Id = Perpetuals.orderId(order1);
        bytes32 order2Id = Perpetuals.orderId(order2);
        uint256 filled1 = ITrader(msg.sender).filled(order1Id);
        uint256 filled2 = ITrader(msg.sender).filled(order2Id);

        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);

        // settle accounts
        // note: this can revert and hence no order events will be emitted
        settle(order1.maker);
        settle(order2.maker);

        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(
            order1,
            order2,
            fillAmount,
            executionPrice
        );
        // validate orders can match, and outcome state is valid
        if (
            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||
            !Balances.marginIsValid(
                newPos1,
                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,
                pricingContract.fairPrice(),
                trueMaxLeverage()
            ) ||
            !Balances.marginIsValid(
                newPos2,
                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,
                pricingContract.fairPrice(),
                trueMaxLeverage()
            )
        ) {
            // emit failed to match event and return false
            if (order1.side == Perpetuals.Side.Long) {
                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);
            } else {
                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);
            }
            return false;
        }

        // update account states
        balances[order1.maker].position = newPos1;
        balances[order2.maker].position = newPos2;

        // update fees
        fees =
            fees +
            // add 2 * fees since getFeeRate returns the fee rate for a single
            // side of the order. Both users were charged fees
            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);

        // update leverage
        _updateAccountLeverage(order1.maker);
        _updateAccountLeverage(order2.maker);

        // Update internal trade state
        pricingContract.recordTrade(executionPrice);

        if (order1.side == Perpetuals.Side.Long) {
            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);
        } else {
            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);
        }
        return true;
    }

    /**
     * @notice Updates account states of two accounts given two orders that are being executed
     * @param order1 The first order
     * @param order2 The second order
     * @param fillAmount The amount that the two ordered are being filled for
     * @param executionPrice The execution price of the trades
     * @return The new balances of the two accounts after the trade
     */
    function _executeTrade(
        Perpetuals.Order memory order1,
        Perpetuals.Order memory order2,
        uint256 fillAmount,
        uint256 executionPrice
    ) internal view returns (Balances.Position memory, Balances.Position memory) {
        // Retrieve account state
        Balances.Account memory account1 = balances[order1.maker];
        Balances.Account memory account2 = balances[order2.maker];

        // Construct `Trade` types suitable for use with LibBalances
        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (
            Balances.Trade(executionPrice, fillAmount, order1.side),
            Balances.Trade(executionPrice, fillAmount, order2.side)
        );

        // Calculate new account state
        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (
            Balances.applyTrade(account1.position, trade1, feeRate),
            Balances.applyTrade(account2.position, trade2, feeRate)
        );

        // return new account state
        return (newPos1, newPos2);
    }

    /**
     * @notice internal function for updating leverage. Called within the Account contract. Also
     *         updates the total leveraged notional value for the tracer market itself.
     */
    function _updateAccountLeverage(address account) internal {
        Balances.Account memory userBalance = balances[account];
        uint256 originalLeverage = userBalance.totalLeveragedValue;
        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());
        balances[account].totalLeveragedValue = newLeverage;

        // Update market leveraged notional value
        _updateTracerLeverage(newLeverage, originalLeverage);
    }

    /**
     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value
     * @param accountNewLeveragedNotional The future notional value of the account
     * @param accountOldLeveragedNotional The stored notional value of the account
     */
    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {
        leveragedNotionalValue = Prices.globalLeverage(
            leveragedNotionalValue,
            accountOldLeveragedNotional,
            accountNewLeveragedNotional
        );
    }

    /**
     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update
     *         account states as necessary.
     * @param liquidator Address of the account that called liquidate(...)
     * @param liquidatee Address of the under-margined account getting liquidated
     * @param liquidatorQuoteChange Amount the liquidator's quote is changing
     * @param liquidatorBaseChange Amount the liquidator's base is changing
     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing
     * @param liquidateeBaseChange Amount the liquidated account's base is changing
     * @param amountToEscrow The amount the liquidator has to put into escrow
     */
    function updateAccountsOnLiquidation(
        address liquidator,
        address liquidatee,
        int256 liquidatorQuoteChange,
        int256 liquidatorBaseChange,
        int256 liquidateeQuoteChange,
        int256 liquidateeBaseChange,
        uint256 amountToEscrow
    ) external override onlyLiquidation {
        // Limits the gas use when liquidating
        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();
        // Update liquidators last updated gas price
        Balances.Account storage liquidatorBalance = balances[liquidator];
        Balances.Account storage liquidateeBalance = balances[liquidatee];

        // update liquidators balance
        liquidatorBalance.lastUpdatedGasPrice = gasPrice;
        liquidatorBalance.position.quote =
            liquidatorBalance.position.quote +
            liquidatorQuoteChange -
            amountToEscrow.toInt256();
        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;

        // update liquidatee balance
        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;
        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;

        // Checks if the liquidator is in a valid position to process the liquidation
        require(userMarginIsValid(liquidator), ""TCR: Liquidator under min margin"");
    }

    /**
     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),
               Liquidation.sol needs to tell the market to update its balance and the balance of the
               liquidated agent.
     * @dev Gives the leftover amount from the receipt to the liquidated agent
     * @param claimant The liquidator, who has experienced slippage selling the liquidated position
     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage
     * @param liquidatee The account that originally got liquidated
     * @param amountToGiveToLiquidatee Amount owed to the liquidated account
     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool
                                        in order to cover liquidation
     */
    function updateAccountsOnClaim(
        address claimant,
        int256 amountToGiveToClaimant,
        address liquidatee,
        int256 amountToGiveToLiquidatee,
        int256 amountToTakeFromInsurance
    ) external override onlyLiquidation {
        address insuranceAddr = address(insuranceContract);
        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;
        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;
        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;
        require(balances[insuranceAddr].position.quote >= 0, ""TCR: Insurance not funded enough"");
    }

    /**
     * @notice settles an account. Compares current global rate with the users last updated rate
     *         Updates the accounts margin balance accordingly.
     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin
     *      and the account must then be liquidated.
     * @param account the address to settle.
     * @dev This function aggregates data to feed into account.sols settle function which sets
     */
    function settle(address account) public override {
        // Get account and global last updated indexes
        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;
        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();
        Balances.Account storage accountBalance = balances[account];

        // if this user has no positions, bring them in sync
        if (accountBalance.position.base == 0) {
            // set to the last fully established index
            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;
            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();
        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {
            // Only settle account if its last updated index was before the last established
            // global index this is since we reference the last global index
            // Get current and global funding statuses
            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;
            // Note: global rates reference the last fully established rate (hence the -1), and not
            // the current global rate. User rates reference the last saved user rate
            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);
            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);

            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(
                lastEstablishedIndex
            );

            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(
                accountLastUpdatedIndex
            );

            // settle the account
            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];

            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);

            // Update account gas price
            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();

            if (accountBalance.totalLeveragedValue > 0) {
                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(
                    accountBalance.position,
                    insuranceBalance.position,
                    currInsuranceGlobalRate,
                    currInsuranceUserRate,
                    accountBalance.totalLeveragedValue
                );

                balances[account].position = newUserPos;
                balances[(address(insuranceContract))].position = newInsurancePos;
            }

            // Update account index
            accountBalance.lastUpdatedIndex = lastEstablishedIndex;
            require(userMarginIsValid(account), ""TCR: Target under-margined"");
            emit Settled(account, accountBalance.position.quote);
        }
    }

    /**
     * @notice Checks if a given accounts margin is valid
     * @param account The address of the account whose margin is to be checked
     * @return true if the margin is valid or false otherwise
     */
    function userMarginIsValid(address account) public view returns (bool) {
        Balances.Account memory accountBalance = balances[account];
        return
            Balances.marginIsValid(
                accountBalance.position,
                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,
                pricingContract.fairPrice(),
                trueMaxLeverage()
            );
    }

    /**
     * @notice Withdraws the fees taken on trades, and sends them to the designated
     *         fee receiver (set by the owner of the market)
     * @dev Anyone can call this function, but fees are transferred to the fee receiver.
     *      Fees is also subtracted from the total value locked in the market because
     *      fees are taken out of trades that result in users' quotes being modified, and
     *      don't otherwise get subtracted from the tvl of the market
     */
    function withdrawFees() external override {
        uint256 tempFees = fees;
        fees = 0;
        tvl = tvl - tempFees;

        // Withdraw from the account
        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);
        emit FeeWithdrawn(feeReceiver, tempFees);
    }

    function getBalance(address account) external view override returns (Balances.Account memory) {
        return balances[account];
    }

    function setLiquidationContract(address _liquidationContract) external override onlyOwner {
        require(_liquidationContract != address(0), ""address(0) given"");
        liquidationContract = _liquidationContract;
    }

    function setInsuranceContract(address insurance) external override onlyOwner {
        require(insurance != address(0), ""address(0) given"");
        insuranceContract = IInsurance(insurance);
    }

    function setPricingContract(address pricing) external override onlyOwner {
        require(pricing != address(0), ""address(0) given"");
        pricingContract = IPricing(pricing);
    }

    function setGasOracle(address _gasOracle) external override onlyOwner {
        require(_gasOracle != address(0), ""address(0) given"");
        gasPriceOracle = _gasOracle;
    }

    function setFeeReceiver(address _feeReceiver) external override onlyOwner {
        require(_feeReceiver != address(0), ""address(0) given"");
        feeReceiver = _feeReceiver;
        emit FeeReceiverUpdated(_feeReceiver);
    }

    function setFeeRate(uint256 _feeRate) external override onlyOwner {
        feeRate = _feeRate;
    }

    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {
        maxLeverage = _maxLeverage;
    }

    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {
        fundingRateSensitivity = _fundingRateSensitivity;
    }

    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {
        deleveragingCliff = _deleveragingCliff;
    }

    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {
        lowestMaxLeverage = _lowestMaxLeverage;
    }

    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {
        insurancePoolSwitchStage = _insurancePoolSwitchStage;
    }

    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {
        require(newOwner != address(0), ""address(0) given"");
        super.transferOwnership(newOwner);
    }

    /**
     * @notice allows the owner of a market to set the whitelisting of a trading interface address
     * @dev a permissioned interface may call the matchOrders function.
     * @param tradingContract the contract to have its whitelisting permissions set
     * @param whitelisted the permission of the contract. If true this contract make call makeOrder
     */
    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {
        tradingWhitelist[tradingContract] = whitelisted;
    }

    // Modifier such that only the set liquidation contract can call a function
    modifier onlyLiquidation() {
        require(msg.sender == liquidationContract, ""TCR: Sender not liquidation"");
        _;
    }

    // Modifier such that only a whitelisted trader can call a function
    modifier onlyWhitelisted() {
        require(tradingWhitelist[msg.sender], ""TCR: Contract not whitelisted"");
        _;
    }
}",5870,599,"H-04: Logic error in fee subtraction. L272 M-02:No check transferFrom() return value M-03: Deflationary tokens are not supported M-08: Missing events for critical parameter changing operations by owner M-09: Wrong funding index in settle when no base?",5
24_SwappableYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",3524,330,"H-01: onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source. L307 H-02: redeemToken can fail for certain tokens H-04: SwappableYieldSource: Missing same deposit token check in transferFunds() M-01: Single-step process for critical ownership transfer/renounce is risky M-03: Inconsistent balance when supplying transfer-on-fee or deflationary tokens. L211",5
68_BasketFacet.sol,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../../interfaces/IBasketFacet.sol"";
import ""../ERC20/LibERC20Storage.sol"";
import ""../ERC20/LibERC20.sol"";
import ""../shared/Reentry/ReentryProtection.sol"";
import ""../shared/Access/CallProtection.sol"";
import ""./LibBasketStorage.sol"";

contract BasketFacet is ReentryProtection, CallProtection, IBasketFacet {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MIN_AMOUNT = 10**6;
    uint256 public constant MAX_ENTRY_FEE = 10**17; 
    // 10%
    uint256 public constant MAX_EXIT_FEE = 10**17; 
    // 10%
    uint256 public constant MAX_ANNUAL_FEE = 10**17; 
    // 10%
    uint256 public constant HUNDRED_PERCENT = 10**18;

    // Assuming a block gas limit of 12M this allows for a gas consumption per token of roughly 333k allowing 2M of overhead for addtional operations
    uint256 public constant MAX_TOKENS = 30;

    function addToken(address _token) external override protectedCall {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        require(!bs.inPool[_token], ""TOKEN_ALREADY_IN_POOL"");
        require(bs.tokens.length < MAX_TOKENS, ""TOKEN_LIMIT_REACHED"");
        // Enforce minimum to avoid rounding errors; (Minimum value is the same as in Balancer)
        require(balance(_token) >= MIN_AMOUNT, ""BALANCE_TOO_SMALL"");

        bs.inPool[_token] = true;
        bs.tokens.push(IERC20(_token));

        emit TokenAdded(_token);
    }

    function removeToken(address _token) external override protectedCall {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();

        require(bs.inPool[_token], ""TOKEN_NOT_IN_POOL"");

        bs.inPool[_token] = false;

        // remove token from array
        for (uint256 i; i < bs.tokens.length; i++) {
            if (address(bs.tokens[i]) == _token) {
                bs.tokens[i] = bs.tokens[bs.tokens.length - 1];
                bs.tokens.pop();
                emit TokenRemoved(_token);
                break;
            }
        }
    }

    function setEntryFee(uint256 _fee) external override protectedCall {
        require(_fee <= MAX_ENTRY_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().entryFee = _fee;
        emit EntryFeeSet(_fee);
    }

    function getEntryFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().entryFee;
    }

    function setExitFee(uint256 _fee) external override protectedCall {
        require(_fee <= MAX_EXIT_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().exitFee = _fee;
        emit ExitFeeSet(_fee);
    }

    function getExitFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().exitFee;
    }

    function setAnnualizedFee(uint256 _fee) external override protectedCall {
        chargeOutstandingAnnualizedFee();
        require(_fee <= MAX_ANNUAL_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().annualizedFee = _fee;
        emit AnnualizedFeeSet(_fee);
    }

    function getAnnualizedFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().annualizedFee;
    }

    function setFeeBeneficiary(address _beneficiary)
        external
        override
        protectedCall
    {
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.basketStorage().feeBeneficiary = _beneficiary;
        emit FeeBeneficiarySet(_beneficiary);
    }

    function getFeeBeneficiary() external view override returns (address) {
        return LibBasketStorage.basketStorage().feeBeneficiary;
    }

    function setEntryFeeBeneficiaryShare(uint256 _share)
        external
        override
        protectedCall
    {
        require(_share <= HUNDRED_PERCENT, ""FEE_SHARE_TOO_BIG"");
        LibBasketStorage.basketStorage().entryFeeBeneficiaryShare = _share;
        emit EntryFeeBeneficiaryShareSet(_share);
    }

    function getEntryFeeBeneficiaryShare()
        external
        view
        override
        returns (uint256)
    {
        return LibBasketStorage.basketStorage().entryFeeBeneficiaryShare;
    }

    function setExitFeeBeneficiaryShare(uint256 _share)
        external
        override
        protectedCall
    {
        require(_share <= HUNDRED_PERCENT, ""FEE_SHARE_TOO_BIG"");
        LibBasketStorage.basketStorage().exitFeeBeneficiaryShare = _share;
        emit ExitFeeBeneficiaryShareSet(_share);
    }

    function getExitFeeBeneficiaryShare()
        external
        view
        override
        returns (uint256)
    {
        return LibBasketStorage.basketStorage().exitFeeBeneficiaryShare;
    }

    function joinPool(uint256 _amount, uint16 _referral)
        external
        override
        noReentry
    {
        require(!this.getLock(), ""POOL_LOCKED"");
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;
        require(
            totalSupply.add(_amount) <= this.getCap(),
            ""MAX_POOL_CAP_REACHED""
        );

        uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenAmount =
                balance(address(token)).mul(_amount.add(feeAmount)).div(
                    totalSupply
                );
            require(tokenAmount != 0, ""AMOUNT_TOO_SMALL"");
            token.safeTransferFrom(msg.sender, address(this), tokenAmount);
        }

        // If there is any fee that should go to the beneficiary mint it
        if (
            feeAmount != 0 &&
            bs.entryFeeBeneficiaryShare != 0 &&
            bs.feeBeneficiary != address(0)
        ) {
            uint256 feeBeneficiaryShare =
                feeAmount.mul(bs.entryFeeBeneficiaryShare).div(10**18);
            if (feeBeneficiaryShare != 0) {
                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);
            }
        }

        LibERC20.mint(msg.sender, _amount);
        emit PoolJoined(msg.sender, _amount, _referral);
    }

    // Must be overwritten to withdraw from strategies
    function exitPool(uint256 _amount, uint16 _referral)
        external
        virtual
        override
        noReentry
    {
        require(!this.getLock(), ""POOL_LOCKED"");
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;

        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            // redeem less tokens if there is an exit fee
            uint256 tokenAmount =
                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);
            require(
                tokenBalance.sub(tokenAmount) >= MIN_AMOUNT,
                ""TOKEN_BALANCE_TOO_LOW""
            );
            token.safeTransfer(msg.sender, tokenAmount);
        }

        // If there is any fee that should go to the beneficiary mint it
        if (
            feeAmount != 0 &&
            bs.exitFeeBeneficiaryShare != 0 &&
            bs.feeBeneficiary != address(0)
        ) {
            uint256 feeBeneficiaryShare =
                feeAmount.mul(bs.exitFeeBeneficiaryShare).div(10**18);
            if (feeBeneficiaryShare != 0) {
                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);
            }
        }

        require(
            totalSupply.sub(_amount) >= MIN_AMOUNT,
            ""POOL_TOKEN_BALANCE_TOO_LOW""
        );
        LibERC20.burn(msg.sender, _amount);
        emit PoolExited(msg.sender, _amount, _referral);
    }

    function calcOutStandingAnnualizedFee()
        public
        view
        override
        returns (uint256)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;

        uint256 lastFeeClaimed = bs.lastAnnualizedFeeClaimed;
        uint256 annualizedFee = bs.annualizedFee;

        if (
            annualizedFee == 0 ||
            bs.feeBeneficiary == address(0) ||
            lastFeeClaimed == 0
        ) {
            return 0;
        }

        uint256 timePassed = block.timestamp.sub(lastFeeClaimed);

        return
            totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(
                365 days
            );
    }

    function chargeOutstandingAnnualizedFee() public override {
        uint256 outStandingFee = calcOutStandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();

        bs.lastAnnualizedFeeClaimed = block.timestamp;

        // if there is any fee to mint and the beneficiary is set
        // note: feeBeneficiary is already checked in calc function
        if (outStandingFee != 0) {
            LibERC20.mint(bs.feeBeneficiary, outStandingFee);
        }

        emit FeeCharged(outStandingFee);
    }

    // returns true when locked
    function getLock() external view override returns (bool) {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        return bs.lockBlock == 0 || bs.lockBlock >= block.number;
    }

    function getTokenInPool(address _token)
        external
        view
        override
        returns (bool)
    {
        return LibBasketStorage.basketStorage().inPool[_token];
    }

    function getLockBlock() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().lockBlock;
    }

    // lock up to and including _lock blocknumber
    function setLock(uint256 _lock) external override protectedCall {
        LibBasketStorage.basketStorage().lockBlock = _lock;
        emit LockSet(_lock);
    }

    function setCap(uint256 _maxCap) external override protectedCall {
        LibBasketStorage.basketStorage().maxCap = _maxCap;
        emit CapSet(_maxCap);
    }

    // Seperated balance function to allow yearn like strategies to be hooked up by inheriting from this contract and overriding
    function balance(address _token) public view override returns (uint256) {
        return IERC20(_token).balanceOf(address(this));
    }

    function getTokens() external view override returns (address[] memory) {
        IERC20[] memory tokens = LibBasketStorage.basketStorage().tokens;
        address[] memory result = new address[](tokens.length);

        for (uint256 i = 0; i < tokens.length; i++) {
            result[i] = address(tokens[i]);
        }

        return (result);
    }

    function getCap() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().maxCap;
    }

    function calcTokensForAmount(uint256 _amount)
        external
        view
        override
        returns (address[] memory tokens, uint256[] memory amounts)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply =
            LibERC20Storage.erc20Storage().totalSupply.add(
                calcOutStandingAnnualizedFee()
            );

        tokens = new address[](bs.tokens.length);
        amounts = new uint256[](bs.tokens.length);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            uint256 tokenAmount = tokenBalance.mul(_amount).div(totalSupply);
            // Add entry fee
            tokenAmount = tokenAmount.add(
                tokenAmount.mul(bs.entryFee).div(10**18)
            );

            tokens[i] = address(token);
            amounts[i] = tokenAmount;
        }

        return (tokens, amounts);
    }

    function calcTokensForAmountExit(uint256 _amount)
        external
        view
        override
        returns (address[] memory tokens, uint256[] memory amounts)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);
        uint256 totalSupply =
            LibERC20Storage.erc20Storage().totalSupply.add(
                calcOutStandingAnnualizedFee()
            );

        tokens = new address[](bs.tokens.length);
        amounts = new uint256[](bs.tokens.length);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            uint256 tokenAmount =
                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);

            tokens[i] = address(token);
            amounts[i] = tokenAmount;
        }

        return (tokens, amounts);
    }
}",2972,397,"H-01: Unused ERC20 tokens are not refunded, and can be stolen by attacker. L143-L168 M-04: Annualized fee APY dependence on the frequency of executing a function M-05: totalSupply may exceed LibBasketStorage.basketStorage().maxCap",3
5_Vader.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iUSDV.sol"";
import ""./interfaces/iROUTER.sol"";

contract Vader is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    bool public emitting;
    bool public minting;
    uint _1m;
    uint public baseline;
    uint public emissionCurve;
    uint public maxSupply;
    uint public secondsPerEra;
    uint public currentEra;
    uint public nextEraTime;
    uint public feeOnTransfer;

    address public VETHER;
    address public USDV;
    address public UTILS;
    address public burnAddress;
    address public rewardAddress;
    address public DAO;

    event NewEra(uint currentEra, uint nextEraTime, uint emission);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO, ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool){
        return iUSDV(USDV).isMature();
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER PROTOCOL TOKEN';
        symbol = 'VADER';
        decimals = 18;
        _1m = 10**6 * 10 ** decimals; 
        baseline = _1m;
        totalSupply = 0;
        maxSupply = 2 * _1m;
        currentEra = 1;
        secondsPerEra = 1; 
        nextEraTime = block.timestamp + secondsPerEra;
        emissionCurve = 900;
        DAO = msg.sender;
        burnAddress = 0x0111011001100001011011000111010101100101;
    }
    // Can only be called once
    function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) external view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        require(sender != address(0), ""sender"");
        require(recipient != address(this), ""recipient"");
        _balances[sender] -= amount;
        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  
        if(_fee >= 0 && _fee <= amount){                            
            amount -= _fee;
            _burn(msg.sender, _fee);
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _checkEmission();
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        require(account != address(0), ""recipient"");
        if((totalSupply + amount) >= maxSupply){
            amount = maxSupply - totalSupply;       
        }
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    // Burn supply
    function burn(uint amount) public virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        require(account != address(0), ""address err"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //=========================================DAO=========================================//
    // Can start
    function flipEmissions() external onlyDAO {
        if(emitting){
            emitting = false;
        } else {
            emitting = true;
        }
    }
    // Can stop
    function flipMinting() external onlyDAO {
        if(minting){
            minting = false;
        } else {
            minting = true;
        }
    }
    // Can set params
    function setParams(uint newEra, uint newCurve) external onlyDAO {
        secondsPerEra = newEra;
        emissionCurve = newCurve;
    }
    // Can set reward address
    function setRewardAddress(address newAddress) external onlyDAO {
        rewardAddress = newAddress;
    }
    // Can change UTILS
    function changeUTILS(address newUTILS) external onlyDAO {
        require(newUTILS != address(0), ""address err"");
        UTILS = newUTILS;
    }
    // Can change DAO
    function changeDAO(address newDAO) external onlyDAO {
        require(newDAO != address(0), ""address err"");
        DAO = newDAO;
    }
    // Can purge DAO
    function purgeDAO() external onlyDAO{
        DAO = address(0);
    }

   //======================================EMISSION========================================//
    // Internal - Update emission function
    function _checkEmission() private {
        if ((block.timestamp >= nextEraTime) && emitting) {                               
            currentEra += 1;                                                               
            nextEraTime = block.timestamp + secondsPerEra;                                 
            uint _emission = getDailyEmission();                                          
            _mint(rewardAddress, _emission);                                               
            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        
            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                
            emit NewEra(currentEra, nextEraTime, _emission);                               
        }
    }
    // Calculate Daily Emission
    function getDailyEmission() public view returns (uint) {
        uint _adjustedMax;
        if(totalSupply <= baseline){ 
            _adjustedMax = (maxSupply * totalSupply) / baseline; 
        } else {
            _adjustedMax = maxSupply;  
        }
        return (_adjustedMax - totalSupply) / (emissionCurve); 
    }

    //======================================ASSET MINTING========================================//
    // VETHER Owners to Upgrade
    function upgrade(uint amount) external {
        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));
        _mint(msg.sender, amount);
    }
    // Directly redeem back to VADER (must have sent USDV first)
    function redeem() external returns (uint redeemAmount){
        return redeemToMember(msg.sender);
    }
    // Redeem on behalf of member (must have sent USDV first)
    function redeemToMember(address member) public flashProof returns (uint redeemAmount){
        if(minting){
            uint _amount = iERC20(USDV).balanceOf(address(this)); 
            iERC20(USDV).burn(_amount);
            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); 
            _mint(member, redeemAmount);
        }
    }
}",1960,245,"H-03: Missing DAO functionality to call changeDAO() function in Vader.sol.  L192-L196 H-06: Incorrect burn address in Vader.sol.   H-17: Transfer fee is burned on wrong accounts H-25: Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol M-13: Init function can be called by everyone.  M-15: changeDAO should be a two-step process in Vader.sol M-17: Vader.redeemToMember() vulnerable to front running",7
16_GasOracle.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""../Interfaces/IOracle.sol"";
import ""../Interfaces/IChainlinkOracle.sol"";
import ""../lib/LibMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""prb-math/contracts/PRBMathUD60x18.sol"";

/**
 * @dev The following is a sample Gas Price Oracle Implementation for a Tracer Oracle.
 *      It references the Chainlink fast gas price and ETH/USD price to get a gas cost
 *      estimate in USD.
 */
contract GasOracle is IOracle, Ownable {
    using LibMath for uint256;
    IChainlinkOracle public gasOracle;
    IChainlinkOracle public priceOracle;
    uint8 public override decimals = 18;
    uint256 private constant MAX_DECIMALS = 18;

    constructor(address _priceOracle, address _gasOracle) {
        gasOracle = IChainlinkOracle(_gasOracle); 
        priceOracle = IChainlinkOracle(_priceOracle); 
    }

    /**
     * @notice Calculates the latest USD/Gas price
     * @dev Returned value is USD/Gas * 10^18 for compatibility with rest of calculations
     */
    function latestAnswer() external view override returns (uint256) {
        uint256 gasPrice = uint256(gasOracle.latestAnswer());
        uint256 ethPrice = uint256(priceOracle.latestAnswer());

        uint256 result = PRBMathUD60x18.mul(gasPrice, ethPrice);
        return result;
    }

    /**
     * @notice converts a raw value to a WAD value.
     * @dev this allows consistency for oracles used throughout the protocol
     *      and allows oracles to have their decimals changed withou affecting
     *      the market itself
     */
    function toWad(uint256 raw, IChainlinkOracle _oracle) internal view returns (uint256) {
        IChainlinkOracle oracle = IChainlinkOracle(_oracle);
        // reset the scaler for consistency
        uint8 _decimals = oracle.decimals(); 
        require(_decimals <= MAX_DECIMALS, ""GAS: too many decimals"");
        uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));
        return raw * scaler;
    }

    function setGasOracle(address _gasOracle) public onlyOwner {
        require(_gasOracle != address(0), ""address(0) given"");
        gasOracle = IChainlinkOracle(_gasOracle);
    }

    function setPriceOracle(address _priceOracle) public onlyOwner {
        require(_priceOracle != address(0), ""address(0) given"");
        priceOracle = IChainlinkOracle(_priceOracle);
    }

    function setDecimals(uint8 _decimals) external {
        decimals = _decimals;
    }
}",603,68,H-06: Wrong price scale for GasOracle,1
23_NotionalV1ToNotionalV2.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface WETH9 {
    function withdraw(uint256 wad) external;

    function transfer(address dst, uint256 wad) external returns (bool);
}

interface IEscrow {
    function getBalances(address account) external view returns (int256[] memory);
}

interface INotionalV1Erc1155 {
    /** Notional V1 Types */
    struct Deposit {
        // Currency Id to deposit
        uint16 currencyId;
        // Amount of tokens to deposit
        uint128 amount;
    }

    /**
     * Used to describe withdraws in ERC1155.batchOperationWithdraw
     */
    struct Withdraw {
        // Destination of the address to withdraw to
        address to;
        // Currency Id to withdraw
        uint16 currencyId;
        // Amount of tokens to withdraw
        uint128 amount;
    }

    enum TradeType {TakeCurrentCash, TakefCash, AddLiquidity, RemoveLiquidity}

    /**
     * Used to describe a trade in ERC1155.batchOperation
     */
    struct Trade {
        TradeType tradeType;
        uint8 cashGroup;
        uint32 maturity;
        uint128 amount;
        bytes slippageData;
    }

    function batchOperationWithdraw(
        address account,
        uint32 maxTime,
        Deposit[] memory deposits,
        Trade[] memory trades,
        Withdraw[] memory withdraws
    ) external payable;
}

contract NotionalV1ToNotionalV2 {
    IEscrow public immutable Escrow;
    NotionalProxy public immutable NotionalV2;
    INotionalV1Erc1155 public immutable NotionalV1Erc1155;
    WETH9 public immutable WETH;
    IERC20 public immutable WBTC;

    uint16 internal constant V1_ETH = 0;
    uint16 internal constant V1_DAI = 1;
    uint16 internal constant V1_USDC = 2;
    uint16 internal constant V1_WBTC = 3;

    uint16 public constant V2_ETH = 1;
    uint16 public immutable V2_DAI;
    uint16 public immutable V2_USDC;
    uint16 public immutable V2_WBTC;

    constructor(
        IEscrow escrow_,
        NotionalProxy notionalV2_,
        INotionalV1Erc1155 erc1155_,
        WETH9 weth_,
        IERC20 wbtc_,
        uint16 v2Dai_,
        uint16 v2USDC_,
        uint16 v2WBTC_
    ) {
        Escrow = escrow_;
        NotionalV2 = notionalV2_;
        NotionalV1Erc1155 = erc1155_;
        WETH = weth_;
        WBTC = wbtc_;
        V2_DAI = v2Dai_;
        V2_USDC = v2USDC_;
        V2_WBTC = v2WBTC_;
    }

    function enableWBTC() external {
        WBTC.approve(address(NotionalV2), type(uint256).max);
    }

    function migrateDaiEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        // borrow on notional via special flash loan facility
        //  - borrow repayment amount
        //  - withdraw to wallet
        // receive callback (tokens transferred to borrowing account)
        //   -> inside callback
        //   -> repay Notional V1
        //   -> deposit collateral to notional v2 (account needs to have set approvals)
        //   -> exit callback
        // inside original borrow, check FC
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateDaiWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");
        (
            uint16 v1DebtCurrencyId,
            uint128 v1RepayAmount,
            uint16 v1CollateralId,
            uint16 v2CollateralId
        ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));

        int256[] memory balances = Escrow.getBalances(account);
        int256 collateralBalance =
            (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);
        require(collateralBalance > 0);

        {
            INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);
            INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);
            INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);

            // This will deposit what was borrowed from the account's wallet
            deposits[0].currencyId = v1DebtCurrencyId;
            deposits[0].amount = v1RepayAmount;

            // This will withdraw to the current contract the collateral to repay the flash loan
            withdraws[0].currencyId = v1CollateralId;
            withdraws[0].to = address(this);
            withdraws[0].amount = uint128(collateralBalance);

            NotionalV1Erc1155.batchOperationWithdraw(
                account,
                uint32(block.timestamp),
                deposits,
                trades,
                withdraws
            );
        }

        // Overflow checked above, cannot be negative
        uint256 v2CollateralBalance = uint256(collateralBalance);
        if (v2CollateralId == V2_ETH) {
            // Notional V1 uses WETH, but V2 uses ETH
            WETH.withdraw(v2CollateralBalance);
            NotionalV2.depositUnderlyingToken{value: v2CollateralBalance}(
                account,
                v2CollateralId,
                v2CollateralBalance
            );
        } else {
            NotionalV2.depositUnderlyingToken(account, v2CollateralId, v2CollateralBalance);
        }

        // When this exits it will do a free collateral check
    }

    receive() external payable {}
}",1658,204,H-05: Access restrictions on NotionalV1ToNotionalV2.notionalCallback can be bypassed,1
14_BadgerYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";

/// @title A pooltogether yield source for badger sett
/// @author Steffel Fenix, 0xkarl
contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param amount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.
    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}",830,82,"H-03: BadgerYieldSource balanceOfToken share calculation seems wrong M-02: Return values of ERC20 transfer and transferFrom are unchecked M-03: SafeMath not completely used in yield source contracts L67",3
22_Staker.sol,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";

import ""./interfaces/IFloatToken.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ISyntheticToken.sol"";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; 
  // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; 
  // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, ""not admin"");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, ""not valid synth"");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), ""not valid market"");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), ""not long short"");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); 
    // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); 
    // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, ""marketLaunchIncentiveMultiplier must be >= 1e18"");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      ""balanceIncentiveCurve_exponent out of bounds""
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      ""balanceIncentiveCurve_equilibriumOffset out of bounds""
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; 
      // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, ""Not enough tokens to shift"");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, ""nothing to withdraw"");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        ""Outstanding next price stake shifts too great""
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}",10105,990,"H-02: 2 variables not indexed by marketIndex. L622 H-03: Users could shift tokens on Staker with more than he has staked.  L885 M-04: Staker.sol: Wrong values returned in edge cases of _calculateFloatPerSecond()",3
8_ERC20FlashMintUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.8;

import ""../interface/IERC3156Upgradeable.sol"";
import ""./ERC20Upgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Implementation of the ERC3156 Flash loans extension, as defined in
 * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].
 *
 * Adds the {flashLoan} method, which provides flash loan support at the token
 * level. By default there is no fee, but this can be changed by overriding {flashFee}.
 */
abstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {
    function __ERC20FlashMint_init() internal initializer {
        __Context_init_unchained();
        __ERC20FlashMint_init_unchained();
    }

    function __ERC20FlashMint_init_unchained() internal initializer {
    }
    bytes32 constant private RETURN_VALUE = keccak256(""ERC3156FlashBorrower.onFlashLoan"");

    /**
     * @dev Returns the maximum amount of tokens available for loan.
     * @param token The address of the token that is requested.
     * @return The amont of token that can be loaned.
     */
    function maxFlashLoan(address token) public view override returns (uint256) {
        return token == address(this) ? type(uint256).max - ERC20Upgradeable.totalSupply() : 0;
    }

    /**
     * @dev Returns the fee applied when doing flash loans. By default this
     * implementation has 0 fees. This function can be overloaded to make
     * the flash loan mechanism deflationary.
     * @param token The token to be flash loaned.
     * @param amount The amount of tokens to be loaned.
     * @return The fees applied to the corresponding flash loan.
     */
    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {
        require(token == address(this), ""ERC20FlashMint: wrong token"");
        // silence warning about unused variable without the addition of bytecode.
        amount;
        return 0;
    }

    /**
     * @dev Performs a flash loan. New tokens are minted and sent to the
     * `receiver`, who is required to implement the {IERC3156FlashBorrower}
     * interface. By the end of the flash loan, the receiver is expected to own
     * amount + fee tokens and have them approved back to the token contract itself so
     * they can be burned.
     * @param receiver The receiver of the flash loan. Should implement the
     * {IERC3156FlashBorrower.onFlashLoan} interface.
     * @param token The token to be flash loaned. Only `address(this)` is
     * supported.
     * @param amount The amount of tokens to be loaned.
     * @param data An arbitrary datafield that is passed to the receiver.
     * @return `true` is the flash loan was successfull.
     */
    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    )
        public virtual override returns (bool)
    {
        uint256 fee = flashFee(token, amount);
        _mint(address(receiver), amount);
        require(receiver.onFlashLoan(msg.sender, token, amount, fee, data) == RETURN_VALUE, ""ERC20FlashMint: invalid return value"");
        uint256 currentAllowance = allowance(address(receiver), address(this));
        require(currentAllowance >= amount + fee, ""ERC20FlashMint: allowance does not allow refund"");
        _approve(address(receiver), address(this), currentAllowance - amount - fee);
        _burn(address(receiver), amount + fee);
        return true;
    }
    uint256[50] private __gap;
}",833,82,H-01: Missing overflow check in flashLoan,1
30_Controller.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IHarvester.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IManager.sol"";

/**
 * @title Controller
 * @notice This controller allows multiple strategies to be used
 * for a single vault supporting multiple tokens.
 */
contract Controller is IController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IManager public immutable override manager;

    bool public globalInvestEnabled;
    uint256 public maxStrategies;

    struct VaultDetail {
        address converter;
        uint256 balance;
        address[] strategies;
        mapping(address => uint256) balances;
        mapping(address => uint256) index;
        mapping(address => uint256) caps;
    }

    // vault => Vault
    mapping(address => VaultDetail) internal _vaultDetails;
    // strategy => vault
    mapping(address => address) internal _vaultStrategies;

    /**
     * @notice Logged when harvest is called for a strategy
     */
    event Harvest(address indexed strategy);

    /**
     * @notice Logged when a strategy is added for a vault
     */
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);

    /**
     * @notice Logged when a strategy is removed for a vault
     */
    event StrategyRemoved(address indexed vault, address indexed strategy);

    /**
     * @notice Logged when strategies are reordered for a vault
     */
    event StrategiesReordered(
        address indexed vault,
        address indexed strategy1,
        address indexed strategy2
    );

    /**
     * @param _manager The address of the manager
     */
    constructor(
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        globalInvestEnabled = true;
        maxStrategies = 10;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Adds a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The cap of the strategy
     * @param _timeout The timeout between harvests
     */
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _cap,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultDetails[_vault].converter != address(0), ""!converter"");
        // checking if strategy is already added
        require(_vaultStrategies[_strategy] == address(0), ""Strategy is already added""); 
        // get the index of the newly added strategy
        uint256 index = _vaultDetails[_vault].strategies.length;
        // ensure we haven't added too many strategies already
        require(index < maxStrategies, ""!maxStrategies"");
        // push the strategy to the array of strategies
        _vaultDetails[_vault].strategies.push(_strategy);
        // set the cap
        _vaultDetails[_vault].caps[_strategy] = _cap;
        // set the index
        _vaultDetails[_vault].index[_strategy] = index;
        // store the mapping of strategy to the vault
        _vaultStrategies[_strategy] = _vault;
        if (_timeout > 0) {
            // add it to the harvester
            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);
        }
        emit StrategyAdded(_vault, _strategy, _cap);
    }

    /**
     * @notice Withdraws token from a strategy to the treasury address as returned by the manager
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     */
    function inCaseStrategyGetStuck(
        address _strategy,
        address _token
    )
        external
        onlyStrategist
    {
        IStrategy(_strategy).withdraw(_token);
        IERC20(_token).safeTransfer(
            manager.treasury(),
            IERC20(_token).balanceOf(address(this))
        );
    }

    /**
     * @notice Withdraws token from the controller to the treasury
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function inCaseTokensGetStuck(
        address _token,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        IERC20(_token).safeTransfer(manager.treasury(), _amount);
    }

    /**
     * @notice Removes a strategy for a given token
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the index of the strategy to remove
        uint256 index = vaultDetail.index[_strategy];
        // get the index of the last strategy
        uint256 tail = vaultDetail.strategies.length.sub(1);
        // get the address of the last strategy
        address replace = vaultDetail.strategies[tail];
        // replace the removed strategy with the tail
        vaultDetail.strategies[index] = replace;
        // set the new index for the replaced strategy
        vaultDetail.index[replace] = index;
        // remove the duplicate replaced strategy
        vaultDetail.strategies.pop();
        // remove the strategy's index
        delete vaultDetail.index[_strategy];
        // remove the strategy's cap
        delete vaultDetail.caps[_strategy];
        // remove the strategy's balance
        delete vaultDetail.balances[_strategy];
        // remove the mapping of strategy to the vault
        delete _vaultStrategies[_strategy];
        // pull funds from the removed strategy to the vault
        IStrategy(_strategy).withdrawAll();
        // remove the strategy from the harvester
        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);
        emit StrategyRemoved(_vault, _strategy);
    }

    /**
     * @notice Reorders two strategies for a given vault
     * @param _vault The address of the vault
     * @param _strategy1 The address of the first strategy
     * @param _strategy2 The address of the second strategy
     */
    function reorderStrategies(
        address _vault,
        address _strategy1,
        address _strategy2
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultStrategies[_strategy1] == _vault, ""!_strategy1"");
        require(_vaultStrategies[_strategy2] == _vault, ""!_strategy2"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the indexes of the strategies
        uint256 index1 = vaultDetail.index[_strategy1];
        uint256 index2 = vaultDetail.index[_strategy2];
        // set the new addresses at their indexes
        vaultDetail.strategies[index1] = _strategy2;
        vaultDetail.strategies[index2] = _strategy1;
        // update indexes
        vaultDetail.index[_strategy1] = index2;
        vaultDetail.index[_strategy2] = index1;
        emit StrategiesReordered(_vault, _strategy1, _strategy2);
    }

    /**
     * @notice Sets/updates the cap of a strategy for a vault
     * @dev If the balance of the strategy is greater than the new cap (except if
     * the cap is 0), then withdraw the difference from the strategy to the vault.
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The new cap of the strategy
     */
    function setCap(
        address _vault,
        address _strategy,
        uint256 _cap,
        address _convert
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        _vaultDetails[_vault].caps[_strategy] = _cap;
        uint256 _balance = IStrategy(_strategy).balanceOf();
        // send excess funds (over cap) back to the vault
        if (_balance > _cap && _cap != 0) {
            uint256 _diff = _balance.sub(_cap);
            IStrategy(_strategy).withdraw(_diff);
            updateBalance(_vault, _strategy);
            _balance = IStrategy(_strategy).balanceOf();
            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);
            address _want = IStrategy(_strategy).want();
            _balance = IERC20(_want).balanceOf(address(this));
            if (_convert != address(0)) {
                IConverter _converter = IConverter(_vaultDetails[_vault].converter);
                IERC20(_want).safeTransfer(address(_converter), _balance);
                _balance = _converter.convert(_want, _convert, _balance, 1);
                IERC20(_convert).safeTransfer(_vault, _balance);
            } else {
                IERC20(_want).safeTransfer(_vault, _balance);
            }
        }
    }

    /**
     * @notice Sets/updates the converter for a given vault
     * @param _vault The address of the vault
     * @param _converter The address of the converter
     */
    function setConverter(
        address _vault,
        address _converter
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedConverters(_converter), ""!allowedConverters"");
        _vaultDetails[_vault].converter = _converter;
    }

    /**
     * @notice Sets/updates the global invest enabled flag
     * @param _investEnabled The new bool of the invest enabled flag
     */
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        notHalted
        onlyStrategist
    {
        globalInvestEnabled = _investEnabled;
    }

    /**
     * @notice Sets/updates the maximum number of strategies for a vault
     * @param _maxStrategies The new value of the maximum strategies
     */
    function setMaxStrategies(
        uint256 _maxStrategies
    )
        external
        notHalted
        onlyStrategist
    {
        maxStrategies = _maxStrategies;
    }

    function skim(
        address _strategy
    )
        external
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).skim();
        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));
    }

    /**
     * @notice Withdraws all funds from a strategy
     * @param _strategy The address of the strategy
     * @param _convert The token address to convert to
     */
    function withdrawAll(
        address _strategy,
        address _convert
    )
        external
        override
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).withdrawAll();
        uint256 _amount = IERC20(_want).balanceOf(address(this));
        address _vault = _vaultStrategies[_strategy];
        updateBalance(_vault, _strategy);
        if (_convert != address(0)) {
            IConverter _converter = IConverter(_vaultDetails[_vault].converter);
            IERC20(_want).safeTransfer(address(_converter), _amount);
            _amount = _converter.convert(_want, _convert, _amount, 1);
            IERC20(_convert).safeTransfer(_vault, _amount);
        } else {
            IERC20(_want).safeTransfer(_vault, _amount);
        }
        uint256 _balance = _vaultDetails[_vault].balance;
        if (_balance >= _amount) {
            _vaultDetails[_vault].balance = _balance.sub(_amount);
        } else {
            _vaultDetails[_vault].balance = 0;
        }
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Harvests the specified strategy
     * @param _strategy The address of the strategy
     */
    function harvestStrategy(
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        notHalted
        onlyHarvester
        onlyStrategy(_strategy)
    {
        uint256 _before = IStrategy(_strategy).balanceOf();
        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);
        uint256 _after = IStrategy(_strategy).balanceOf();
        address _vault = _vaultStrategies[_strategy];
        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));
        _vaultDetails[_vault].balances[_strategy] = _after;
        emit Harvest(_strategy);
    }

    /**
     * VAULT-ONLY FUNCTIONS
     */

    /**
     * @notice Invests funds into a strategy
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     * @param _amount The amount that will be invested
     */
    function earn(
        address _strategy,
        address _token,
        uint256 _amount
    )
        external
        override
        notHalted
        onlyStrategy(_strategy)
        onlyVault(_token)
    {
        // get the want token of the strategy
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);
            IERC20(_token).safeTransfer(address(_converter), _amount);
            // TODO: do estimation for received
            _amount = _converter.convert(_token, _want, _amount, 1);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);
        // call the strategy deposit function
        IStrategy(_strategy).deposit();
        updateBalance(msg.sender, _strategy);
    }

    /**
     * @notice Withdraws funds from a strategy
     * @dev If the withdraw amount is greater than the first strategy given
     * by getBestStrategyWithdraw, this function will loop over strategies
     * until the requested amount is met.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function withdraw(
        address _token,
        uint256 _amount
    )
        external
        override
        onlyVault(_token)
    {
        (
            address[] memory _strategies,
            uint256[] memory _amounts
        ) = getBestStrategyWithdraw(_token, _amount);
        for (uint i = 0; i < _strategies.length; i++) {
            // getBestStrategyWithdraw will return arrays larger than needed
            // if this happens, simply exit the loop
            if (_strategies[i] == address(0)) {
                break;
            }
            IStrategy(_strategies[i]).withdraw(_amounts[i]);
            updateBalance(msg.sender, _strategies[i]);
            address _want = IStrategy(_strategies[i]).want();
            if (_want != _token) {
                address _converter = _vaultDetails[msg.sender].converter;
                IERC20(_want).safeTransfer(_converter, _amounts[i]);
                // TODO: do estimation for received
                IConverter(_converter).convert(_want, _token, _amounts[i], 1);
            }
        }
        _amount = IERC20(_token).balanceOf(address(this));
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the rough balance of the sum of all strategies for a given vault
     * @dev This function is optimized to prevent looping over all strategy balances,
     * and instead the controller tracks the earn, withdraw, and harvest amounts.
     */
    function balanceOf()
        external
        view
        override
        returns (uint256 _balance)
    {
        return _vaultDetails[msg.sender].balance;
    }

    /**
     * @notice Returns the converter assigned for the given vault
     * @param _vault Address of the vault
     */
    function converter(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return _vaultDetails[_vault].converter;
    }

    /**
     * @notice Returns the cap of a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function getCap(
        address _vault,
        address _strategy
    )
        external
        view
        returns (uint256)
    {
        return _vaultDetails[_vault].caps[_strategy];
    }

    /**
     * @notice Returns whether investing is enabled for the calling vault
     * @dev Should be called by the vault
     */
    function investEnabled()
        external
        view
        override
        returns (bool)
    {
        if (globalInvestEnabled) {
            return _vaultDetails[msg.sender].strategies.length > 0;
        }
        return false;
    }

    /**
     * @notice Returns all the strategies for a given vault
     * @param _vault The address of the vault
     */
    function strategies(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return _vaultDetails[_vault].strategies;
    }

    /**
     * @notice Returns the length of the strategies of the calling vault
     * @dev This function is expected to be called by a vault
     */
    function strategies()
        external
        view
        override
        returns (uint256)
    {
        return _vaultDetails[msg.sender].strategies.length;
    }

    /**
     * INTERNAL FUNCTIONS
     */

    /**
     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from
     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays
     * from this function will always be the same length as the amount of strategies for
     * a token. Check that _strategies[i] != address(0) when consuming to know when to
     * break out of the loop.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function getBestStrategyWithdraw(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (
            address[] memory _strategies,
            uint256[] memory _amounts
        )
    {
        // get the length of strategies for a single token
        address _vault = manager.vaults(_token);
        uint256 k = _vaultDetails[_vault].strategies.length;
        // initialize fixed-length memory arrays
        _strategies = new address[](k);
        _amounts = new uint256[](k);
        address _strategy;
        uint256 _balance;
        // scan forward from the the beginning of strategies
        for (uint i = 0; i < k; i++) {
            _strategy = _vaultDetails[_vault].strategies[i];
            _strategies[i] = _strategy;
            // get the balance of the strategy
            _balance = _vaultDetails[_vault].balances[_strategy];
            // if the strategy doesn't have the balance to cover the withdraw
            if (_balance < _amount) {
                // withdraw what we can and add to the _amounts
                _amounts[i] = _balance;
                _amount = _amount.sub(_balance);
            } else {
                // stop scanning if the balance is more than the withdraw amount
                _amounts[i] = _amount;
                break;
            }
        }
    }

    /**
     * @notice Updates the stored balance of a given strategy for a vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function updateBalance(
        address _vault,
        address _strategy
    )
        internal
    {
        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();
    }

    /**
     * MODIFIERS
     */

    /**
     * @notice Reverts if the protocol is halted
     */
    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    /**
     * @notice Reverts if the caller is not governance
     */
    modifier onlyGovernance() {
        require(msg.sender == manager.governance(), ""!governance"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    /**
     * @notice Reverts if the strategy is not allowed in the manager
     */
    modifier onlyStrategy(address _strategy) {
        require(manager.allowedStrategies(_strategy), ""!allowedStrategy"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the harvester
     */
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the vault for the given token
     */
    modifier onlyVault(address _token) {
        require(msg.sender == manager.vaults(_token), ""!vault"");
        _;
    }
}",4847,683,"H-01: Controller.setCap sets wrong vault balance H-02: set cap breaks vault's Balance.  L475 H-06: earn results in decreasing share price. L410-L436 H-09: removeToken would break the vault/protocol.   L488 H-10: An attacker can steal funds from multi-token vaults. L396 M-06: Controller is vulnerable to sandwich attack. L360 M-08: Controller.inCaseStrategyGetStuck does not update balance M-13: manager.allowedVaults check missing for add/remove strategy. L130 L297 L224 ",8
47_WrappedIbbtcEth.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";

/*Wrapped Interest-Bearing Bitcoin (Ethereum mainnet variant)
*/
contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    /// @dev The ibBTC token is technically capable of having it's Core contract changed via governance process. This allows the wrapper to adapt.
    /// @dev This function should be run atomically with setCore() on ibBTC if that eventuality ever arises.
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Update live ibBTC price per share from core
    /// @dev We cache this to reduce gas costs of mint / burn / transfer operations.
    /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}",1336,162,"H-03: WrappedIbbtcEth contract will use stalled price for mint/burn if updatePricePerShare wasn't run properly.  L155 L72 H-04: WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers. L72 L75 M-02: Null check in pricePerShare. L73 L123 M-04: No sanity check on pricePerShare might lead to lost value. L127",4
23_nTokenAction.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/nTokenHandler.sol"";
import ""../../internal/markets/AssetRate.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/balances/Incentives.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../global/StorageLayoutV1.sol"";
import ""interfaces/notional/nTokenERC20.sol"";
import ""@openzeppelin/contracts/utils/SafeCast.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract nTokenAction is StorageLayoutV1, nTokenERC20 {
    using BalanceHandler for BalanceState;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;
    using SafeInt256 for int256;
    using SafeMath for uint256;

    /// @notice Total number of tokens in circulation
    /// @param nTokenAddress The address of the nToken
    /// @return totalSupply number of tokens held
    function nTokenTotalSupply(address nTokenAddress)
        external
        view
        override
        returns (uint256 totalSupply)
    {
        // prettier-ignore
        (
            totalSupply,
            /* integralTotalSupply */,
            /* lastSupplyChangeTime */
        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);
    }

    /// @notice Get the number of tokens held by the `account`
    /// @param account The address of the account to get the balance of
    /// @return The number of tokens held
    function nTokenBalanceOf(uint16 currencyId, address account)
        external
        view
        override
        returns (uint256)
    {
        // prettier-ignore
        (
            /* int cashBalance */,
            int256 nTokenBalance,
            /* uint lastClaimTime */,
            /* uint lastClaimIntegralSupply */
        ) = BalanceHandler.getBalanceStorage(account, currencyId);

        require(nTokenBalance >= 0); 
        // dev: negative nToken balance
        return uint256(nTokenBalance);
    }

    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
    /// @param owner The address of the account holding the funds
    /// @param spender The address of the account spending the funds
    /// @return The number of tokens approved
    function nTokenTransferAllowance(
        uint16 currencyId,
        address owner,
        address spender
    ) external view override returns (uint256) {
        // This whitelist allowance supersedes any specific allowances
        uint256 allowance = nTokenWhitelist[owner][spender];
        if (allowance > 0) return allowance;

        return nTokenAllowance[owner][spender][currencyId];
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev Can only be called via the nToken proxy
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function nTokenTransferApprove(
        uint16 currencyId,
        address owner,
        address spender,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        nTokenAllowance[owner][spender][currencyId] = amount;

        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @dev Can only be called via the nToken proxy
    /// @param from The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function nTokenTransfer(
        uint16 currencyId,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        return _transfer(currencyId, from, to, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @dev Can only be called via the nToken proxy
    /// @param currencyId Currency id of the nToken
    /// @param spender The address of the original caller
    /// @param from The address of the source account
    /// @param to The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function nTokenTransferFrom(
        uint16 currencyId,
        address spender,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool, uint256) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        uint256 allowance = nTokenWhitelist[from][spender];

        if (allowance > 0) {
            // This whitelist allowance supersedes any specific allowances
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenWhitelist[from][spender] = allowance;
        } else {
            // This is the specific allowance for the nToken.
            allowance = nTokenAllowance[from][spender][currencyId];
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenAllowance[from][spender][currencyId] = allowance;
        }

        bool success = _transfer(currencyId, from, to, amount);
        return (success, allowance);
    }

    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve
    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly
    /// on the Notional contract, not available via the ERC20 proxy.
    /// @dev emit:Approval
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function nTokenTransferApproveAll(address spender, uint256 amount)
        external
        override
        returns (bool)
    {
        nTokenWhitelist[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender
    /// @dev auth:msg.sender
    /// @return Total amount of incentives claimed
    function nTokenClaimIncentives() external override returns (uint256) {
        address account = msg.sender;
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        uint256 totalIncentivesClaimed;
        BalanceState memory balanceState;

        if (accountContext.bitmapCurrencyId != 0) {
            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));

            balanceState.loadBalanceState(account, currencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }

            currencies = currencies << 16;
        }

        // NOTE: no need to set account context after claiming incentives
        return totalIncentivesClaimed;
    }

    /// @notice Returns the present value of the nToken's assets denominated in asset tokens
    function nTokenPresentValueAssetDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        // prettier-ignore
        (
            int256 totalAssetPV,
            /* portfolio */
        ) = _getNTokenPV(currencyId);

        return totalAssetPV;
    }

    /// @notice Returns the present value of the nToken's assets denominated in underlying
    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);

        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);
    }

    function _getNTokenPV(uint256 currencyId)
        private
        view
        returns (int256, nTokenPortfolio memory)
    {
        uint256 blockTime = block.timestamp;
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);

        // prettier-ignore
        (
            int256 totalAssetPV,
            /* ifCashMapping */
        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);

        return (totalAssetPV, nToken);
    }

    /// @notice Transferring tokens will also claim incentives at the same time
    function _transfer(
        uint256 currencyId,
        address sender,
        address recipient,
        uint256 amount
    ) internal returns (bool) {
        {
            // prettier-ignore
            (
                uint256 isNToken,
                /* incentiveAnnualEmissionRate */,
                /* lastInitializedTime */,
                /* parameters */
            ) = nTokenHandler.getNTokenContext(recipient);
            // nTokens cannot hold nToken balances
            require(isNToken == 0, ""Cannot transfer to nToken"");
        }

        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);
        BalanceState memory senderBalance;
        senderBalance.loadBalanceState(sender, currencyId, senderContext);

        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);
        BalanceState memory recipientBalance;
        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);

        int256 amountInt = SafeCast.toInt256(amount);
        senderBalance.netNTokenTransfer = amountInt.neg();
        recipientBalance.netNTokenTransfer = amountInt;

        senderBalance.finalize(sender, senderContext, false);
        recipientBalance.finalize(recipient, recipientContext, false);
        senderContext.setAccountContext(sender);
        recipientContext.setAccountContext(recipient);

        emit Transfer(sender, recipient, amount);

        return true;
    }
}",2311,292,H-01: Self transfer can lead to unlimited mint.  L279,1
67_Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";

/**
 * A vault where other accounts can deposit an underlying token
 * currency and set distribution params for their principal and yield
 *
 * @dev Yield generation strategies not yet implemented
 */

contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    //
    // Constants
    //

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; 
    // 2 weeks in seconds
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    //
    // State
    //

    /// Underlying ERC20 token accepted by the vault
    /// See {IVault}
    IERC20 public override(IVault) underlying;

    /// See {IVault}
    IStrategy public strategy;

    /// See {IVault}
    uint256 public investPerc;

    /// See {IVault}
    uint256 public immutable override(IVault) minLockPeriod;

    /// See {IVaultSponsoring}
    uint256 public override(IVaultSponsoring) totalSponsored;

    /// Depositors, represented as an NFT per deposit
    Depositors public depositors;

    /// Yield allocation
    Claimers public claimers;

    /// Unique IDs to correlate donations that belong to the same foundation
    Counters.Counter private _depositGroupIds;

    /**
     * @param _underlying Underlying ERC20 token to use.
     */
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    //
    // IVault
    //

    /// See {IVault}
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    /// See {IVault}
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    /// See {IVault}
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    /// See {IVault}
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    /// See {IVault}
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    /// See {IVault}
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    /// See {IVault}
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    /// See {IVault}
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    /// See {IVault}
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    /// See {IVault}
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    /// See {IVault}
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    //
    // IVaultSponsoring

    /// See {IVaultSponsoring}
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    /// See {IVaultSponsoring}
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    /// See {IVaultSponsoring}
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    //
    // Public API
    //

    /**
     * Computes the total amount of principal + yield currently controlled by the
     * vault and the strategy. The principal + yield is the total amount
     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.
     *
     * @return Total amount of principal and yield help by the vault (not including sponsored amount).
     */
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        // TODO no invested amount yet
        return totalUnderlying() - totalSponsored;
    }

    //
    // ERC165
    //

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    //
    // Internal API
    //

    /**
     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    /**
     * Withdraws the sponsored amount for the deposits with the ids provided
     * in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    /**
     * Creates a deposit with the given amount of underlying and claim
     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.
     * @notice This function assumes underlying will be transfered elsewhere in
     * the transaction.
     *
     * @notice Underlying must be transfered *after* this function, in order to
     * correctly calculate shares.
     *
     * @notice claims must add up to 100%.
     *
     * @param _amount Amount of underlying to consider @param claims claim
     * @param _lockedUntil When the depositor can unsponsor the amount.
     * @param claims Claim params
     * params.
     */
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    /**
     * Burns a deposit NFT and reduces the principal and shares of the claimer.
     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.
     *
     * @notice This function doesn't transfer any funds, it only updates the state.
     *
     * @notice Only the owner of the deposit may call this function.
     *
     * @param _tokenId The deposit ID to withdraw from.
     * @param _totalShares The total shares to consider for the withdraw.
     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.
     *
     * @return the amount to withdraw.
     */
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    /**
     * Computes amount of shares that will be received for a given deposit amount
     *
     * @param _amount Amount of deposit to consider.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount of shares the deposit will receive.
     */
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    /**
     * Computes the amount of underlying from a given number of shares
     *
     * @param _shares Number of shares.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount that corresponds to the number of shares.
     */
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            // TODO exclude sponsored assets
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    /**
     * Checks if the given address is a contract implementing IIntegration
     *
     * @param addr Address to check
     * @return true if contract is an IIntegraiont
     */
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",4420,654,"H-02: Reentrancy, Withdrawers can get more value returned than expected with reentrant call H-04: deposit() function is open to reentrancy attacks.  L160 L470 L476 H-05: sponsor() function in open to reentrancy attacks. L244 M-01: Late users will take more losses than expected when the underlying contract (EthAnchor) suffers investment losses. L544 M-04: unsponsor, claimYield and withdraw might fail unexpectedly. L391 M-06: totalUnderlyingMinusSponsored() may revert on underflow and malfunction the contract. L290 M-07: Vault can't receive deposits if underlying token charges fees on transfer L583 M-09: no use of safeMint() as safe guard for users. L470 L256",8
83_StakingRewards.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./MasterChef.sol"";

contract StakingRewards is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    MasterChef public immutable masterChef;

    /* ========== STATE VARIABLES ========== */

    IERC20 public rewardsToken;
    IERC20 public stakingToken;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public rewardsDuration = 7 days;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    address public rewardsDistribution;

    /* ========== CONSTRUCTOR ========== */

    constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken,
        MasterChef _masterChef
    ) {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        masterChef = _masterChef;
    }

    /* ========== VIEWS ========== */

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            (((lastTimeRewardApplicable() - lastUpdateTime) *
                rewardRate *
                1e18) / _totalSupply);
    }

    function earned(address account) public view returns (uint256) {
        return
            (_balances[account] *
                (rewardPerToken() - userRewardPerTokenPaid[account])) /
            1e18 +
            rewards[account];
    }

    function getRewardForDuration() external view returns (uint256) {
        return rewardRate * rewardsDuration;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function stake(uint256 amount)
        external
        nonReentrant
        whenNotPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.deposit(msg.sender, pid, amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount)
        public
        nonReentrant
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.withdraw(msg.sender, pid, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address tokenAddress, uint256 tokenAmount)
        external
        onlyOwner
    {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }

    function setRewardsDistribution(address _rewardsDistribution)
        external
        onlyOwner
    {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDistribution = _rewardsDistribution;
        emit RewardsDistributionUpdated(rewardsDistribution);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    /* ========== EVENTS ========== */

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event RewardsDistributionUpdated(address indexed newDistribution);
    event Recovered(address token, uint256 amount);
}",1501,221,"H-04: ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver  L99 M-06: StakingRewards.sol recoverERC20() can be used as a backdoor by the owner to retrieve rewardsToken. L166 M-09: StakingRewards.sol#notifyRewardAmount() Improper reward balance checks can make some users unable to withdraw their rewards. L154 M-13: StakingRewards.recoverERC20 allows owner to rug the rewardsToken. L166 M-22: If The Staking Token Exists In Both StakingRewards.sol And ConvexStakingWrapper.sol Then It Will Be Possible To Continue Claiming Concur Rewards After The Shelter Has Been Activated M-23: Transfer to treasury can register as succeeded when failing in _calcRewardIntegral. L126 M-26: StakingRewards.setRewardsDuration allows setting near zero or enormous rewardsDuration, which breaks reward logic M-30: StakingRewards reward rate can be dragged out and diluted",8
28_PostAuctionLauncher.sol,"pragma solidity 0.6.12;


//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's Post Auction Launcher
//
// A post auction contract that takes the proceeds and creates a liquidity pool
//
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

import ""../OpenZeppelin/utils/ReentrancyGuard.sol"";
import ""../Access/MISOAccessControls.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""../Utils/BoringMath.sol"";
import ""../UniswapV2/UniswapV2Library.sol"";
import ""../UniswapV2/interfaces/IUniswapV2Pair.sol"";
import ""../UniswapV2/interfaces/IUniswapV2Factory.sol"";
import ""../interfaces/IWETH9.sol"";
import ""../interfaces/IERC20.sol"";
import ""../interfaces/IMisoAuction.sol"";



contract PostAuctionLauncher is MISOAccessControls, SafeTransfer, ReentrancyGuard {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;
    using BoringMath32 for uint32;
    using BoringMath16 for uint16;


    /// @notice Number of seconds per day.
    uint256 private constant SECONDS_PER_DAY = 24 * 60 * 60;
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant LIQUIDITY_PRECISION = 10000;
    
    /// @notice MISOLiquidity template id.
    uint256 public constant liquidityTemplate = 3;

    /// @notice First Token address.
    IERC20 public token1;
    /// @notice Second Token address.
    IERC20 public token2;
    /// @notice Uniswap V2 factory address.
    IUniswapV2Factory public factory;
    /// @notice WETH contract address.
    address private immutable weth;


    /// @notice LP pair address.
    address public tokenPair;
    /// @notice Withdraw wallet address.
    address public wallet;
    /// @notice Token market contract address.
    IMisoAuction public market;

    struct LauncherInfo {
        uint32 locktime;
        uint64 unlock;
        uint16 liquidityPercent;
        bool launched;
        uint128 liquidityAdded;
    }
    LauncherInfo public launcherInfo;

    /// @notice Emitted when LP contract is initialised.
    event InitLiquidityLauncher(address indexed token1, address indexed token2, address factory, address sender);
    /// @notice Emitted when LP is launched.
    event LiquidityAdded(uint256 liquidity);
    /// @notice Emitted when wallet is updated.
    event WalletUpdated(address indexed wallet);
    /// @notice Emitted when launcher is cancelled.
    event LauncherCancelled(address indexed wallet);

    constructor (address _weth) public {
        weth = _weth;
    }


    /**
     * @notice Initializes main contract variables (requires launchwindow to be more than 2 days.)
     * @param _market Auction address for launcher.
     * @param _factory Uniswap V2 factory address.
     * @param _admin Contract owner address.
     * @param _wallet Withdraw wallet address.
     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.
     * @param _locktime How long the liquidity will be locked. Number of seconds.
     */
    function initAuctionLauncher(
            address _market,
            address _factory,
            address _admin,
            address _wallet,
            uint256 _liquidityPercent,
            uint256 _locktime
    )
        public
    {
        require(_locktime < 10000000000, 'PostAuction: Enter an unix timestamp in seconds, not miliseconds');
        require(_liquidityPercent <= LIQUIDITY_PRECISION, 'PostAuction: Liquidity percentage greater than 100.00% (>10000)');
        require(_liquidityPercent > 0, 'PostAuction: Liquidity percentage equals zero');
        require(_admin != address(0), ""PostAuction: admin is the zero address"");
        require(_wallet != address(0), ""PostAuction: wallet is the zero address"");

        initAccessControls(_admin);

        market = IMisoAuction(_market);
        token1 = IERC20(market.paymentCurrency());
        token2 = IERC20(market.auctionToken());

        if (address(token1) == ETH_ADDRESS) {
            token1 = IERC20(weth);
        }

        uint256 d1 = uint256(token1.decimals());
        uint256 d2 = uint256(token2.decimals());
        require(d2 >= d1);

        factory = IUniswapV2Factory(_factory);
        bytes32 pairCodeHash = IUniswapV2Factory(_factory).pairCodeHash();
        tokenPair = UniswapV2Library.pairFor(_factory, address(token1), address(token2), pairCodeHash);
   
        wallet = _wallet;
        launcherInfo.liquidityPercent = BoringMath.to16(_liquidityPercent);
        launcherInfo.locktime = BoringMath.to32(_locktime);

        uint256 initalTokenAmount = market.getTotalTokens().mul(_liquidityPercent).div(LIQUIDITY_PRECISION);
        _safeTransferFrom(address(token2), msg.sender, initalTokenAmount);

        emit InitLiquidityLauncher(address(token1), address(token2), address(_factory), _admin);
    }

    receive() external payable {
        if(msg.sender != weth ){
             depositETH();
        }
    }

    /// @notice Deposits ETH to the contract.
    function depositETH() public payable {
        require(address(token1) == weth || address(token2) == weth, ""PostAuction: Launcher not accepting ETH"");
        if (msg.value > 0 ) {
            IWETH(weth).deposit{value : msg.value}();
        }
    }

    /**
     * @notice Deposits first Token to the contract.
     * @param _amount Number of tokens to deposit.
     */
    function depositToken1(uint256 _amount) external returns (bool success) {
        return _deposit( address(token1), msg.sender, _amount);
    }

    /**
     * @notice Deposits second Token to the contract.
     * @param _amount Number of tokens to deposit.
     */
    function depositToken2(uint256 _amount) external returns (bool success) {
        return _deposit( address(token2), msg.sender, _amount);
    }

    /**
     * @notice Deposits Tokens to the contract.
     * @param _amount Number of tokens to deposit.
     * @param _from Where the tokens to deposit will come from.
     * @param _token Token address.
     */
    function _deposit(address _token, address _from, uint _amount) internal returns (bool success) {
        require(!launcherInfo.launched, ""PostAuction: Must first launch liquidity"");
        require(launcherInfo.liquidityAdded == 0, ""PostAuction: Liquidity already added"");

        require(_amount > 0, ""PostAuction: Token amount must be greater than 0"");
        _safeTransferFrom(_token, _from, _amount);
        return true;
    }


    /**
     * @notice Checks if market wallet is set to this launcher
     */
    function marketConnected() public view returns (bool)  {
        return market.wallet() == address(this);
    }

    /**
     * @notice Finalizes Token sale and launches LP.
     * @return liquidity Number of LPs.
     */
    function finalize() external nonReentrant returns (uint256 liquidity) {
        // GP: Can we remove admin, let anyone can finalise and launch?
        // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), ""PostAuction: Sender must be operator"");
        require(marketConnected(), ""PostAuction: Auction must have this launcher address set as the destination wallet"");
        require(!launcherInfo.launched);

        if (!market.finalized()) {
            market.finalize();
        }
        require(market.finalized());

        launcherInfo.launched = true;
        if (!market.auctionSuccessful() ) {
            return 0;
        }

        /// @dev if the auction is settled in weth, wrap any contract balance 
        uint256 launcherBalance = address(this).balance;
        if (launcherBalance > 0 ) {
            IWETH(weth).deposit{value : launcherBalance}();
        }
        
        (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();

        /// @dev cannot start a liquidity pool with no tokens on either side
        if (token1Amount == 0 || token2Amount == 0 ) {
            return 0;
        }

        address pair = factory.getPair(address(token1), address(token2));
        if(pair == address(0)) {
            createPool();
        }

        /// @dev add liquidity to pool via the pair directly
        _safeTransfer(address(token1), tokenPair, token1Amount);
        _safeTransfer(address(token2), tokenPair, token2Amount);
        liquidity = IUniswapV2Pair(tokenPair).mint(address(this));
        launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));

        /// @dev if unlock time not yet set, add it.
        if (launcherInfo.unlock == 0 ) {
            launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));
        }
        emit LiquidityAdded(liquidity);
    }


    function getTokenAmounts() public view returns (uint256 token1Amount, uint256 token2Amount) {
        token1Amount = getToken1Balance().mul(uint256(launcherInfo.liquidityPercent)).div(LIQUIDITY_PRECISION);
        token2Amount = getToken2Balance(); 

        uint256 tokenPrice = market.tokenPrice();  
        uint256 d2 = uint256(token2.decimals());
        uint256 maxToken1Amount = token2Amount.mul(tokenPrice).div(10**(d2));
        uint256 maxToken2Amount = token1Amount
                                    .mul(10**(d2))
                                    .div(tokenPrice);

        /// @dev if more than the max.
        if (token2Amount > maxToken2Amount) {
            token2Amount =  maxToken2Amount;
        } 
        /// @dev if more than the max.
        if (token1Amount > maxToken1Amount) {
            token1Amount =  maxToken1Amount;
        }

    }

    /**
     * @notice Withdraws LPs from the contract.
     * @return liquidity Number of LPs.
     */
    function withdrawLPTokens() external returns (uint256 liquidity) {
        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), ""PostAuction: Sender must be operator"");
        require(launcherInfo.launched, ""PostAuction: Must first launch liquidity"");
        require(block.timestamp >= uint256(launcherInfo.unlock), ""PostAuction: Liquidity is locked"");
        liquidity = IERC20(tokenPair).balanceOf(address(this));
        require(liquidity > 0, ""PostAuction: Liquidity must be greater than 0"");
        _safeTransfer(tokenPair, wallet, liquidity);
    }

    /// @notice Withraws deposited tokens and ETH from the contract to wallet.
    function withdrawDeposits() external {
        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), ""PostAuction: Sender must be operator"");
        require(launcherInfo.launched, ""PostAuction: Must first launch liquidity"");

        uint256 token1Amount = getToken1Balance();
        if (token1Amount > 0 ) {
            _safeTransfer(address(token1), wallet, token1Amount);
        }
        uint256 token2Amount = getToken2Balance();
        if (token2Amount > 0 ) {
            _safeTransfer(address(token2), wallet, token2Amount);
        }
    }

    // TODO     
    // GP: Sweep non relevant ERC20s / ETH


    //--------------------------------------------------------
    // Setter functions
    //--------------------------------------------------------


    /**
     * @notice Admin can set the wallet through this function.
     * @param _wallet Wallet is where funds will be sent.
     */
    function setWallet(address payable _wallet) external {
        require(hasAdminRole(msg.sender));
        require(_wallet != address(0), ""Wallet is the zero address"");

        wallet = _wallet;

        emit WalletUpdated(_wallet);
    }

    function cancelLauncher() external {
        require(hasAdminRole(msg.sender));
        require(!launcherInfo.launched);

        launcherInfo.launched = true;
        emit LauncherCancelled(msg.sender);

    }

    //--------------------------------------------------------
    // Helper functions
    //--------------------------------------------------------

    /**
     * @notice Creates new SLP pair through SushiSwap.
     */
    function createPool() public {
        factory.createPair(address(token1), address(token2));
    }

    //--------------------------------------------------------
    // Getter functions
    //--------------------------------------------------------

    /**
     * @notice Gets the number of first token deposited into this contract.
     * @return uint256 Number of WETH.
     */
    function getToken1Balance() public view returns (uint256) {
         return token1.balanceOf(address(this));
    }

    /**
     * @notice Gets the number of second token deposited into this contract.
     * @return uint256 Number of WETH.
     */
    function getToken2Balance() public view returns (uint256) {
         return token2.balanceOf(address(this));
    }

    /**
     * @notice Returns LP token address..
     * @return address LP address.
     */
    function getLPTokenAddress() public view returns (address) {
        return tokenPair;
    }
    /**
     * @notice Returns LP Token balance.
     * @return uint256 LP Token balance.
     */
    function getLPBalance() public view returns (uint256) {
         return IERC20(tokenPair).balanceOf(address(this));
    }


    //--------------------------------------------------------
    // Init functions
    //--------------------------------------------------------


    /**
     * @notice Decodes and hands auction data to the initAuction function.
     * @param _data Encoded data for initialization.
     */

    function init(bytes calldata _data) external payable {

    }

    function initLauncher(
        bytes calldata _data
    ) public {
        (
            address _market,
            address _factory,
            address _admin,
            address _wallet,
            uint256 _liquidityPercent,
            uint256 _locktime
        ) = abi.decode(_data, (
            address,
            address,
            address,
            address,
            uint256,
            uint256
        ));
        initAuctionLauncher( _market, _factory,_admin,_wallet,_liquidityPercent,_locktime);
    }

    /**
     * @notice Collects data to initialize the auction and encodes them.
     * @param _market Auction address for launcher.
     * @param _factory Uniswap V2 factory address.
     * @param _admin Contract owner address.
     * @param _wallet Withdraw wallet address.
     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.
     * @param _locktime How long the liquidity will be locked. Number of seconds.
     * @return _data All the data in bytes format.
     */
    function getLauncherInitData(
            address _market,
            address _factory,
            address _admin,
            address _wallet,
            uint256 _liquidityPercent,
            uint256 _locktime
    )
        external 
        pure
        returns (bytes memory _data)
    {
            return abi.encode(_market,
                                _factory,
                                _admin,
                                _wallet,
                                _liquidityPercent,
                                _locktime
            );
    }

}",3728,463,H-01: PostAuctionLauncher.sol#finalize() Adding liquidity to an existing pool may allows the attacker to steal most of the tokens. L257,1
39_VaultTracker.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

import ""./Abstracts.sol"";

contract VaultTracker {
  struct Vault {
    uint256 notional;
    uint256 redeemable;
    uint256 exchangeRate;
  }

  mapping(address => Vault) public vaults;

  address public immutable admin;
  address public immutable cTokenAddr;
  address public immutable swivel;
  bool public matured;
  uint256 public immutable maturity;
  uint256 public maturityRate;

  /// @param m Maturity timestamp of the new market
  /// @param c cToken address associated with underlying for the new market
  /// @param s address of the deployed swivel contract
  constructor(uint256 m, address c, address s) {
    admin = msg.sender;
    maturity = m;
    cTokenAddr = c;
    swivel = s;
  }

  /// @notice Adds notional (nTokens) to a given user's vault
  /// @param o Address that owns a vault
  /// @param a Amount of notional added
  function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    Vault memory vlt = vaults[o];

    if (vlt.notional > 0) {
      uint256 yield;
      uint256 interest;

      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
      // otherwise, calculate marginal exchange rate between current and previous exchange rate.
      if (matured) { 
        // Calculate marginal interest
        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
      } else {
        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
      }

      interest = (yield * vlt.notional) / 1e26;
      // add interest and amount to position, reset cToken exchange rate
      vlt.redeemable += interest;
      vlt.notional += a;
    } else {
      vlt.notional = a;
    }

    vlt.exchangeRate = exchangeRate;
    vaults[o] = vlt;

    return true;
  }

  /// @notice Removes notional (nTokens) from a given user's vault
  /// @param o Address that owns a vault
  /// @param a Amount of notional to remove
  function removeNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {

    Vault memory vlt = vaults[o];

    require(vlt.notional >= a, ""amount exceeds vault balance"");

    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { 
      // Calculate marginal interest
      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
    } else {
      // calculate marginal interest
      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
    }

    interest = (yield * vlt.notional) / 1e26;
    // remove amount from position, Add interest to position, reset cToken exchange rate
    vlt.redeemable += interest;
    vlt.notional -= a;
    vlt.exchangeRate = exchangeRate;

    vaults[o] = vlt;

    return true;
  }

  /// @notice Redeem's the `redeemable` + marginal interest from a given user's vault
  /// @param o Address that owns a vault
  function redeemInterest(address o) external onlyAdmin(admin) returns (uint256) {

    Vault memory vlt = vaults[o];

    uint256 redeemable = vlt.redeemable;
    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { 
      // Calculate marginal interest
      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
    } else {
      // calculate marginal interest
      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
    }

    interest = (yield * vlt.notional) / 1e26;

    vlt.exchangeRate = exchangeRate;
    vlt.redeemable = 0;

    vaults[o] = vlt;

    // return adds marginal interest to previously accrued redeemable interest
    return (redeemable + interest);
  }

  /// @notice Matures the vault and sets the market's maturityRate
  function matureVault() external onlyAdmin(admin) returns (bool) {
    require(!matured, 'already matured');
    require(block.timestamp >= maturity, 'maturity has not been reached');
    matured = true;
    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();
    return true;
  }

  /// @notice Transfers notional (nTokens) from one user to another
  /// @param f Owner of the amount
  /// @param t Recipient of the amount
  /// @param a Amount to transfer
  function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {
    Vault memory from = vaults[f];
    Vault memory to = vaults[t];

    require(from.notional >= a, ""amount exceeds available balance"");

    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { 
      // calculate marginal interest
      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;
    } else {
      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;
    }

    interest = (yield * from.notional) / 1e26;
    // remove amount from position, Add interest to position, reset cToken exchange rate
    from.redeemable += interest;
    from.notional -= a;
    from.exchangeRate = exchangeRate;

    vaults[f] = from;

    // transfer notional to address ""t"", calculate interest if necessary
    if (to.notional > 0) {
      uint256 newVaultInterest;

      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
      // otherwise, calculate marginal exchange rate between current and previous exchange rate.
      if (matured) { 
        // calculate marginal interest
        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;
      } else {
        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;
      }

      newVaultInterest = (yield * to.notional) / 1e26;
      // add interest and amount to position, reset cToken exchange rate
      to.redeemable += newVaultInterest;
      to.notional += a;
    } else {
      to.notional += a;
    }

    to.exchangeRate = exchangeRate;
    vaults[t] = to;

    return true;
  }

  /// @notice transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner
  /// @param f Owner of the amount
  /// @param a Amount to transfer
  function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {
    Vault memory oVault = vaults[f];
    Vault memory sVault = vaults[swivel];

    // remove notional from its owner
    oVault.notional -= a;

    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();
    uint256 yield;
    uint256 interest;

    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate
    if (sVault.exchangeRate != exchangeRate) {
      // the rate will be 0 if swivel did not already have a vault
      if (sVault.exchangeRate != 0) {
        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
        // otherwise, calculate marginal exchange rate between current and previous exchange rate.
        if (matured) { 
          // calculate marginal interest
            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;
        } else {
            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;
        }

        interest = (yield * sVault.notional) / 1e26;
        // add interest and amount, reset cToken exchange rate
        sVault.redeemable += interest;
      }
      sVault.exchangeRate = exchangeRate;
    }

    // add notional to swivel's vault
    sVault.notional += a;

    // store the adjusted vaults
    vaults[swivel] = sVault;
    vaults[f] = oVault;
    return true;
  }

  /// @notice Returns both relevant balances for a given user's vault
  /// @param o Address that owns a vault
  function balancesOf(address o) public view returns (uint256, uint256) {
    return (vaults[o].notional, vaults[o].redeemable);
  }

  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }
}",2192,255,"H-03: transferNotionalFrom doesn't check from != to.  L144-196 M-01: Admin is a single-point of failure without any mitigations. L27 M-02: Missing event & timelock for critical onlyAdmin functions. L36 L70 L102 L132 L144 L201",3
104_CoreCollection.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    // ----------------- MODIFIER -----------------

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    // ----------------- EXTERNAL -----------------

    /**
     * @notice Initializes the collection
     * @dev This method is being called from the CoreFactory contract
     * @param _collectionName Name of the collection
     * @param _collectionSymbol Symbol of the collection
     * @param _collectionURI Base URI for the collection
     * @param _maxSupply The maximum number of tokens that can be minted
     * @param _mintFee The price of a token in this collection
     * @param _payableToken The address of the ERC20 this collection uses to settle transactions
     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed
     * @param _splitFactory base URI for the collection
     */
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    /**
     * @notice Allows the collection owner to airdrop tokens
     * @dev The Merkle tree defines for each address how much token can be claimed
     * @dev This method can only be called once
     * @param _root A Merkle root
     */
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    /**
     * @notice Allows the collection owner to change the collection's name and symbol
     * @dev This function is only callable by the collection's owner
     * @param _collectionName A collection name
     * @param _collectionSymbol A collection symbol
     */
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    /**
     * @notice This function is called to mint tokens from this ERC721 collection
     * @dev The collection must be initialized first
     * @param to Token recipient
     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token
     * @param claimableAmount The amount of tokens the user has been airdropped
     * @param amount The amount of tokens the user wants to mint
     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token
     */
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    /**
     * @notice Allows the contract owner to withdraw the funds generated by the token sales
     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner
     */
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    /**
     * @notice Set royalty vault address for collection
     * @dev All revenue (Primary sales + royalties from secondardy sales) 
     * from the collection are transferred to the vault when the vault is initialized
     * @param _royaltyVault The address of the royalty vault
     */
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    /**
     * @notice Set a provenance hash
     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)
     * This hash is generated off-chain
     * @param _proof The SHA256 generated hash
     */
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    // ----------------- PUBLIC -----------------

    /**
     * @notice Set the mint starting index
     * @dev The starting index can only be generated once
     */
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    // ---------------- VIEW ----------------

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    // ---------------- PRIVATE ----------------

    /**
     * @notice Mint token
     * @dev A starting index is calculated at the time of first mint
     * returns a tokenId
     * @param _to Token recipient
     */
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    /**
     * @notice Mint tokens in batch
     * @param _to Token recipient
     * @param _amount Number of tokens to include in batch
     * @param _isClaim Whether the batch mint is an airdrop or not
     */
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    // ---------------- INTERNAL ----------------

    /**
     * @notice This hook transfers tokens sitting in the royalty vault to the split contract
     * @dev The split contract is a contract that allows a team to share revenue together
     * @param _from Transfer sender
     * @param _to Transfer recipient
     * @param _tokenId TokenId of token being transferred
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",2331,311,"H-04: CoreCollection can be reinitialized. L87 H-07: Duplicate NFTs Can Be Minted if payableToken Has a Callback Attached to it.  L139-L167 H-08: Funds cannot be withdrawn in CoreCollection.withdraw.  M-03: RoyaltyVault.sol is Not Equipped to Handle On-Chain Royalties From Secondary Sales M-05: Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover. M-06: CoreCollection's token transfer can be disabled M-11: Not handling return value of transferFrom command can create inconsistency. L175 M-12: CoreCollection.setRoyaltyVault doesn't check royaltyVault.royaltyAsset against payableToken, resulting in potential permanent lock of payableTokens in royaltyVault",8
12_Cauldron.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;
import ""./interfaces/vault/IFYToken.sol"";
import ""./interfaces/vault/IOracle.sol"";
import ""./interfaces/vault/DataTypes.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./math/WMul.sol"";
import ""./math/WDiv.sol"";
import ""./math/CastU128I128.sol"";
import ""./math/CastI128U128.sol"";
import ""./math/CastU256U32.sol"";
import ""./math/CastU256I256.sol"";

library CauldronMath {
    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.
    function add(uint128 x, int128 y) internal pure returns (uint128 z) {
        require (y > 0 || x >= uint128(-y), ""Result below zero"");
        z = y > 0 ? x + uint128(y) : x - uint128(-y);
    }
}


contract Cauldron is AccessControl() {
    using CauldronMath for uint128;
    using WMul for uint256;
    using WDiv for uint256;
    using CastU128I128 for uint128;
    using CastU256U32 for uint256;
    using CastU256I256 for uint256;
    using CastI128U128 for int128;

    event AuctionIntervalSet(uint32 indexed auctionInterval);
    event AssetAdded(bytes6 indexed assetId, address indexed asset);
    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);
    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);
    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);
    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);
    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);

    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);
    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);
    event VaultDestroyed(bytes12 indexed vaultId);
    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);

    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);
    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);
    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);
    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);

    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);

    // ==== Configuration data ====
    mapping (bytes6 => address)                                 public assets;         
    mapping (bytes6 => DataTypes.Series)                        public series;          
    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            

    mapping (bytes6 => IOracle)                                 public rateOracles;     
    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     

    // ==== Protocol data ====
    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            
    mapping (bytes6 => uint256)                                 public ratesAtMaturity; 
    uint32                                                      public auctionInterval;

    // ==== User data ====
    mapping (bytes12 => DataTypes.Vault)                        public vaults;          
    mapping (bytes12 => DataTypes.Balances)                     public balances;        
    mapping (bytes12 => uint32)                                 public auctions;        

    // ==== Administration ====

    /// @dev Add a new Asset.
    function addAsset(bytes6 assetId, address asset)
        external
        auth
    {
        require (assetId != bytes6(0), ""Asset id is zero"");
        require (assets[assetId] == address(0), ""Id already used"");
        assets[assetId] = asset;
        emit AssetAdded(assetId, address(asset));
    }

    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.
    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)
        external
        auth
    {
        require (assets[baseId] != address(0), ""Base not found"");
        require (assets[ilkId] != address(0), ""Ilk not found"");
        DataTypes.Debt memory debt_ = debt[baseId][ilkId];
        debt_.max = max;
        debt_.min = min;
        debt_.dec = dec;
        debt[baseId][ilkId] = debt_;
        emit DebtLimitsSet(baseId, ilkId, max, min, dec);
    }

    /// @dev Set a rate oracle. Can be reset.
    function setRateOracle(bytes6 baseId, IOracle oracle)
        external
        auth
    {
        require (assets[baseId] != address(0), ""Base not found"");
        rateOracles[baseId] = oracle;
        emit RateOracleAdded(baseId, address(oracle));
    }

    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine
    function setAuctionInterval(uint32 auctionInterval_)
        external
        auth
    {
        auctionInterval = auctionInterval_;
        emit AuctionIntervalSet(auctionInterval_);
    }

    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.
    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)
        external
        auth
    {
        require (assets[baseId] != address(0), ""Base not found"");
        require (assets[ilkId] != address(0), ""Ilk not found"");
        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({
            oracle: oracle,
            ratio: ratio                                                                    
        });                                                                                 
        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);
    }

    /// @dev Add a new series
    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)
        external
        auth
    {
        require (seriesId != bytes6(0), ""Series id is zero"");
        address base = assets[baseId];
        require (base != address(0), ""Base not found"");
        require (fyToken != IFYToken(address(0)), ""Series need a fyToken"");
        require (fyToken.underlying() == base, ""Mismatched series and base"");
        require (rateOracles[baseId] != IOracle(address(0)), ""Rate oracle not found"");
        require (series[seriesId].fyToken == IFYToken(address(0)), ""Id already used"");
        series[seriesId] = DataTypes.Series({
            fyToken: fyToken,
            maturity: fyToken.maturity().u32(),
            baseId: baseId
        });
        emit SeriesAdded(seriesId, baseId, address(fyToken));
    }

    /// @dev Add a new Ilk (approve an asset as collateral for a series).
    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)
        external
        auth
    {
        DataTypes.Series memory series_ = series[seriesId];
        require (
            series_.fyToken != IFYToken(address(0)),
            ""Series not found""
        );
        for (uint256 i = 0; i < ilkIds.length; i++) {
            require (
                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),
                ""Spot oracle not found""
            );
            ilks[seriesId][ilkIds[i]] = true;
            emit IlkAdded(seriesId, ilkIds[i]);
        }
    }

    // ==== Vault management ====

    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral
    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)
        external
        auth
        returns(DataTypes.Vault memory vault)
    {
        require (vaultId != bytes12(0), ""Vault id is zero"");
        require (vaults[vaultId].seriesId == bytes6(0), ""Vault already exists"");   
        require (ilks[seriesId][ilkId] == true, ""Ilk not added to series"");
        vault = DataTypes.Vault({
            owner: owner,
            seriesId: seriesId,
            ilkId: ilkId
        });
        vaults[vaultId] = vault;

        emit VaultBuilt(vaultId, owner, seriesId, ilkId);
    }

    /// @dev Destroy an empty vault. Used to recover gas costs.
    function destroy(bytes12 vaultId)
        external
        auth
    {
        DataTypes.Balances memory balances_ = balances[vaultId];
        require (balances_.art == 0 && balances_.ink == 0, ""Only empty vaults"");
        delete auctions[vaultId];
        delete vaults[vaultId];
        emit VaultDestroyed(vaultId);
    }

    /// @dev Change a vault series and/or collateral types.
    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)
        internal
    {
        require (ilks[vault.seriesId][vault.ilkId] == true, ""Ilk not added to series"");

        vaults[vaultId] = vault;
        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);
    }

    /// @dev Change a vault series and/or collateral types.
    /// We can change the series if there is no debt, or assets if there are no assets
    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)
        external
        auth
        returns(DataTypes.Vault memory vault)
    {
        DataTypes.Balances memory balances_ = balances[vaultId];
        vault = vaults[vaultId];
        if (seriesId != vault.seriesId) {
            require (balances_.art == 0, ""Only with no debt"");
            vault.seriesId = seriesId;
        }
        if (ilkId != vault.ilkId) {
            require (balances_.ink == 0, ""Only with no collateral"");
            vault.ilkId = ilkId;
        }
        _tweak(vaultId, vault);
    }

    /// @dev Transfer a vault to another user.
    function _give(bytes12 vaultId, address receiver)
        internal
        returns(DataTypes.Vault memory vault)
    {
        vault = vaults[vaultId];
        vault.owner = receiver;
        vaults[vaultId] = vault;
        emit VaultGiven(vaultId, receiver);
    }

    /// @dev Transfer a vault to another user.
    function give(bytes12 vaultId, address receiver)
        external
        auth
        returns(DataTypes.Vault memory vault)
    {
        vault = _give(vaultId, receiver);
    }

    // ==== Asset and debt management ====

    function vaultData(bytes12 vaultId, bool getSeries)
        internal
        view
        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)
    {
        vault_ = vaults[vaultId];
        require (vault_.seriesId != bytes6(0), ""Vault not found"");
        if (getSeries) series_ = series[vault_.seriesId];
        balances_ = balances[vaultId];
    }

    /// @dev Move collateral and debt between vaults.
    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)
        external
        auth
        returns (DataTypes.Balances memory, DataTypes.Balances memory)
    {
        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);
        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);

        if (ink > 0) {
            require (vaultFrom.ilkId == vaultTo.ilkId, ""Different collateral"");
            balancesFrom.ink -= ink;
            balancesTo.ink += ink;
        }
        if (art > 0) {
            require (vaultFrom.seriesId == vaultTo.seriesId, ""Different series"");
            balancesFrom.art -= art;
            balancesTo.art += art;
        }

        balances[from] = balancesFrom;
        balances[to] = balancesTo;

        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, ""Undercollateralized at origin"");
        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, ""Undercollateralized at destination"");

        emit VaultStirred(from, to, ink, art);
        return (balancesFrom, balancesTo);
    }

    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user
    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user
    function _pour(
        bytes12 vaultId,
        DataTypes.Vault memory vault_,
        DataTypes.Balances memory balances_,
        DataTypes.Series memory series_,
        int128 ink,
        int128 art
    )
        internal returns (DataTypes.Balances memory)
    {
        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.
        if (ink != 0) {
            balances_.ink = balances_.ink.add(ink);
        }

        // Modify vault and global debt records. If debt increases, check global limit.
        if (art != 0) {
            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];
            balances_.art = balances_.art.add(art);
            debt_.sum = debt_.sum.add(art);
            uint128 dust = debt_.min * uint128(10) ** debt_.dec;
            uint128 line = debt_.max * uint128(10) ** debt_.dec;
            require (balances_.art == 0 || balances_.art >= dust, ""Min debt not reached"");
            if (art > 0) require (debt_.sum <= line, ""Max debt exceeded"");
            debt[series_.baseId][vault_.ilkId] = debt_;
        }
        balances[vaultId] = balances_;

        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);
        return balances_;
    }

    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.
    /// To be used by debt management contracts.
    function pour(bytes12 vaultId, int128 ink, int128 art)
        external
        auth
        returns (DataTypes.Balances memory)
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);

        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);

        if (balances_.art > 0 && (ink < 0 || art > 0))                          
            require(_level(vault_, balances_, series_) >= 0, ""Undercollateralized"");
        return balances_;
    }

    /// @dev Give a non-timestamped vault to another user, and timestamp it.
    /// To be used for liquidation engines.
    function grab(bytes12 vaultId, address receiver)
        external
        auth
    {
        uint32 now_ = uint32(block.timestamp);
        require (auctions[vaultId] + auctionInterval <= now_, ""Vault under auction"");       

        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);
        require(_level(vault_, balances_, series_) < 0, ""Not undercollateralized"");

        auctions[vaultId] = now_;
        _give(vaultId, receiver);

        emit VaultLocked(vaultId, now_);
    }

    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.
    /// To be used by liquidation engines.
    function slurp(bytes12 vaultId, uint128 ink, uint128 art)
        external
        auth
        returns (DataTypes.Balances memory)
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);

        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));

        return balances_;
    }

    /// @dev Change series and debt of a vault.
    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.
    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)
        external
        auth
        returns (DataTypes.Vault memory, DataTypes.Balances memory)
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);
        DataTypes.Series memory newSeries_ = series[newSeriesId];
        require (oldSeries_.baseId == newSeries_.baseId, ""Mismatched bases in series"");
        
        // Change the vault series
        vault_.seriesId = newSeriesId;
        _tweak(vaultId, vault_);

        // Change the vault balances
        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);

        require(_level(vault_, balances_, newSeries_) >= 0, ""Undercollateralized"");
        emit VaultRolled(vaultId, newSeriesId, balances_.art);

        return (vault_, balances_);
    }

    // ==== Accounting ====

    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.
    function level(bytes12 vaultId) public returns (int256) {
        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);

        return _level(vault_, balances_, series_);
    }

    /// @dev Record the borrowing rate at maturity for a series
    function mature(bytes6 seriesId)
        public
    {
        DataTypes.Series memory series_ = series[seriesId];
        require (uint32(block.timestamp) >= series_.maturity, ""Only after maturity"");
        require (ratesAtMaturity[seriesId] == 0, ""Already matured"");
        _mature(seriesId, series_);
    }

    /// @dev Record the borrowing rate at maturity for a series
    function _mature(bytes6 seriesId, DataTypes.Series memory series_)
        internal
    {
        IOracle rateOracle = rateOracles[series_.baseId];
        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(""rate""), 1e18);
        ratesAtMaturity[seriesId] = rateAtMaturity;
        emit SeriesMatured(seriesId, rateAtMaturity);
    }
    

    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.
    function accrual(bytes6 seriesId)
        public
        returns (uint256)
    {
        DataTypes.Series memory series_ = series[seriesId];
        require (uint32(block.timestamp) >= series_.maturity, ""Only after maturity"");
        return _accrual(seriesId, series_);
    }

    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.
    /// Note: Call only after checking we are past maturity
    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)
        private
        returns (uint256 accrual_)
    {
        uint256 rateAtMaturity = ratesAtMaturity[seriesId];
        if (rateAtMaturity == 0) {  
            _mature(seriesId, series_);
        } else {
            IOracle rateOracle = rateOracles[series_.baseId];
            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(""rate""), 1e18);
            accrual_ = rate.wdiv(rateAtMaturity);
        }
        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     
    }

    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.
    function _level(
        DataTypes.Vault memory vault_,
        DataTypes.Balances memory balances_,
        DataTypes.Series memory series_
    )
        internal
        returns (int256)
    {
        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];
        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   
        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    

        if (uint32(block.timestamp) >= series_.maturity) {
            uint256 accrual_ = _accrual(vault_.seriesId, series_);
            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();
        }

        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();
    }
}",4632,480,"M-01: Potential griefing with DoS by front-running vault creation with same vaultID.  L180 M-03: Witch can't give back vault after 2x grab M-08: Users can avoid paying borrowing interest after the fyToken matures",3
5_Vether.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iVETHER.sol"";

// Token Contract
contract Vether is iVETHER {

    // Coin Defaults
    string public override name;                                        
    string public override symbol;                                     
    uint public override decimals  = 18;                              
    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   

    uint public totalFees;
    mapping(address=>bool) public mapAddress_Excluded;  

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    
    // Minting event
    constructor() {
        name = ""Vether"";
        symbol  = ""VETH"";
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""iERC20: approve from the zero address"");
        require(spender != address(0), ""iERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

       // Internal transfer function which includes the Fee
    function _transfer(address _from, address _to, uint _value) private {
        require(_balances[_from] >= _value, 'Must not send more than balance');
        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');
        _balances[_from] -= _value;
        uint _fee = _getFee(_from, _to, _value);                                           
        _balances[_to] += (_value - _fee);                                             
        _balances[address(this)] += _fee;                                                   
        totalFees += _fee;                                                                 
        emit Transfer(_from, _to, (_value - _fee));                                      
        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {
            emit Transfer(_from, address(this), _fee);                                      
        }
    }
    
    // Calculate Fee amount
    function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                       
        } else {
            return (_value / 1000);                                                       
        }
    }

    function addExcluded(address excluded) public {
        mapAddress_Excluded[excluded] = true;
    }
}",862,96,H-21: Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List.,1
5_DAO.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iVAULT.sol"";
import ""./interfaces/iROUTER.sol"";

    //======================================VADER=========================================//
contract DAO {

    struct GrantDetails{
        address recipient;
        uint amount;
    }

    bool private inited;
    uint public proposalCount;
    address public VADER;
    address public USDV;
    address public VAULT;
    uint public coolOffPeriod;

    mapping(uint => GrantDetails) public mapPID_grant;
    mapping(uint => address) public mapPID_address;

    mapping(uint => string) public mapPID_type;
    mapping(uint => uint) public mapPID_votes;
    mapping(uint => uint) public mapPID_timeStart;
    mapping(uint => bool) public mapPID_finalising;
    mapping(uint => bool) public mapPID_finalised;
    mapping(uint => mapping(address => uint)) public mapPIDMember_votes;

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member,uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed oldProposalID, uint oldVotes, uint newVotes, uint totalWeight);
    event FinalisedProposal(address indexed member,uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
    }
    function init(address _vader, address _usdv, address _vault) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        VAULT = _vault;
        coolOffPeriod = 1;
    }

    //============================== CREATE PROPOSALS ================================//
    // Action with funding
    function newGrantProposal(address recipient, uint amount) public {
        string memory typeStr = ""GRANT"";
        proposalCount += 1;
        mapPID_type[proposalCount] = typeStr;
        GrantDetails memory grant;
        grant.recipient = recipient;
        grant.amount = amount;
        mapPID_grant[proposalCount] = grant;
        emit NewProposal(msg.sender, proposalCount, typeStr);
    }

    // Action with address parameter
    function newAddressProposal(address proposedAddress, string memory typeStr) public {
        proposalCount += 1;
        mapPID_address[proposalCount] = proposedAddress;
        mapPID_type[proposalCount] = typeStr;
        emit NewProposal(msg.sender, proposalCount, typeStr);
    }

//============================== VOTE && FINALISE ================================//

    // Vote for a proposal
    function voteProposal(uint proposalID) public returns (uint voteWeight) {
        bytes memory _type = bytes(mapPID_type[proposalID]);
        voteWeight = countMemberVotes(proposalID);
        if(hasQuorum(proposalID) && mapPID_finalising[proposalID] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'REWARD')){
                if(hasMajority(proposalID)){
                    _finalise(proposalID);
                }
            } else {
                _finalise(proposalID);
            }
        }
        emit NewVote(msg.sender, proposalID, voteWeight, mapPID_votes[proposalID], string(_type));
    }

    function _finalise(uint _proposalID) internal {
        bytes memory _type = bytes(mapPID_type[_proposalID]);
        mapPID_finalising[_proposalID] = true;
        mapPID_timeStart[_proposalID] = block.timestamp;
        emit ProposalFinalising(msg.sender, _proposalID, block.timestamp+coolOffPeriod, string(_type));
    }

    // If an existing proposal, allow a minority to cancel
    function cancelProposal(uint oldProposalID, uint newProposalID) public {
        require(mapPID_finalising[oldProposalID], ""Must be finalising"");
        require(hasMinority(newProposalID), ""Must have minority"");
        require(isEqual(bytes(mapPID_type[oldProposalID]), bytes(mapPID_type[newProposalID])), ""Must be same"");
        mapPID_votes[oldProposalID] = 0;
        emit CancelProposal(msg.sender, oldProposalID, mapPID_votes[oldProposalID], mapPID_votes[newProposalID], iVAULT(VAULT).totalWeight());
    }

    // Proposal with quorum can finalise after cool off period
    function finaliseProposal(uint proposalID) public  {
        require((block.timestamp - mapPID_timeStart[proposalID]) > coolOffPeriod, ""Must be after cool off"");
        require(mapPID_finalising[proposalID] == true, ""Must be finalising"");
        if(!hasQuorum(proposalID)){
            _finalise(proposalID);
        }
        bytes memory _type = bytes(mapPID_type[proposalID]);
        if (isEqual(_type, 'GRANT')){
            grantFunds(proposalID);
        } else if (isEqual(_type, 'UTILS')){
            moveUtils(proposalID);
        } else if (isEqual(_type, 'REWARD')){
            moveRewardAddress(proposalID);
        }
    }

    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID];
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], iVAULT(VAULT).totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0;
        mapPID_finalised[_proposalID] = true;
        mapPID_finalising[_proposalID] = false;
    }

//============================== BUSINESS LOGIC ================================//

    function grantFunds(uint _proposalID) internal {
        GrantDetails memory _grant = mapPID_grant[_proposalID];
        require(_grant.amount <= iERC20(USDV).balanceOf(VAULT) / 10, ""Not more than 10%"");
        completeProposal(_proposalID);
        iVAULT(VAULT).grant(_grant.recipient, _grant.amount);
    }

    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID];
        require(_proposedAddress != address(0), ""No address proposed"");
        iVADER(VADER).changeUTILS(_proposedAddress);
        completeProposal(_proposalID);
    }
    function moveRewardAddress(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID];
        require(_proposedAddress != address(0), ""No address proposed"");
        iVADER(VADER).setRewardAddress(_proposedAddress);
        completeProposal(_proposalID);
    }
//============================== CONSENSUS ================================//

    function countMemberVotes(uint _proposalID) internal returns (uint voteWeight){
        mapPID_votes[_proposalID] -= mapPIDMember_votes[_proposalID][msg.sender];
        voteWeight = iVAULT(VAULT).getMemberWeight(msg.sender);
        mapPID_votes[_proposalID] += voteWeight;
        mapPIDMember_votes[_proposalID][msg.sender] = voteWeight;
    }

    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID];
        uint consensus = iVAULT(VAULT).totalWeight() / 2; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID];
        uint consensus = iVAULT(VAULT).totalWeight() / 3; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID];
        uint consensus = iVAULT(VAULT).totalWeight() / 6; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }
    function isEqual(bytes memory part1, bytes memory part2) public pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }
    }
    
}",1813,200,"H-04: Proposals can be cancelled H-05: Flash loans can affect governance voting in DAO.sol M-02: Undefined behavior for DAO and GRANT vote proposals in DAO.sol M-13: Init function can be called by everyone",4
38_Identity.sol,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.7;

import ""./libs/SignatureValidatorV2.sol"";

contract Identity {
	mapping (address => bytes32) public privileges;
	// The next allowed nonce
	uint public nonce = 0;

	// Events
	event LogPrivilegeChanged(address indexed addr, bytes32 priv);
	event LogErr(address indexed to, uint value, bytes data, bytes returnData); 
	// only used in tryCatch

	// Transaction structure
	// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig
	struct Transaction {
		address to;
		uint value;
		bytes data;
	}

	constructor(address[] memory addrs) {
		uint len = addrs.length;
		for (uint i=0; i<len; i++) {
			// @TODO should we allow setting to any arb value here?
			privileges[addrs[i]] = bytes32(uint(1));
			emit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));
		}
	}

	// This contract can accept ETH without calldata
	receive() external payable {}

	// This contract can accept ETH with calldata
	// However, to support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature
	fallback() external payable {
		bytes4 method = msg.sig;
		if (
			method == 0x150b7a02 
			// bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""))
				|| method == 0xf23a6e61 
				// bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))
				|| method == 0xbc197c81 
				// bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))
		) {
			// Copy back the method
			// solhint-disable-next-line no-inline-assembly
			assembly {
				calldatacopy(0, 0, 0x04)
				return (0, 0x20)
			}
		}
	}

	function setAddrPrivilege(address addr, bytes32 priv)
		external
	{
		require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');
		// Anti-bricking measure: if the privileges slot is used for special data (not 0x01),
		// don't allow to set it to true
		if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))
			require(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');
		privileges[addr] = priv;
		emit LogPrivilegeChanged(addr, priv);
	}

	function tipMiner(uint amount)
		external
	{
		require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');
		// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract
		// generally this contract is reentrancy proof cause of the nonce
		executeCall(block.coinbase, amount, new bytes(0));
	}

	function tryCatch(address to, uint value, bytes calldata data)
		external
	{
		require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');
		(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);
		if (!success) emit LogErr(to, value, data, returnData);
	}


	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function execute(Transaction[] calldata txns, bytes calldata signature)
		external
	{
		require(txns.length > 0, 'MUST_PASS_TX');
		// If we use the naive abi.encode(txn) and have a field of type `bytes`,
		// there is a discrepancy between ethereumjs-abi and solidity
		// @TODO check if this is resolved
		uint currentNonce = nonce;
		// NOTE: abi.encode is safer than abi.encodePacked in terms of collision safety
		bytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));
		// We have to increment before execution cause it protects from reentrancies
		nonce = currentNonce + 1;

		address signer = SignatureValidator.recoverAddrImpl(hash, signature, true);
		require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');
		uint len = txns.length;
		for (uint i=0; i<len; i++) {
			Transaction memory txn = txns[i];
			executeCall(txn.to, txn.value, txn.data);
		}
		// The actual anti-bricking mechanism - do not allow a signer to drop their own priviledges
		require(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');
	}

	// no need for nonce management here cause we're not dealing with sigs
	function executeBySender(Transaction[] calldata txns) external {
		require(txns.length > 0, 'MUST_PASS_TX');
		require(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');
		uint len = txns.length;
		for (uint i=0; i<len; i++) {
			Transaction memory txn = txns[i];
			executeCall(txn.to, txn.value, txn.data);
		}
		// again, anti-bricking
		require(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');
	}

	// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884
	// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol
	// there's also
	// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce
	// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol
	// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol
	function executeCall(address to, uint256 value, bytes memory data)
		internal
	{
		assembly {
			let result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)

			switch result case 0 {
				let size := returndatasize()
				let ptr := mload(0x40)
				returndatacopy(ptr, 0, size)
				revert(ptr, size)
			}
			default {}
		}
		// A single call consumes around 477 more gas with the pure solidity version, for whatever reason
		//(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);
		//if (!success) revert(string(data));
	}

	// EIP 1271 implementation
	// see https://eips.ethereum.org/EIPS/eip-1271
	function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {
		if (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {
			// bytes4(keccak256(""isValidSignature(bytes32,bytes)"")
			return 0x1626ba7e;
		} else {
			return 0xffffffff;
		}
	}

	// EIP 1155 implementation
	// we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function
	function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
		return
			interfaceID == 0x01ffc9a7 ||    
			// ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).
			interfaceID == 0x4e2312e0;      
			// ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)"")) ^ bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`).
	}
}",1895,171,"H-01: Prevent execution with invalid signatures.  L30, L98",1
43_DelegatedStaking.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

contract DelegatedStaking is OwnableUpgradeable{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    uint256 constant divider = 10**18; 
    // 18 decimals used for scaling the rates
    uint128 validatorCoolDown; 
    // how many epochs until validator unstaking is unlocked
    uint128 delegatorCoolDown; 
    // how many epochs until delegator unstaking is unlocked
    uint128 maxCapMultiplier;
    uint128 validatorMinStakedRequired; 
    // minimum # of tokens validator is required to have staked
    uint128 allocatedTokensPerEpoch; 
    // # of tokens per epoch to be distributed
    uint128 rewardsLocked; 
    // # of tokens the owner sent to the contract
    uint128 endEpoch; 
    // the epoch when the contract will be out of allocated reward tokens
    uint128 totalGlobalShares; 
    // global shares
    uint128 lastUpdateEpoch; 
    // block # when the global exchange rate was updated last
    uint128 globalExchangeRate;
    uint128 validatorsN; 
    // number of validators, used to get validator ids
    mapping(uint128 => Validator) validators; 
    // id -> validator instance
    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);

    struct Staking {
        uint128 staked; 
        // initial CQT amount staked
        uint128 shares; 
        // # of validator shares that delegate owns
    }
    struct Unstaking {
        uint128 coolDownEnd; 
        // epoch when unstaking can be redeemed
        uint128 amount;
    }
    struct Validator {
        address _address;
        address operator;
        uint128 commissionRate; 
        // validator commission rate
        uint128 disabledEpoch; 
        // epoch when validator got disabled, if set to 0, validator is enabled
        uint128 globalShares; 
        // total number of global shares under a validator
        uint128 lastUpdateGlobalRate; 
        // global exchange rate when the validator was updated the last time
        uint128 totalShares; 
        // total number of validator shares
        uint128 delegated; 
        // total number of tokens originally staked/delegated to the validator, this does not include interest
        uint128 exchangeRate; 
        // validator exchange rate
        uint128 commissionAvailableToRedeem; 
        // # of CQTs paid to the validator
        mapping(address => Staking) stakings;
        mapping(address => Unstaking[]) unstakings;
    }
    event RewardTokensDeposited(uint128 amount);
    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);
    event ValidatorDisabled(uint128 indexed id);
    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);
    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event AllocatedTokensTaken(uint128 amount);
    event MaxCapMultiplierChanged(uint128 amount);
    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event EmissionRateChanged(uint128 newRate);
    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);
    event ValidatorMinStakedRequiredChanged(uint128 amount);
    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);

    // this is used to have the contract upgradeable
    function initialize(uint128 minStakedRequired) public initializer {
        __Ownable_init();
        validatorMinStakedRequired = minStakedRequired;
        validatorCoolDown = 180*6646; 
        // ~ 6 months
        delegatorCoolDown = 28*6646; 
        // ~ 28 days
        maxCapMultiplier = 10;
        allocatedTokensPerEpoch = 1*10**18; 
        // should never be 0
        globalExchangeRate = 10**18; 
        // 1 to 1
        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);
    }

    // used to transfer CQT from delegators, validators and the owner to the contract
    function _transferToContract(address from, uint128 amount) internal {
        CQT.safeTransferFrom(from, address(this), amount);
    }

    // used to transfer CQT from contract, for rewards redemption or transferring out unstaked
    function _transferFromContract(address to, uint128 amount) internal {
        CQT.safeTransfer(to, amount);
    }

    // transfer CQT from the owner to the contract for rewards allocation, must change end epoch
    function depositRewardTokens(uint128 amount) public onlyOwner {
        require(amount >= allocatedTokensPerEpoch, ""Does not cover least 1 epoch"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0) {
            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
        }
        else{
            unchecked { rewardsLocked += amount; }
        }
        _transferToContract(msg.sender, amount);
        emit RewardTokensDeposited(amount);
    }

    // transfer reward CQT from the contract to the owner, must change end epoch and not allow transfer from the past
    function takeOutRewardTokens(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0){
            uint128 currentEpoch = uint128(block.number);
            uint128 epochs = amount / allocatedTokensPerEpoch;
            require(endEpoch - epochs > currentEpoch, ""Cannot takeout rewards from past"");
            unchecked { endEpoch = endEpoch - epochs; }
        }
        else{
            require(rewardsLocked >= amount, ""Amount is greater than available"");
            unchecked { rewardsLocked -= amount; }
        }
        _transferFromContract(msg.sender, amount);
        emit AllocatedTokensTaken(amount);
    }

    // update global exchange rate
    function _updateGlobalExchangeRate() internal {
        uint128 currentBlock = uint128(block.number);
        // if the program ended, set update epoch to the end epoch
        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;
        if (currentEpoch != lastUpdateEpoch){
            // when no one has staked anything, do not update the rate
            if(totalGlobalShares > 0)
            {
                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }
            }
            lastUpdateEpoch = currentEpoch;
        }
    }

    // update validator exchange rate
    function _updateValidator(Validator storage v) internal {
        // if validator is disabled, we do not update it since it was updated during disabling transaction
        if(v.disabledEpoch == 0){
            if (v.totalShares == 0){
                // when validator stakes the first time, the exchange rate must be equal to the current global exchange rate
                v.exchangeRate = globalExchangeRate;
            }
            else {
                // the growth of global exchange rate since the validator was updated the last time
                uint128 rateDifference;
                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }
                // tokens given to the validator and its delegators since last update
                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);
                // commission paid out of the tokens
                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);
                // increase validator exchange rate by distributing the leftover tokens through the validator shares
                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);
                // give commission tokens to the validator
                unchecked { v.commissionAvailableToRedeem += commissionPaid; }
            }
            // set the last update global rate to the current one
            v.lastUpdateGlobalRate = globalExchangeRate;
        }
    }
    // used to convert global shares or validator shares to CQT
    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){
        return uint128(uint256(sharesN) * uint256(rate) / divider);
    }
    // used to convert CQT to global shares or validator shares
    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){
        return uint128(uint256(amount) * divider / uint256(rate));
    }

    function stake(uint128 validatorId, uint128 amount) public {
        _stake(validatorId, amount, true);
    }
    // need to update global exchange rate, validator data and then delegator instance
    // withTransfer set to false when delegators recover unstake, because the tokens are already in the contract
    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {
        require(amount >= divider, ""Amount must be at least 1 token"");
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is disabled"");
        // if this is the first stake, then set the end epoch
        if (endEpoch == 0){
            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }
            rewardsLocked = 0; 
            // no longer used and saves a bit of gas
        }
        require(endEpoch > block.number, ""Program ended"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // if staker is validator who self delegates
        if (msg.sender == v._address){
            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, ""Amount < min staked required"");
        }
        else {
            // otherwise need to check for max cap
            uint128 validatorStaked = v.stakings[v._address].staked;
            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;
            uint128 newDelegated = v.delegated - validatorStaked + amount;
            require(newDelegated <= validatorMaxCap, ""Validator max capacity exceeded"");
        }
        // it is set to true when there is a stake
        // it is set to false when we recover delegation from unstaking
        if (withTransfer)
            _transferToContract(msg.sender, amount);
        Staking storage s = v.stakings[msg.sender];

        // update global shares #
        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);
        unchecked { totalGlobalShares += globalSharesToAdd; }
        unchecked { v.globalShares += globalSharesToAdd; }

        // update validator shares #
        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);
        unchecked { v.totalShares += newDelegatorSharesN; }
        unchecked { s.shares += newDelegatorSharesN; }
        unchecked { v.delegated += amount; }
        unchecked { s.staked += amount; }
        emit Staked(validatorId, msg.sender, amount);
    }

    // need to update global exchange rate, validator data and then delegator instance
    function unstake(uint128 validatorId, uint128 amount) public {
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        Staking storage s = v.stakings[msg.sender];
        require(s.staked >= amount, ""Staked < amount provided"");
        bool isValidator = msg.sender == v._address;
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore
        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
        require(validatorSharesRemove > 0, ""Unstake amount is too small"");
        if (v.disabledEpoch == 0){
            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required
            if (isValidator && endEpoch > block.number){
                uint128 newValidatorStaked = s.staked - amount;
                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;
                uint128 delegated = v.delegated - s.staked;
                require(delegated <= newValidatorMaxCap, ""Cannot unstake beyond max cap"");
                require(newValidatorStaked >= validatorMinStakedRequired, ""Unstake > min staked required"");
            }

            // update global shares #
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            require(globalSharesRemove > 0, ""Unstake amount is too small"");
            unchecked { totalGlobalShares -= globalSharesRemove;}
            unchecked { v.globalShares -= globalSharesRemove; }

            // update validator shares #
            unchecked { v.totalShares -= validatorSharesRemove; }
            unchecked { v.delegated -= amount; }
        }
        unchecked { s.shares -= validatorSharesRemove; }
        unchecked { s.staked -= amount; }

        // create unstaking instance
        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);
        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }
        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));
        emit Unstaked(validatorId, msg.sender, amount);
    }

    // restake unstaked tokens
    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(validatorId, amount, false);
        us.amount -= amount;
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);
    }

    // if amount is 0 then redeem all
    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {
        require(beneficiary!=address(0x0), ""Invalid beneficiary"");
        _updateGlobalExchangeRate();
        Validator storage v = validators[validatorId];
        _updateValidator(v);
        Staking storage s = v.stakings[msg.sender];

        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
        if(msg.sender == v._address){
            if(amount == 0){
                unchecked { amount = rewards + v.commissionAvailableToRedeem; }
            }
            require(rewards + v.commissionAvailableToRedeem >= amount, ""Redeem amount > available"");
            // first redeem rewards from commission
            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;
            // if there is more, redeem  it from regular rewards
            if (commissionLeftOver == 0){
                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);
                unchecked { s.shares -= validatorSharesRemove; }
                unchecked { v.totalShares -= validatorSharesRemove; }
            }
            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);
            v.commissionAvailableToRedeem = commissionLeftOver;
        }
        else {
            if(amount == 0){
                amount = rewards;
            }
            require(rewards >= amount, ""Redeem amount > available"");
            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
            unchecked { s.shares -= validatorSharesRemove; }
            unchecked { v.totalShares -= validatorSharesRemove; }
        }
        _transferFromContract(beneficiary, amount);

        // update global shares #
        // this includes commission and rewards earned
        // only update if the validator is enabled, otherwise the shares were already excluded during disableValidator call
        if (v.disabledEpoch == 0){
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            unchecked { totalGlobalShares -= globalSharesRemove; }
            unchecked { v.globalShares -= globalSharesRemove; }
        }
        emit RewardRedeemed(validatorId, beneficiary, amount);
    }

    // redeem all available rewards
    function redeemAllRewards( uint128 validatorId, address beneficiary) external {
        _redeemRewards(validatorId, beneficiary, 0);
    }

    // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards
    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {
        require(amount > 0, ""Amount is 0"");
        _redeemRewards(validatorId, beneficiary, amount);
    }

    // add new validator instance
    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {
        require(commissionRate < divider, ""Rate must be less than 100%"");
        uint128 N = validatorsN;
        validators[N]._address = validator;
        validators[N].operator = operator;
        validators[N].commissionRate = commissionRate;
        emit ValidatorAdded(N, validator, operator);
        unchecked { validatorsN += 1; }
    }

    // can only be called by the owner or the validator, disabling will allow validator to fully unstake
    // validator instance can only be disabled once and can never be reenabled
    function disableValidator(uint128 validatorId) public {
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is already disabled"");
        require(v._address == msg.sender || msg.sender == owner(), ""Caller is not owner or validator"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;
        unchecked { totalGlobalShares -= v.globalShares; }
        emit ValidatorDisabled(validatorId);
    }

    // change emission rate, should reset end epoch
    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        uint128 toTransfer;
        if (endEpoch != 0){
            _updateGlobalExchangeRate();
            // get number of epochs from now to the end epoch
            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;
            // calculate how much rewards would be distributed with the old emission rate
            uint128 futureRewards = allocatedTokensPerEpoch * epochs;
            // calculate how many epochs will be covered
            uint128 addEpochs = futureRewards / amount;
            toTransfer = futureRewards % amount;
            require(addEpochs != 0, ""This amount will end the program"");
            unchecked { endEpoch = uint128(block.number) + addEpochs; }
        }
        else {
          toTransfer = rewardsLocked % amount;
        }
        allocatedTokensPerEpoch = amount;
        emit EmissionRateChanged(amount);
        if(toTransfer > 0)
            _transferFromContract(msg.sender, toTransfer);

    }

    // we assume that we will never set it to less than what is staked already
    function setMaxCapMultiplier(uint128 amount) public onlyOwner {
        require(amount > 0, ""Must be greater than 0"");
        maxCapMultiplier = amount;
        emit MaxCapMultiplierChanged(amount);
    }

    // only owner can change commission rate
    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {
        require(amount < divider, ""Rate must be less than 100%"");
        _updateGlobalExchangeRate();
        _updateValidator(validators[validatorId]);
        validators[validatorId].commissionRate = amount;
        emit ValidatorCommissionRateChanged(validatorId, amount);
    }

    // we are assuming there will never be a case when the owner sets the value to something extremely big and if that happens accidentally, we will just recall the function
    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {
        validatorMinStakedRequired = amount;
        emit ValidatorMinStakedRequiredChanged(amount);
    }

    // if a validator gets disabled, delegators can redelegate their tokens to another validator
    // first they need to unstake
    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {
        require(validators[oldValidatorId].disabledEpoch != 0, ""Validator is not disabled"");
        require(validators[oldValidatorId]._address != msg.sender, ""Validator cannot redelegate"");
        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(newValidatorId, amount, false);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);
    }

    // transfer out unlocked unstaked tokens back to the delegator
    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require( uint128(block.number) > us.coolDownEnd, ""Cooldown period has not ended"" );
        require(us.amount >= amount, ""Amount is too high"");
        _transferFromContract(msg.sender, amount);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if (us.amount == 0)
            us.coolDownEnd = 0;
        emit UnstakeRedeemed(validatorId, msg.sender, amount);
    }

    // returns details of each validator
    // array index is id
    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {
        commissionRates = new uint128[](validatorsN);
        delegated = new uint128[](validatorsN);
        for (uint128 i = 0; i < validatorsN; ++i){
            Validator storage v = validators[i];
            commissionRates[i] = v.commissionRate;
            delegated[i] = v.delegated - v.stakings[v._address].staked;
        }
        return (commissionRates, delegated);
    }

    // this follows the same logic as _updateGlobalExchangeRate and _updateValidator
    // array index is id of validator
    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {
       delegated = new uint128[](validatorsN);
       rewardsAvailable = new uint128[](validatorsN);
       commissionRewards = new uint128[](validatorsN);
       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;
       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;
       Validator storage v;
       Staking storage s;
        for (uint128 i = 0; i < validatorsN; ++i){
            v = validators[i];
            s = v.stakings[delegator];
            delegated[i] = s.staked;
            if (v.disabledEpoch == 0){
                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);
                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);
                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;
            }
            else {
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem;
            }
        }
        return (delegated, rewardsAvailable, commissionRewards);
    }

    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){
        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);
        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);
    }
}",5683,503,"H-01: Usage of an incorrect version of Ownbale library can potentially malfunction all onlyOwner functions. L62 M-01: reward tokens could get lost due to rounding down.  L90-98 M-03: Validator can fail to receive commission reward in redeemAllRewards. L275",3
12_CompoundMultiOracle.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../../utils/access/AccessControl.sol"";
import ""../../interfaces/vault/IOracle.sol"";
import ""../../constants/Constants.sol"";
import ""../../math/CastBytes32Bytes6.sol"";
import ""./CTokenInterface.sol"";


contract CompoundMultiOracle is IOracle, AccessControl, Constants {
    using CastBytes32Bytes6 for bytes32;

    event SourceSet(bytes6 indexed baseId, bytes6 indexed kind, address indexed source);

    uint public constant SCALE_FACTOR = 1; 
    // I think we don't need scaling for rate and chi oracles
    uint8 public constant override decimals = 18;

    mapping(bytes6 => mapping(bytes6 => address)) public sources;

    /**
     * @notice Set or reset one source
     */
    function setSource(bytes6 base, bytes6 kind, address source) external auth {
        _setSource(base, kind, source);
    }

    /**
     * @notice Set or reset an oracle source
     */
    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) external auth {
        require(bases.length == kinds.length && kinds.length == sources_.length, ""Mismatched inputs"");
        for (uint256 i = 0; i < bases.length; i++)
            _setSource(bases[i], kinds[i], sources_[i]);
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @return value
     */
    function peek(bytes32 base, bytes32 kind, uint256 amount)
        external view virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), kind.b6());
        value = price * amount / 1e18;
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.
     * @return value
     */
    function get(bytes32 base, bytes32 kind, uint256 amount)
        external virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), kind.b6());
        value = price * amount / 1e18;
    }

    function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {
        uint256 rawPrice;
        address source = sources[base][kind];
        require (source != address(0), ""Source not found"");

        if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();
        else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();
        else revert(""Unknown oracle type"");

        require(rawPrice > 0, ""Compound price is zero"");

        price = rawPrice * SCALE_FACTOR;
        updateTime = block.timestamp;
    }

    function _setSource(bytes6 base, bytes6 kind, address source) internal {
        sources[base][kind] = source;
        emit SourceSet(base, kind, source);
    }
}",673,83,M-04: User can redeem more tokens by artificially increasing the chi accrual. L132-L143,1
45_CreditLimitByMedian.sol,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../interfaces/ICreditLimitModel.sol"";

contract CreditLimitByMedian is Ownable, ICreditLimitModel {
    using Math for uint256;

    bool public constant override isCreditLimitModel = true;
    uint256 public override effectiveNumber;

    constructor(uint256 effectiveNumber_) {
        effectiveNumber = effectiveNumber_;
    }

    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {
        if (vouchs.length >= effectiveNumber) {
            return _findMedian(vouchs);
        } else {
            return 0;
        }
    }

    function getLockedAmount(
        LockedInfo[] memory array,
        address account,
        uint256 amount,
        bool isIncrease
    ) public pure override returns (uint256) {
        if (array.length == 0) return 0;

        uint256 newLockedAmount;
        if (isIncrease) {
            for (uint256 i = 0; i < array.length; i++) {
                uint256 remainingVouchingAmount;
                if (array[i].vouchingAmount > array[i].lockedAmount) {
                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;
                } else {
                    remainingVouchingAmount = 0;
                }

                if (remainingVouchingAmount > array[i].availableStakingAmount) {
                    if (array[i].availableStakingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;
                    }
                } else {
                    if (remainingVouchingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;
                    }
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        } else {
            for (uint256 i = 0; i < array.length; i++) {
                if (array[i].lockedAmount > amount) {
                    newLockedAmount = array[i].lockedAmount - 1;
                } else {
                    newLockedAmount = 0;
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        }

        return 0;
    }

    function setEffectNumber(uint256 number) external onlyOwner {
        effectiveNumber = number;
    }

    /**
     *  @dev Find median from uint array
     *  @param array array
     *  @return uint256
     */
    function _findMedian(uint256[] memory array) private pure returns (uint256) {
        uint256[] memory arr = _sortArray(array);
        if (arr.length == 0) return 0;

        if (arr.length % 2 == 0) {
            uint256 num1 = arr[arr.length >> 1];
            uint256 num2 = arr[(arr.length >> 1) - 1];
            return num1.average(num2);
        } else {
            return arr[arr.length >> 1];
        }
    }

    /**
     *  @dev Sort uint array
     *  @param arr array
     *  @return uint256 array
     */
    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {
        uint256 length = arr.length;

        for (uint256 i = 0; i < length; i++) {
            for (uint256 j = i + 1; j < length; j++) {
                if (arr[i] < arr[j]) {
                    uint256 temp = arr[j];
                    arr[j] = arr[i];
                    arr[i] = temp;
                }
            }
        }

        return arr;
    }
}",861,123,"H-02: Wrong implementation of CreditLimitByMedian.sol#getLockedAmount() makes it unable to unlock lockedAmount in CreditLimitByMedian model.  L27-L78 M-01: Wrong implementation of CreditLimitByMedian.sol#getLockedAmount() will lock a much bigger total amount of staked tokens than expected.  L27-L63 M-08: MAX_TRUST_LIMIT might be too high",3
,,,,,349